<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>python | czz🕉️</title><meta name="keywords" content="python"><meta name="author" content="czz🕉️"><meta name="copyright" content="czz🕉️"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Python 基础语法 字面量 字面量：在代码中，被 写下来 的的固定的 值，称之为字面量 Python 中常用的有 6 种值（数据）的类型    类型 描述 说明     数字（Number） •整数（int）  •浮点数（float）  •复数（complex）  •布尔（bool） 整数（int），如：10、-10    浮点数（float），如：13.14、-13.14    复数（com">
<meta property="og:type" content="article">
<meta property="og:title" content="python">
<meta property="og:url" content="https://www.fomal.cc/posts/a4d4b8.html">
<meta property="og:site_name" content="czz🕉️">
<meta property="og:description" content="Python 基础语法 字面量 字面量：在代码中，被 写下来 的的固定的 值，称之为字面量 Python 中常用的有 6 种值（数据）的类型    类型 描述 说明     数字（Number） •整数（int）  •浮点数（float）  •复数（complex）  •布尔（bool） 整数（int），如：10、-10    浮点数（float），如：13.14、-13.14    复数（com">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://bu.dusays.com/2024/04/08/6613760da5b06.png">
<meta property="article:published_time" content="2023-01-14T09:15:26.000Z">
<meta property="article:modified_time" content="2025-05-10T07:23:27.045Z">
<meta property="article:author" content="czz🕉️">
<meta property="article:tag" content="python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bu.dusays.com/2024/04/08/6613760da5b06.png"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://www.fomal.cc/posts/a4d4b8"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/font-awesome/6.0.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'python',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-05-10 15:23:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://cdn1.tianli0.top/npm/element-ui@2.15.6/packages/theme-chalk/lib/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="czz🕉️" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/05/08/6458dafb3921a.gif" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">czz🕉️</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">python</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2023-01-14T09:15:26.000Z" title="发表于 2023-01-14 17:15:26">2023-01-14</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-10T07:23:27.045Z" title="更新于 2025-05-10 15:23:27">2025-05-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/python/">python</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">6w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>212分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="python"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="Python-基础语法">Python 基础语法</h2>
<h3 id="字面量">字面量</h3>
<p>字面量：在代码中，被 <strong>写下来</strong> 的的固定的 <strong>值</strong>，称之为字面量</p>
<p>Python 中常用的有 <strong>6</strong> 种值（数据）的类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>数字（Number）</td>
<td>•整数（int）  •浮点数（float）  •复数（complex）  •布尔（bool）</td>
<td style="text-align:left">整数（int），如：10、-10    浮点数（float），如：13.14、-13.14    复数（complex），如：4+3j，以 j 结尾表示复数    布尔（bool）表达现实生活中的逻辑，即真和假，True 表示真，False 表示假。  True 本质上是一个数字记作 1，False 记作 0</td>
</tr>
<tr>
<td>字符串（String）</td>
<td>描述文本的一种数据类型</td>
<td style="text-align:left">字符串（string）由任意数量的字符组成</td>
</tr>
<tr>
<td>列表（List）</td>
<td>有序的可变序列</td>
<td style="text-align:left">Python 中使用最频繁的数据类型，可有序记录一堆数据</td>
</tr>
<tr>
<td>元组（Tuple）</td>
<td>有序的不可变序列</td>
<td style="text-align:left">可有序记录一堆不可变的 Python 数据集合</td>
</tr>
<tr>
<td>集合（Set）</td>
<td>无序不重复集合</td>
<td style="text-align:left">可无序记录一堆不重复的 Python 数据集合</td>
</tr>
<tr>
<td>字典（Dictionary）</td>
<td>无序 Key-Value 集合</td>
<td style="text-align:left">可无序记录一堆 Key-Value 型的 Python 数据集合</td>
</tr>
</tbody>
</table>
<h3 id="注释">注释</h3>
<ul>
<li>单行注释</li>
</ul>
<p>​	<code> # 我是注释</code></p>
<ul>
<li>
<p>多行注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">``` 我是多行注释</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="变量">变量</h3>
<p>变量：在程序运行时，能储存计算结果或能表示值的抽象概念。<br>
简单的说，变量就是在程序运行时，记录数据用的</p>
<p>变量的目的是存储运行过程的数据<br>
存储的目的是为了：重复使用</p>
<h3 id="数据类型">数据类型</h3>
<p>掌握使用type()语句查看数据的类型<br>
理解变量无类型而数据有类型的概念</p>
<p>目前在入门阶段，我们主要接触如下三类数据类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>string</strong></td>
<td>字符串类型</td>
<td>用引号引起来的数据都是字符串</td>
</tr>
<tr>
<td><strong>int</strong></td>
<td>整型（有符号）</td>
<td>数字类型，存放整数 如 -1,10, 0 等</td>
</tr>
<tr>
<td><strong>float</strong></td>
<td>浮点型（有符号）</td>
<td>数字类型，存放小数 如 -3.14, 6.66</td>
</tr>
</tbody>
</table>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e527b337.png" alt=""></p>
<p>我们通过type(变量)可以输出类型，这是查看变量的类型还是数据的类型？</p>
<p>查看的是：<strong>变量存储的数据的类型。因为，变量无类型，但是它存储的数据有。</strong></p>
<h3 id="数据类型转换">数据类型转换</h3>
<p>数据类型转换，将会是我们以后经常使用的功能。<br>
如：</p>
<ul>
<li>从文件中读取的数字，默认是字符串，我们需要转换成数字类型</li>
<li>后续学习的input()语句，默认结果是字符串，若需要数字也需要转换</li>
<li>将数字转换成字符串用以写出到外部系统</li>
<li>等等</li>
</ul>
<table>
<thead>
<tr>
<th>语句(函数)</th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>int(x)</td>
<td>将x转换为一个整数</td>
</tr>
<tr>
<td>float(x)</td>
<td>将x转换为一个浮点数</td>
</tr>
<tr>
<td>str(x)</td>
<td>将对象  x 转换为字符串</td>
</tr>
</tbody>
</table>
<p>同前面学习的type()语句一样，这三个语句，都是带有结果的（返回值）<br>
我们可以用print直接输出<br>
或用变量存储结果值</p>
<ul>
<li>
<p>注意</p>
<ol>
<li>
<p>任何类型，都可以通过str()，转换成字符串</p>
</li>
<li>
<p>字符串内必须真的是数字，才可以将字符串转换为数字</p>
</li>
</ol>
</li>
</ul>
<h3 id="标识符">标识符</h3>
<p>在Python程序中，我们可以给很多东西起名字，比如：</p>
<ul>
<li>变量的名字</li>
<li>方法的名字</li>
<li>类的名字,等等</li>
</ul>
<p>这些名字，我们把它统一的称之为标识符，用来做内容的标识。<br>
所以，标识符：是用户在编程的时候所使用的一系列名字，用于给变量、类、方法等命名。</p>
<p>Python中，标识符命名的规则主要有3类：</p>
<p>•<strong>内容限定</strong></p>
<p>•<strong>大小写敏感</strong></p>
<p>•<strong>不可使用关键字</strong></p>
<p>标识符命名中，只允许出现：</p>
<ul>
<li>英文</li>
<li>中文</li>
<li>数字</li>
<li>下划线（_）</li>
</ul>
<p>这四类元素。</p>
<p>其余任何内容都不被允许。</p>
<blockquote>
<p>注意：1. 不推荐使用中文</p>
<p>​           2. 数字不可以开头</p>
</blockquote>
<ul>
<li>Python中有一系列单词，称之为关键字<br>
关键字在Python中都有特定用途<br>
我们不可以使用它们作为标识符</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e7244c5b.png" alt=" "></p>
<ul>
<li>命名规范
<ol>
<li>下划线命名法</li>
<li>驼峰命名法</li>
</ol>
</li>
</ul>
<h3 id="运算符">运算符</h3>
<p>了解Python中常见</p>
<ul>
<li>
<p>算术（数学）运算符</p>
</li>
<li>
<p>赋值运算符</p>
</li>
</ul>
<p><strong>算术（数学）运算符</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>加</td>
<td>两个对象相加  a + b 输出结果  30</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
<td>得到负数或是一个数减去另一个数  a - b 输出结果  -10</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
<td>两个数相乘或是返回一个被重复若干次的字符串  a * b 输出结果  200</td>
</tr>
<tr>
<td>/</td>
<td>除</td>
<td>b /  a 输出结果 2</td>
</tr>
<tr>
<td>//</td>
<td>取整除</td>
<td>返回商的整数部分  9//2 输出结果  4 , 9.0//2.0 输出结果  4.0</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
<td>返回除法的余数  b % a 输出结果  0</td>
</tr>
<tr>
<td>**</td>
<td>指数</td>
<td>a**b  为10的20次方，  输出结果 100000000000000000000</td>
</tr>
</tbody>
</table>
<p><strong>赋值运算符</strong></p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>描述</strong></th>
<th><strong>实例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>赋值运算符</td>
<td>把 =  号右边的结果 赋给 左边的变量，如 num  = 1 + 2 * 3，结果num的值为7</td>
</tr>
</tbody>
</table>
<p><strong>复合赋值运算符</strong></p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>描述</strong></th>
<th><strong>实例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>+=</td>
<td>加法赋值运算符</td>
<td>c  += a 等效于 c =  c + a</td>
</tr>
<tr>
<td>-=</td>
<td>减法赋值运算符</td>
<td>c  -= a 等效于 c =  c - a</td>
</tr>
<tr>
<td>*=</td>
<td>乘法赋值运算符</td>
<td>c  *= a 等效于 c =  c * a</td>
</tr>
<tr>
<td>/=</td>
<td>除法赋值运算符</td>
<td>c  /= a 等效于 c =  c / a</td>
</tr>
<tr>
<td>%=</td>
<td>取模赋值运算符</td>
<td>c  %= a 等效于 c =  c % a</td>
</tr>
<tr>
<td>**=</td>
<td>幂赋值运算符</td>
<td>c  **= a 等效于 c =  c ** a</td>
</tr>
<tr>
<td>//=</td>
<td>取整除赋值运算符</td>
<td>c  //= a 等效于 c =  c // a</td>
</tr>
</tbody>
</table>
<h3 id="字符串扩展">字符串扩展</h3>
<p>==<strong>字符串的三种定义方式</strong>==</p>
<ul>
<li>字符串在Python中有多种定义形式：</li>
</ul>
<ol>
<li>
<p>单引号定义法</p>
</li>
<li>
<p>双引号定义法</p>
</li>
<li>
<p>三引号定义法</p>
</li>
</ol>
<blockquote>
<p>三引号定义法，和多行注释的写法一样，同样支持换行操作。</p>
<p>使用变量接收它，它就是字符串</p>
<p>不使用变量接收它，就可以作为多行注释使用。</p>
</blockquote>
<p><strong>字符串的引号嵌套</strong></p>
<ul>
<li>
<p>单引号定义法，可以内含双引号</p>
</li>
<li>
<p>双引号定义法，可以内含单引号</p>
</li>
<li>
<p>可以使用转移字符（\）来将引号解除效用，变成普通字符串</p>
</li>
</ul>
<p>==<strong>字符串拼接</strong>==</p>
<p>如果我们有两个字符串（文本）字面量，可以将其拼接成一个字符串，通过+号即可完成，如：</p>
<p><code>print(&quot;学IT来黑马&quot; + &quot;月薪过万&quot;)</code></p>
<p>不过一般，单纯的2个字符串字面量进行拼接显得很呆，一般，字面量和变量或变量和变量之间会使用拼接，如：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e731200d.png" alt=" "></p>
<p>既然可以和字符串变量完成拼接，那么，是否可以和其它变量类型如数字类型完成拼接呢</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e73c9f1c.png" alt=" "></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e74c116d.png" alt=" "></p>
<blockquote>
<p><strong>字符串无法和非字符串变量进行拼接</strong><br>
因为类型不一致，无法接上<br>
就像接力赛一样，不是队友，不能接力的哦</p>
</blockquote>
<p>==<strong>字符串格式化</strong>==</p>
<p>我们会发现，这个拼接字符串也不好用啊</p>
<ol>
<li>
<p>变量过多，拼接起来实在是太麻烦了</p>
</li>
<li>
<p><strong>字符串无法和数字或其它类型完成拼接。</strong></p>
</li>
</ol>
<ul>
<li>掌握通过占位的形式拼接字符串（字符串格式化）</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e75973d0.png" alt=" "></p>
<p>其中的，%s</p>
<ul>
<li>
<p>% 表示：我要占位</p>
</li>
<li>
<p>s  表示：将变量<strong>变成字符串</strong>放入占位的地方</p>
</li>
</ul>
<p>数字也能用%s占位吗？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e7673e4f.png" alt=" "></p>
<p>可以的哦，这里是将数字 转换成了 字符串哦</p>
<p>也就是数字57，变成了字符串&quot;57&quot;被放入占位的地方</p>
<blockquote>
<p>多个变量占位</p>
<p>变量要用括号括起来</p>
<p>并按照占位的顺序填入</p>
</blockquote>
<p>数字类型，也太没有地位了吧，竟然要被转成字符串拼接。</p>
<p>有没有体面一点的方式，让数字以其原本的面貌拼接进去呢？</p>
<p>安排。</p>
<p>Python中，其实支持非常多的数据类型占位</p>
<p>最常用的是如下三类</p>
<table>
<thead>
<tr>
<th>格式符号</th>
<th>转化</th>
</tr>
</thead>
<tbody>
<tr>
<td>%s</td>
<td>将内容转换成字符串，放入占位位置</td>
</tr>
<tr>
<td>%d</td>
<td>将内容转换成整数，放入占位位置</td>
</tr>
<tr>
<td>%f</td>
<td>将内容转换成浮点型，放入占位位置</td>
</tr>
</tbody>
</table>
<p>如下代码，完成字符串、整数、浮点数，三种不同类型变量的占位</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e776d680.png" alt=" "></p>
<p>==<strong>格式化的精度控制</strong>==</p>
<p>细心的同学可能会发现：</p>
<p>浮点数19.99，变成了19.990000输出</p>
<p>这里我们就要讲解一下，字符串格式化之“数字精度控制”</p>
<p><u>我们可以使用辅助符号&quot;m.n&quot;来控制数据的宽度和精度</u></p>
<ul>
<li>
<p>m，控制宽度，要求是数字（很少使用）,设置的宽度小于数字自身，不生效</p>
</li>
<li>
<p>.n(有个点)，控制小数点精度，要求是数字，会进行小数的<u>四舍五入</u></p>
</li>
</ul>
<p>示例：</p>
<ul>
<li>
<p>%5d：表示将整数的宽度控制在5位，如数字11，被设置为5d，就会变成：[空格][空格][空格]11，用三个空格补足宽度。</p>
</li>
<li>
<p>%5.2f：表示将宽度控制为5，将小数点精度设置为2</p>
<p>小数点和小数部分也算入宽度计算。如，对11.345设置了%7.2f 后，结果是：[空格][空格]11.35。2个空格补足宽度，小数部分限制2位精度后，四舍五入为 .35</p>
</li>
<li>
<p>%.2f：表示不限制宽度，只设置小数点精度为2，如11.345设置%.2f后，结果是11.35</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e787418a.png" alt=" "></p>
<p>==<strong>字符串格式化方式2</strong>==</p>
<p>目前通过%符号占位已经很方便了，还能进行精度控制。</p>
<p>可是追求效率和优雅的Python，是否有更加优雅的方式解决问题呢？</p>
<p>那当然：有</p>
<ul>
<li>通过语法：f&quot;内容{变量}&quot;的格式来快速格式化</li>
</ul>
<p>看如下代码</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e793dda6.png" alt=" "></p>
<blockquote>
<p>这种写法不做精度控制</p>
<p>也不理会类型</p>
<p>适用于快速格式化字符串</p>
</blockquote>
<p>==<strong>对表达式进行格式化</strong>==</p>
<p>刚刚的演示，都是基于变量的。</p>
<p>可是，我想更加优雅些，少写点代码，直接对“表达式”进行格式化是否可行呢？</p>
<p>那么，我们先了解一下什么是表达式。</p>
<p><strong>表达式：一条具有明确执行结果的代码语句</strong></p>
<p>如：</p>
<p>1 + 1、5 * 2，就是表达式，因为有具体的结果，结果是一个数字</p>
<p>又或者，常见的变量定义：</p>
<p>name = “张三”   age = 11 + 11</p>
<p>等号右侧的都是表达式呢，因为它们有具体的结果，结果赋值给了等号左侧的变量。</p>
<p>那么，对于字符串格式化，能否直接格式化一个表达式呢？</p>
<p>可以，上代码：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e7a2e9f2.png" alt=" "></p>
<blockquote>
<p>在无需使用变量进行数据存储的时候，可以直接格式化表达式，简化代码哦</p>
</blockquote>
<h3 id="数据输入">数据输入</h3>
<p>我们前面学习过print语句（函数），可以完成将内容（字面量、变量等）输出到屏幕上。</p>
<p>在Python中，与之对应的还有一个input语句，用来获取键盘输入。</p>
<ul>
<li>
<p>数据输出：print</p>
</li>
<li>
<p>数据输入：input</p>
</li>
</ul>
<p>使用上也非常简单：</p>
<ul>
<li>使用input()语句可以从键盘获取输入</li>
<li>使用一个变量接收（存储）input语句获取的键盘输入数据即可</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e7aeb440.png" alt=" "></p>
<blockquote>
<p>input()语句其实是可以在要求使用者输入内容前，输出提示内容的哦，input的括号内直接填入提示内容即可。</p>
</blockquote>
<p><strong>input语句获取的数据类型</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e7c1b21a.png" alt=" "></p>
<p>可以看到，无论键盘输入何种类型的数据</p>
<p><strong>最终的结果都是：字符串类型的数据</strong></p>
<h3 id="转义字符（必须是反斜杠）">转义字符（必须是反斜杠）</h3>
<p>什么是转义字符？</p>
<p>运行如下代码，看看结果是什么：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;abcnABC&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;abc\nABC&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果是：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">abcnABC</span></span><br><span class="line"><span class="attribute">abc</span></span><br><span class="line"><span class="attribute">ABC</span></span><br></pre></td></tr></table></figure>
<p>仔细观察会发现，第2个打印中的字母n没有输出，而第1个的打印有字母n，为什么？</p>
<p>答：有些特殊的字母像n，如果在前面加上了一个反斜杠<code>\</code>，那么此时<code>\n</code>就有特殊功能了”换行“</p>
<p>除了<code>\n</code>表示换行以外，常用的还有<code>\t</code>表示一个tab键的间距。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;abc\tABC&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>输出的效果：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">abc    ABC</span></span><br></pre></td></tr></table></figure>
<ul>
<li>换行符(<code>\n</code>)：表示将光标移动到<strong>下一行</strong>，通常是移动到下一行的行首。ASCII码为10。</li>
<li>回车符(<code>\r</code>) ：表示将光标移动到<strong>当前行</strong>的行首。ASCII码为13。</li>
</ul>
<h2 id="Python判断语句">Python判断语句</h2>
<h3 id="布尔类型和比较、逻辑运算符">布尔类型和比较、逻辑运算符</h3>
<p>掌握布尔类型用于表示：真和假</p>
<p>掌握比较运算符用于计算：真和假</p>
<ul>
<li>
<p>布尔类型的字面量：</p>
<ol>
<li>True 表示真（是、肯定）</li>
<li>False 表示假 （否、否定）</li>
</ol>
</li>
<li>
<p>定义变量存储布尔类型数据：</p>
</li>
</ul>
<p>​		<code>变量名称 = 布尔类型字面量</code></p>
<blockquote>
<p>布尔类型不仅可以自行定义</p>
<p>同时也可以通过计算的来。</p>
<p>也就是使用<strong>比较运算符进行比较运算得到布尔类型的结果。</strong></p>
</blockquote>
<p>如下代码：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e7ce1741.png" alt=" "><br>
<strong>比较运算符的分类</strong></p>
<table>
<thead>
<tr>
<th><strong>运算符</strong></th>
<th><strong>描述</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>==</strong></td>
<td>判断内容是否相等，满足为True，不满足为False</td>
<td>如a=3,b=3，则(a  == b)  为  True</td>
</tr>
<tr>
<td>!=</td>
<td>判断内容是否不相等，满足为True，不满足为False</td>
<td>如a=1,b=3，则(a  != b) 为  True</td>
</tr>
<tr>
<td>&gt;</td>
<td>判断运算符左侧内容是否大于右侧  满足为True，不满足为False</td>
<td>如a=7,b=3，则(a  &gt; b)  为 True</td>
</tr>
<tr>
<td>&lt;</td>
<td>判断运算符左侧内容是否小于右侧  满足为True，不满足为False</td>
<td>如a=3,b=7，则(a  &lt; b)  为 True</td>
</tr>
<tr>
<td>&gt;=</td>
<td>判断运算符左侧内容是否大于等于右侧  满足为True，不满足为False</td>
<td>如a=3,b=3，则(a  &gt;= b) 为  True</td>
</tr>
<tr>
<td>&lt;=</td>
<td>判断运算符左侧内容是否小于等于右侧  满足为True，不满足为False</td>
<td>如a=3,b=3，则(a  &lt;= b) 为  True</td>
</tr>
</tbody>
</table>
<p><strong>逻辑运算符的简单使用</strong></p>
<p><strong>and</strong></p>
<p>实现<code>并</code>的功能，通俗的说就是<code>并且</code></p>
<p>一般的用法：两边都为<code>True</code>，结果才为<code>True</code></p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> &gt; <span class="number">50</span> <span class="keyword">and</span> <span class="number">90</span> &lt; <span class="number">200</span>  <span class="comment"># 100 &gt; 50 结果为 True  90 &lt; 200 结果为 True，就相当于 True and True 所以最后结果是 True</span></span><br></pre></td></tr></table></figure>
<p><strong>or</strong></p>
<p>实现<code>或</code>的功能，通俗的说就是<code>或者</code></p>
<p>一般的用法：两边只要有一个<code>True</code>，结果就为<code>True</code></p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span> &gt; <span class="number">50</span> <span class="keyword">or</span> <span class="number">90</span> &gt; <span class="number">200</span>  <span class="comment"># 100 &gt; 50 结果为 True  90 &gt; 200 结果为 False，就相当于 True or False 所以最后结果是 True</span></span><br></pre></td></tr></table></figure>
<p><strong>not</strong></p>
<p>实现<code>非</code>的功能，通俗的说就是<code>不</code></p>
<p>一般的用法：之前结果为<code>True</code>，那么<code>not True</code>就是<code>False</code>，如果之前是<code>False</code>，那么<code>not False</code>就是<code>True</code></p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">not</span> (<span class="number">100</span> &gt; <span class="number">50</span>)  <span class="comment"># 结果为 False，本来 100 &gt; 50 的结果是 True, 但前面加了 not 就相当于反义，所以最后结果为 False</span></span><br><span class="line"><span class="keyword">not</span> (<span class="number">100</span> &lt; <span class="number">50</span>)  <span class="comment"># 结果为 True, 本来 100 &lt; 50 的结果是 False, 但前面加了 not 其反义的作用，所以最后结果是 True</span></span><br></pre></td></tr></table></figure>
<p><strong>逻辑运算符与比较运算符一起使用</strong></p>
<p>示例一：</p>
<ul>
<li>需求：怎样判断用户名与密码同时都相同呢？</li>
</ul>
<p>参考代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名：&quot;</span>)  <span class="comment"># 获取用户名</span></span><br><span class="line">password = <span class="built_in">input</span>(<span class="string">&quot;请输入密码：&quot;</span>)  <span class="comment"># 获取密码</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;用户名和密码能校验通过吗？&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(name == <span class="string">&quot;顾安&quot;</span> <span class="keyword">and</span> password == <span class="string">&quot;123456&quot;</span>)  <span class="comment"># 输出用户名与密码是否相同</span></span><br></pre></td></tr></table></figure>
<p>示例二：</p>
<ul>
<li>需求：怎样实现老板或者领导就能开门呢？</li>
</ul>
<p>参考代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">role = <span class="string">&quot;老板&quot;</span>  <span class="comment"># 定义角色变量，存储职位</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;能开门吗？&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(role == <span class="string">&quot;老板&quot;</span> <span class="keyword">or</span> role == <span class="string">&quot;领导&quot;</span>)  <span class="comment"># 输出结果</span></span><br></pre></td></tr></table></figure>
<p>示例三：</p>
<ul>
<li>需求：怎样实现不小于18岁的判断呢？</li>
</ul>
<p>参考代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;大于 18 岁吗？&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(age &gt; <span class="number">18</span>)  <span class="comment"># 方式一：直接用比较运算符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span>(age &lt;= <span class="number">18</span>))  <span class="comment"># 方式二：用了比较运算符与逻辑运算符</span></span><br></pre></td></tr></table></figure>
<p>示例四：</p>
<ul>
<li>需求：年龄在18~50之间的女性</li>
</ul>
<p>参考代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">20</span></span><br><span class="line">gender = <span class="string">&quot;女性&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;符合要求吗？&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">18</span> &lt;= age &lt;= <span class="number">50</span> <span class="keyword">and</span> gender == <span class="string">&quot; 女性 &quot;</span>)  <span class="comment"># 方式 1：简单的写法</span></span><br><span class="line"><span class="built_in">print</span>(age &gt;= <span class="number">18</span> <span class="keyword">and</span> age &lt;= <span class="number">50</span> <span class="keyword">and</span> gender == <span class="string">&quot; 女性 &quot;</span>)  <span class="comment"># 方式 2：一般的写法</span></span><br></pre></td></tr></table></figure>
<p>示例五：</p>
<ul>
<li>需求：年龄在18~60岁之间的男性或者年龄在18~50岁之间的女性</li>
</ul>
<p>参考代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">20</span></span><br><span class="line">gender = <span class="string">&quot;男性&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;符合要求吗？&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>((<span class="number">18</span> &lt;= age &lt;= <span class="number">50</span> <span class="keyword">and</span> gender == <span class="string">&quot; 女性 &quot;</span>) <span class="keyword">or</span> (<span class="number">18</span> &lt;= age &lt;= <span class="number">60</span> <span class="keyword">and</span> gender == <span class="string">&quot; 男性 &quot;</span>))</span><br></pre></td></tr></table></figure>
<p><strong>特殊情况下的逻辑运算符</strong></p>
<p>我们一般用逻辑运算符时，左右两边的结果是<code>True</code>或者<code>False</code>，最后得到一个<code>True</code>或者<code>False</code></p>
<p>但，有时逻辑运算符的左右两边不是<code>True</code>或者<code>False</code>，这种情况我们就需要小心一点</p>
<p><strong>and</strong></p>
<p>看下面的示例，猜猜看，结果是多少</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">100</span> <span class="keyword">and</span> <span class="number">200</span>)  <span class="comment"># 输出什么呢？</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">100</span> <span class="keyword">and</span> <span class="number">100</span> &gt; <span class="number">50</span>)  <span class="comment"># 输出什么呢？</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">and</span> <span class="number">200</span>)  <span class="comment"># 输出什么呢？</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">and</span> <span class="number">100</span> &gt; <span class="number">50</span>)  <span class="comment"># 输出什么呢？</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">200</span><br><span class="line">True</span><br><span class="line">0</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>为什么呢？</p>
<p>答：想要搞懂这个问题，需要有2点</p>
<p>第1点：</p>
<p>Python中是有布尔类型的也就是<code>True</code>和<code>False</code> 用<code>True</code>表示<code>真</code> 用<code>False</code>表示<code>假</code>，而在一些其它编程语言中没有，例如C语言中是没有布尔类型的，因此C语言为了能够表示出<code>真</code>、<code>假</code>，就发明了一个规定，只要数字<code>不是0 </code>无论是正数还是负数 统统表示<code>真</code>，只要是<code>0</code>就表示<code>假</code>。</p>
<p>后来，虽然Python发明了<code>True</code>和<code>False</code>，但它依然保留了C语言中的这种开发者都已经习以为常的习惯，所以Python中也用</p>
<ul>
<li>非0表示 <code>真</code></li>
<li>0表示<code>假</code></li>
</ul>
<p>第2点：</p>
<p>我们知道<code>and</code>实现的是两边都是<code>True</code>最后结果才是<code>True</code>，否则是<code>False</code>，但是它有个隐藏的功能，</p>
<p>如果左边的表达式不是<code>True</code>那么右边根本不会执行，且将左侧的值当做最后结果</p>
<p><strong>如果左边的表达式是<code>True</code>那么右边才会执行，且将右侧的值当做最后的结果</strong></p>
<p>之所以有这个隐藏的功能是因为：<code>and</code>是<code>与</code>的功能，既然左侧已经为<code>假</code>了，也就没有必要看右边了，结果一定是<code>假</code>，只不过此时把左侧的结果当做最后结果而已</p>
<p>根据上述2点来看：</p>
<ul>
<li>
<p><code>print(100 and 200)</code>，因为100不是0 所以<code>and</code>左边为<code>真</code>，接下来执行右边，此时将200当做最后的结果</p>
</li>
<li>
<p><code>print(100 and 100&gt;50)</code>，因为100不是0 所以为<code>真</code>，执行右边 <code>100&gt;50</code>且将它的结果当做最后的结果，所以最后为<code>True</code></p>
</li>
<li>
<p><code>print(0 and 200)</code>，因为<code>and</code>左侧为0 所以为<code>假</code>，不会执行右边，且将左边的结果当做最后结果，所以最后为0</p>
</li>
<li>
<p><code>print(0 and 100&gt;50)</code>，原因与上一条一样，结果为0</p>
</li>
</ul>
<p><strong>or</strong></p>
<p>有了前面<code>and</code>的额外经验，我们再看<code>or</code>时就简单多了</p>
<p><code>or</code>的特殊规则如下:</p>
<ul>
<li>如果左边为<code>真</code>，那么就把左边的值当做最后的结果</li>
<li>如果左右为<code>假</code>，那么就把右边的值当做最后的结果</li>
</ul>
<p><code>or</code>之所以有这样功能是因为：<code>or</code>是<code>或</code>的功能，既然左侧已经为<code>真</code>了，也就没有必要看右边了，结果一定是<code>真</code>，只不过此时把左侧的结果当做最后结果而已</p>
<p>代码示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">100</span> <span class="keyword">or</span> <span class="number">200</span>)  <span class="comment"># 输出什么呢？</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">100</span> <span class="keyword">or</span> <span class="number">100</span> &gt; <span class="number">50</span>)  <span class="comment"># 输出什么呢？</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">or</span> <span class="number">200</span>)  <span class="comment"># 输出什么呢？</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">or</span> <span class="number">100</span> &gt; <span class="number">50</span>)  <span class="comment"># 输出什么呢？</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><strong>总结</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">逻辑运算符</th>
<th style="text-align:left">表达式</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>and</code></td>
<td style="text-align:left"><code>x and y</code></td>
<td style="text-align:left">布尔&quot;与&quot;：如果 <code>x </code>为<code> False</code>，<code>x and y </code>返回<code> False</code>，否则它返回 <code>y </code>的值</td>
<td style="text-align:left"><code>True and False</code>， 返回<code> False</code></td>
</tr>
<tr>
<td style="text-align:left"><code>or</code></td>
<td style="text-align:left"><code>x or y</code></td>
<td style="text-align:left">布尔&quot;或&quot;：如果 <code>x</code> 是<code> True</code>，它返回<code> True</code>，否则它返回 <code>y</code> 的值</td>
<td style="text-align:left"><code>False or True</code>， 返回<code> True</code></td>
</tr>
<tr>
<td style="text-align:left"><code>not</code></td>
<td style="text-align:left"><code>not x</code></td>
<td style="text-align:left">布尔&quot;非&quot;：如果 <code>x</code> 为 <code>True</code>，返回 <code>False</code> 。如果 <code>x</code> 为 <code>False</code>，它返回 <code>True</code></td>
<td style="text-align:left"><code>not True</code> 返回<code> False</code>, <code>not False</code> 返回 <code>True</code></td>
</tr>
</tbody>
</table>
<h3 id="if语句的基本格式">if语句的基本格式</h3>
<p>掌握逻辑判断语句（if）的基本语法格式</p>
<p>掌握布尔类型数据，在判断语句中的作用</p>
<ol>
<li>if语句的基本格式 （<strong>冒号加空格</strong> ‘冒空’）</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e7d9489d.png" alt=" "></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e7e7684b.png" alt=" "></p>
<ol start="2">
<li>if语句的注意事项：
<ul>
<li>判断条件的结果一定要是布尔类型</li>
<li>不要忘记判断条件后的： 冒号</li>
<li>归属于if语句的代码块，需在前方填充4个空格缩进</li>
</ul>
</li>
</ol>
<h3 id="if-else-语句">if else 语句</h3>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e7f9b532.png" alt=" "></p>
<p><strong>if else语句注意点</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e8095bd7.png" alt=" "></p>
<blockquote>
<ol>
<li>else后，不需要判断条件</li>
<li>和if的代码块一样，else的代码块同样需要4个空格作为缩进</li>
</ol>
</blockquote>
<h3 id="if-elif-else语句">if elif else语句</h3>
<p>某些场景下，判断条件不止一个，可能有多个。</p>
<p>这种需求能用Python实现吗？</p>
<p><strong>if elif else 语句可以实现</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e81ba1cf.png" alt=" " style="zoom:50%;" />
<blockquote>
<p>elif 语句可以写多个。</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e82e2004.png" alt=" " style="zoom:50%;" />
<p>判断是互斥且有顺序的。</p>
<ul>
<li>满足1（如图编号）将不会理会2和3</li>
<li>满足2，将不会理会3</li>
<li>1、2、3均不满足，进入else</li>
<li>else也可以省略不写，效果等同3个独立的if判断</li>
<li>空格缩进同样不可省略</li>
</ul>
<h3 id="判断语句的嵌套">判断语句的嵌套</h3>
<p>掌握Python判断语句的终极用法：嵌套使用</p>
<p>有很多场景，不仅仅是多个并列条件，还会有满足前置条件才会二次判断的多层判断需求。</p>
<p><strong>对这种需求，嵌套判断语句可以实现</strong></p>
<p>基础语法格式如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e83abfc7.png" alt=" "></p>
<p>如上图，第二个if，属于第一个if内，只有第一个if满足条件，才会执行第二个if</p>
<ul>
<li>
<p>嵌套的关键点，在于：<strong>空格缩进</strong></p>
</li>
<li>
<p>通过空格缩进，来决定语句之间的：<strong>层次关系</strong></p>
</li>
</ul>
<h2 id="Python循环语句">Python循环语句</h2>
<p>循环在程序中同判断一样，也是广泛存在的，是非常多功能实现的基础：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e84a2043.png" alt=" "></p>
<h3 id="while循环的基础语法">while循环的基础语法</h3>
<p>掌握使用while循环的基础应用</p>
<p>程序中的循环</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e85741df.png" alt=" "></p>
<blockquote>
<p>只要条件满足<br>
会无限循环执行</p>
<p><strong>冒号+空格</strong></p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">100</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;小美，我喜欢你&quot;</span>)</span><br><span class="line">	i += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>while的条件需得到布尔类型，True表示继续循环，False表示结束循环</p>
</li>
<li>
<p>需要设置循环终止的条件，如i += 1配合 i &lt; 100，就能确保100次后停止，否则将无限循环</p>
</li>
<li>
<p>空格缩进和if判断一样，都需要设置</p>
</li>
</ol>
<h3 id="while循环的基础案例">while循环的基础案例</h3>
<p>能够使用while循环，完成猜数字案例</p>
<p>设置一个范围1-100的随机整数变量，通过while循环，配合input语句，判断输入的数字是否等于随机数</p>
<ul>
<li>无限次机会，直到猜中为止</li>
<li>每一次猜不中，会提示大了或小了</li>
<li>猜完数字后，提示猜了几次</li>
</ul>
<p>提示：</p>
<ul>
<li>无限次机会，终止条件不适合用数字累加来判断</li>
<li>可以考虑布尔类型本身（True or False）</li>
<li>需要提示几次猜中，就需要提供数字累加功能</li>
</ul>
<p>随机数可以使用：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e862e0ba.png" alt=" "></p>
<h3 id="while循环的嵌套应用">while循环的嵌套应用</h3>
<ol>
<li>
<p>掌握while嵌套循环基本格式</p>
</li>
<li>
<p>完成while嵌套循环的应用</p>
</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e8719771.png" alt=" " style="zoom:50%;" />
<ul>
<li>
<p>同判断语句的嵌套一样，循环语句的嵌套，要注意空格缩进。</p>
</li>
<li>
<p><strong>基于空格缩进来决定层次关系</strong></p>
</li>
<li>
<p>注意条件的设置，避免出现无限循环（除非真的需要无限循环）</p>
</li>
</ul>
<h3 id="while循环的嵌套案例">while循环的嵌套案例</h3>
<p>1.掌握使用while嵌套循环，打印九九乘法表</p>
<p><strong>补充知识print输出不换行</strong></p>
<p>默认print语句输出内容会自动换行，如下图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e87d4a25.png" alt="image-20230208180744865" style="zoom: 80%;" />
<p>在即将完成的案例中，我们需要使用print语句，输出不换行的功能，非常简单，实现方式如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e888fd42.png" alt=" "></p>
<p>如图，在print语句中，加上 end=’’ 即可输出不换行了</p>
<blockquote>
<p>ps: end=’’ 是使用的方法传参功能，我们在后面会详细讲解。</p>
</blockquote>
<p><strong>补充知识制表符\t</strong></p>
<p>在字符串中，有一个特殊符号：\t，效果等同于在键盘上按下：tab键。</p>
<p>它可以让我们的多行字符串进行对齐。</p>
<p>比如：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e897cc5e.png" alt=" " style="zoom:50%;" /></p>
<p>通过while循环，输出如下九九乘法表内容<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e8a76c88.png" alt=" "></p>
<p>提示：</p>
<ul>
<li>
<p>2层循环，外层控制行，内层控制列</p>
</li>
<li>
<p>外层循环和内存循环的累加数字变量，用以辅助输出乘法表的数值</p>
</li>
</ul>
<h3 id="for循环的基础语法">for循环的基础语法</h3>
<h4 id="基础语法"><strong>基础语法</strong></h4>
<p>除了while循环语句外，Python同样提供了for循环语句。</p>
<p>两者能完成的功能基本差不多，但仍有一些区别：</p>
<ul>
<li>
<p>while循环的循环条件<strong>是自定义的</strong>，自行控制循环条件</p>
</li>
<li>
<p>for循环是一种”<strong>轮询”机制，是对一批内容进行”逐个处理”</strong></p>
</li>
</ul>
<p><strong>while循环</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e8b40df7.png" alt=" " style="zoom: 50%;" />
<p><strong>for循环</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e8c0a301.png" alt=" " style="zoom:50%;" />
<blockquote>
<p>for循环就是将”待办事项”逐个完成的循环机制</p>
</blockquote>
<p>程序中的for循环（<strong>冒 + 空</strong>）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 临时变量 <span class="keyword">in</span> 待处理数据集: </span><br><span class="line">        循环满足条件时执行的代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>从待处理数据集中：逐个取出数据</strong></p>
<p><strong>赋值给临时变量</strong></p>
<p><strong>遍历字符串</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义字符串 name</span></span><br><span class="line">name = ”itheima”</span><br><span class="line"><span class="comment"># for 循环处理字符串</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> name: </span><br><span class="line">       <span class="built_in">print</span>(x)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下</strong><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e8ca8348.png" alt="image-20230208181520569" style="zoom:67%;" /></p>
<p>可以看出，for循环是将字符串的内容：<strong>依次取出</strong></p>
<p>所以，for循环也被称之为：<strong>遍历循环</strong></p>
<p><strong>fo循环注意点</strong></p>
<ul>
<li>
<p>同while循环不同，for循环是<strong>无法定义循环条件</strong>的。</p>
<p>只能从被处理的数据集中，依次取出内容进行处理。</p>
<p>所以，理论上讲，Python的for循环无法构建无限循环（被处理的数据集不可能无限大）</p>
</li>
<li>
<p>要注意，循环内的语句，需要有空格缩进</p>
</li>
</ul>
<h4 id="range语句"><strong>range语句</strong></h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 临时变量 <span class="keyword">in</span> 待处理数据集(可迭代对象): </span><br><span class="line">        循环满足条件时执行的代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>语法中的：待处理数据集，严格来说，称之为：可迭代类型</p>
<p>可迭代类型指，<strong>其内容可以一个个依次取出的一种类型</strong>，包括：</p>
<ul>
<li>字符串</li>
<li>列表</li>
<li>元组</li>
<li>集合</li>
<li>字典</li>
</ul>
<p>目前我们只学习了字符串类型，其余类型在后续章节会详细学习它们</p>
<p>for循环语句，本质上是遍历：可迭代对象。</p>
<p>尽管除字符串外，其它可迭代类型目前没学习到，但不妨碍我们通过学习range语句，获得一个简单的数字序列（可迭代类型的一种）。（<strong>range后面括号里数字是几就有几个数字</strong>）</p>
<p>语法1：</p>
<p><code>range(num)</code></p>
<blockquote>
<p>获取一个从0开始，到num结束的数字序列（不含num本身）</p>
<p>如range(5)取得的数据是：[0, 1, 2, 3, 4]</p>
</blockquote>
<p>语法2：</p>
<p><code>range(num1, num2)</code></p>
<blockquote>
<p>获得一个从num1开始，到num2结束的数字序列（不含num2本身）</p>
<p>如，range(5, 10)取得的数据是：[5, 6, 7, 8, 9]</p>
</blockquote>
<p>语法3：</p>
<p><code>range(num1, num2, step)</code></p>
<p>获得一个从num1开始，到num2结束的数字序列（不含num2本身）</p>
<p>数字之间的步长，以step为准（step默认为1）</p>
<p>如，range(5, 10, 2)取得的数据是：[5, 7, 9]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for 循环处理字符串</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>): </span><br><span class="line">       <span class="built_in">print</span>(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>运行结果如下</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e8d694ba.png" alt=" "></p>
<h4 id="变量作用域">变量作用域</h4>
<p><strong>for循环的变量作用域</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e8e33eb4.png" alt=" " style="zoom:67%;" />
<p>回看for循环的语法，我们会发现，将从数据集（序列）中取出的数据赋值给：临时变量</p>
<p>为什么是临时的呢？</p>
<p>临时变量，在编程规范上，作用范围（作用域），只限定在for循环内部</p>
<p>如果在for循环外部访问临时变量：</p>
<ul>
<li>
<p>实际上是可以访问到的</p>
</li>
<li>
<p>在编程规范上，是不允许、不建议这么做的</p>
</li>
</ul>
<p>如果实在需要在循环外访问循环内的临时变量，可以在循环外预先定义</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e8eed312.png" alt=" " style="zoom:67%;" />
<p>如图，每一次循环的时候，都会将取出的值赋予i变量。</p>
<ul>
<li>
<p>由于i变量是在循环之前（外）定义的</p>
</li>
<li>
<p>在循环外访问i变量是合理的、允许的</p>
</li>
</ul>
<h3 id="for循环的嵌套应用">for循环的嵌套应用</h3>
<p>同while一样，for循环也支持嵌套使用</p>
<p>同样以向小美表白的案例为例</p>
<ul>
<li>
<p>坚持表白100天</p>
</li>
<li>
<p>每天送花10束</p>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e8ff2eba.png" alt=" " style="zoom:50%;" />
<blockquote>
<p>如图，和while循环一样，需要注意缩进<br>
因为通过缩进，确定层次关系</p>
</blockquote>
<p>我们目前学习了2个循环，while循环和for循环。</p>
<p>这两类循环语句是可以相互嵌套的，如下，小美表白的案例可以改为：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e90d4101.png" alt=" "></p>
<p>通过for循环，输出如下九九乘法表内容</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e8a76c88.png" alt=" " style="zoom:50%;" />
<p>提示：</p>
<ul>
<li>2层循环，外层控制行，内层控制列</li>
<li>可使用range语句来得到数字序列进行for循环</li>
<li>内层for循环的range最大范围，取决于当前外层循环的数字</li>
</ul>
<h3 id="循环中断-break和continue-只作用于循环，和判断无关">循环中断 : break和continue(只作用于循环，和判断无关)</h3>
<p>1.掌握使用continue和break关键字控制循环</p>
<p>思考：无论是while循环或是for循环，都是重复性的执行特定操作。</p>
<p>在这个重复的过程中，会出现一些其它情况让我们不得不：</p>
<ul>
<li>
<p>暂时跳过某次循环，直接进行下一次</p>
</li>
<li>
<p>提前退出循环，不在继续</p>
</li>
</ul>
<p>对于这种场景，Python提供<strong>continue</strong>和<strong>break</strong>关键字</p>
<p>用以对循环进行临时跳过和直接结束</p>
<p><strong>continue</strong></p>
<blockquote>
<p>continue关键字用于：中断本次循环，直接进入下一次循环</p>
<p>continue可以用于：  for循环和while循环，效果一致</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e92dcf79.png" alt=" " style="zoom:50%;" />
<blockquote>
<p>continue只能控制左图编号1的for循环</p>
<p>对编号2的for循环，无影响</p>
<p>continue关键字只可以控制：它所在的循环临时中断</p>
</blockquote>
<p><strong>break</strong></p>
<blockquote>
<p>break关键字用于：直接结束所在循环</p>
<p>break可以用于：  for循环和while循环，效果一致</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e93c501e.png" alt="image-20230208183200564" style="zoom:50%;" />
<blockquote>
<p>break只能控制左图编号1的循环</p>
<p>对编号2的循环，无影响</p>
<p>break关键字同样只可以控制：它所在的循环永久中断</p>
</blockquote>
<p><strong>切记口诀：break、continue在哪个循环中就对哪个循环起作用</strong></p>
<p><strong>练习案例：发工资</strong></p>
<p>某公司，账户余额有1W元，给20名员工发工资。</p>
<ul>
<li>员工编号从1到20，从编号1开始，依次领取工资，每人可领取1000元</li>
<li>领工资时，财务判断员工的绩效分（1-10）（随机生成），如果低于5，不发工资，换下一位</li>
<li>如果工资发完了，结束发工资。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e94b9bde.png" alt=" " style="zoom: 80%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e958d40a.png" alt=" " style="zoom: 67%;" />
<p>提示：</p>
<ul>
<li>continue用于跳过员工，break直接结束发工资</li>
<li>if判断余额，不要忘记发完工资后，余额减少1000哦</li>
</ul>
<h3 id="循环中的-else">循环中的 else</h3>
<h4 id="引入">引入</h4>
<p>看如下代码，想一想：怎样实现 “密码不正确的相应提示”</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">3</span></span><br><span class="line"><span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">    password = <span class="built_in">input</span>(<span class="string">&quot;请输入密码：（还剩%d 次机会）&quot;</span> % i)</span><br><span class="line">    <span class="keyword">if</span> password == <span class="string">&quot;123456&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;密码输入正确&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    i -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>想要实现在 “密码不正确” 时提示相应的信息，普通的做法是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">login_flag = <span class="literal">False</span>  <span class="comment"># 定义一个变量，用来存储是否登录成功，True 表示成功 False 表示不成功</span></span><br><span class="line">i = <span class="number">3</span></span><br><span class="line"><span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">    password = <span class="built_in">input</span>(<span class="string">&quot;请输入密码：（还剩%d 次机会）&quot;</span> % i)</span><br><span class="line">    <span class="keyword">if</span> password == <span class="string">&quot;123456&quot;</span>:</span><br><span class="line">        login_flag = <span class="literal">True</span>  <span class="comment"># 如果登录成功，那么这里就改为 True</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    i -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当上述的 while 循环结束后，判断 login_flag 的值，来输出对应的信息</span></span><br><span class="line"><span class="keyword">if</span> login_flag == <span class="literal">True</span>:  <span class="comment"># 简单的写法是 if login_flag:</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;密码输入正确&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;密码输入不正确，今日 3 次机会已用完，请明天再试...&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>上述的代码整体逻辑是：</p>
<ol>
<li>循环中获取密码判断是否正确，通过一个变量来标记正确与否</li>
<li>当循环结束后，在单独判断标记，然后输出对应的信息</li>
</ol>
<p>问题：有么有简单的方式呢？</p>
<p>答：<code>else</code></p>
<h4 id="while…else…-的使用方式">while…else… 的使用方式</h4>
<p><strong>格式：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">    <span class="comment"># 条件满足时执行的代码...</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 如果上述的 while 循环没有调用 break，就执行的代码...</span></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li>只要while循环体中没有执行break，<strong>那么当while循环体中所有的代码执行完后，else中的代码也会执行</strong></li>
<li><strong>如果while循环中有break那么表示整个while结束，else中的代码也不会被执行</strong></li>
</ul>
<p><strong>示例：</strong></p>
<ul>
<li>
<p>有 break 时：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是一段测试信息...&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;调用了 break&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是 else 中的代码&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是一段测试信息...</span><br><span class="line">调用了 break</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>没有 break 时</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">3</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这是一段测试信息...&quot;</span>)</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是 else 中的代码&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这是一段测试信息...</span><br><span class="line">这是一段测试信息...</span><br><span class="line">这是一段测试信息...</span><br><span class="line">我是 else 中的代码</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="代码案例">代码案例</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">3</span></span><br><span class="line"><span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">    password = <span class="built_in">input</span>(<span class="string">&quot;请输入密码：（还剩%d 次机会）&quot;</span> % i)</span><br><span class="line">    <span class="keyword">if</span> password == <span class="string">&quot;123456&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;密码输入正确&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    i -= <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;密码输入 3 次全部错误，请明日再试&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="for…else…-的使用方式">for…else… 的使用方式</h4>
<p><strong>格式：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 可迭代对对象:</span><br><span class="line">    <span class="comment"># 正常执行的代码</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># for 未使用 break 时执行的代码</span></span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<ul>
<li>
<p>未使用 break</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i =%d&quot;</span> % i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是 else 中的代码...&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = 0</span><br><span class="line">i = 1</span><br><span class="line">i = 2</span><br><span class="line">i = 3</span><br><span class="line">i = 4</span><br><span class="line">我是 else 中的代码....</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用 break</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;i =%d&quot;</span> % i)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;我是 break 哦...&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是 else 中的代码...&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = 0</span><br><span class="line">i = 1</span><br><span class="line">我是 break 哦...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="代码案例-2">代码案例</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">0</span>, -<span class="number">1</span>):</span><br><span class="line">    password = <span class="built_in">input</span>(<span class="string">&quot;请输入密码：（还剩%d 次机会）&quot;</span> % i)</span><br><span class="line">    <span class="keyword">if</span> password == <span class="string">&quot;123456&quot;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;密码输入正确&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;密码输入 3 次全部错误，请明日再试&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="验证-continue">验证 continue</h4>
<p>我们知道<code>continue</code>的作用是结束本次循环，那么既然<code>break</code>在<code>for...else...</code>和<code>while...else...</code>中都起作用，那么<code>continue</code>呢？</p>
<p>接下来我们就验证一下。</p>
<p>验证一：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">3</span>:</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;来了老弟...&quot;</span>)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;一起学 Python 啊，别忘了来 www.tulingxueyuan.com 网站哈&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是 else 中的代码...&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">来了老弟...</span><br><span class="line">来了老弟...</span><br><span class="line">来了老弟...</span><br><span class="line">我是 else 中的代码...</span><br></pre></td></tr></table></figure>
<p>验证二：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;来了老弟...&quot;</span>)</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;一起学 Python 啊，别忘了来 www.tulingxueyuan.com 网站哈&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是 else 中的代码...&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">来了老弟...</span><br><span class="line">来了老弟...</span><br><span class="line">来了老弟...</span><br><span class="line">我是 else 中的代码...</span><br></pre></td></tr></table></figure>
<p><strong>结论：</strong></p>
<ul>
<li>在<code>while...else...</code>与<code>for...else...</code>中，<code>break</code>会让<code>else</code>中的代码不执行，而<code>continue</code>没有这个功能</li>
</ul>
<h2 id="Python函数">Python函数</h2>
<h3 id="函数介绍">函数介绍</h3>
<ol>
<li>
<p>快速体验函数的使用</p>
</li>
<li>
<p>了解函数的作用</p>
</li>
</ol>
<p>函数：是<strong>组织好的，可重复使用</strong>的，用来实现特定功能的代码段。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e965ce56.png" alt=" " style="zoom: 50%;" />
<p><strong>为什么随时都可以使用len()统计长度？</strong></p>
<p>因为，len()是Python内置的函数：</p>
<ul>
<li>是提前写好的</li>
<li>可以重复使用</li>
<li>实现统计长度这一特定功能的代码段</li>
</ul>
<blockquote>
<p>我们使用过的：input()、print()、str()、int()等都是Python的内置函数</p>
</blockquote>
<h3 id="函数的定义">函数的定义</h3>
<p>1.掌握函数的基础定义语法</p>
<p>函数的定义</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e9727a70.png" alt=" " style="zoom:80%;" />
<p>函数的调用：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e97d023a.png" alt=" "></p>
<blockquote>
<p>注意事项:</p>
<p>① 参数如不需要，可以省略（后续章节讲解）</p>
<p>② 返回值如不需要，可以省略（后续章节讲解）</p>
<p>③ 函数必须先定义后使用</p>
</blockquote>
<h3 id="函数的参数">函数的参数</h3>
<p>1.掌握函数传入参数的使用</p>
<p>传入参数的功能是：在函数进行计算的时候，接受外部（调用时）提供的数据</p>
<p>有如下代码，完成了2个数字相加的功能：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e9895f6e.png" alt=" " style="zoom:67%;" /></p>
<p>函数的功能非常局限，只能计算1 + 2。</p>
<p><strong>有没有可能实现：每一次使用函数，去计算用户指定的2个数字，而非每次都是1 + 2呢？</strong></p>
<p>可以的，使用函数的传入参数功能，即可实现。</p>
<ul>
<li>可以有如下函数定义：</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e995e1f4.png" alt=" " style="zoom:67%;" />
<blockquote>
<p>实现了，每次计算的是x + y，而非固定的1 + 2</p>
<p>x + y的值，可以在调用函数的时候指定。</p>
</blockquote>
<p>语法解析：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e9a32dd2.png" alt=" " style="zoom:50%;" /></p>
<p>调用：函数名+（），（）可以理解为调用</p>
<ul>
<li>函数定义中，提供的x和y，称之为：形式参数（形参），表示函数声明将要使用2个参数</li>
<li><strong>参数之间使用逗号进行分隔</strong></li>
<li>函数调用中，提供的5和6，称之为：实际参数（实参），表示函数执行时真正使用的参数值</li>
<li><strong>传入的时候，按照顺序传入数据，使用逗号分隔</strong></li>
</ul>
<blockquote>
<p>传入参数的数量是不受限制的。</p>
<p>可以不使用参数</p>
<p>也可以仅使用任意N个参数</p>
</blockquote>
<h3 id="函数的返回值">函数的返回值</h3>
<h4 id="函数返回值的定义">函数返回值的定义</h4>
<p>1.掌握函数返回值的作用</p>
<p>2.掌握函数返回值的定义语法</p>
<p>程序中的返回值：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e9b0b04e.png" alt=" " style="zoom:50%;" />
<blockquote>
<p>如图代码</p>
<p>定义两数相加的函数功能。完成功能后，会将相加的结果返回给函数调用者</p>
<p>所以，变量r接收到了函数的执行结果。</p>
</blockquote>
<ul>
<li>综上所述：</li>
</ul>
<p>​      所谓“返回值”，就是程序中函数完成事情后，最后给调用者的结果</p>
<p>语法格式如图：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e9bd75df.png" alt=" " style="zoom:50%;" /></p>
<p>如图，变量就能接收到函数的返回值</p>
<p>语法就是：通过return关键字，就能向调用者返回数据</p>
<blockquote>
<p>注意：</p>
<p>函数体在遇到return后就结束了，所以写在return后的代码不会执行。</p>
</blockquote>
<h4 id="None类型">None类型</h4>
<ul>
<li>
<p>思考：如果函数没有使用return语句返回数据，那么函数有返回值吗？</p>
</li>
<li>
<p>实际上是：有的。</p>
</li>
</ul>
<p>Python中有一个特殊的字面量：<strong>None</strong>，其类型是：&lt;class ‘NoneType’&gt;</p>
<p>无返回值的函数，实际上就是返回了：None这个字面量</p>
<ul>
<li>None表示：空的、无实际意义的意思</li>
</ul>
<p>​		函数返回的None，就表示，这个函数没有返回什么有意义的内容。</p>
<p>​		也就是返回了空的意思。</p>
<p>演示：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e9cb5c97.png" alt=" " style="zoom: 67%;" /></p>
<p>None可以主动使用return返回，效果等同于不写return语句：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e9d85a1a.png" alt=" " style="zoom:67%;" /></p>
<p><strong>None作为一个特殊的字面量，用于表示：空、无意义，其有非常多的应用场景。</strong></p>
<ul>
<li>
<p>用在函数无返回值上</p>
</li>
<li>
<p>用在if判断上<br>
在if判断中，None等同于False<br>
一般用于在函数中主动返回None，配合if判断做相关处理</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e9e47162.png" alt=" " style="zoom:67%;" />
</li>
<li>
<p>用于声明无内容的变量上<br>
定义变量，但暂时不需要变量有具体值，可以用None来代替</p>
</li>
</ul>
<p>​    <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e9f05bf1.png" alt=" " style="zoom:50%;" /></p>
<h3 id="函数说明文档">函数说明文档</h3>
<ol>
<li>掌握通过注释对函数进行解释说明</li>
</ol>
<p>函数是纯代码语言，想要理解其含义，就需要一行行的去阅读理解代码，效率比较低。</p>
<p>我们可以给函数添加说明文档，辅助理解函数的作用。</p>
<p>语法如下：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398e9fc6553.png" alt="" style="zoom:67%;" /></p>
<p>通过多行注释的形式，对函数进行说明解释</p>
<ul>
<li>内容应写在函数体之前</li>
</ul>
<p>在PyCharm编写代码时，可以通过鼠标悬停，查看调用函数的说明文档</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ea0c9834.png" alt=" " style="zoom:50%;" />
<h3 id="函数的嵌套调用">函数的嵌套调用</h3>
<ol>
<li>
<p>掌握函数的嵌套调用</p>
</li>
<li>
<p>理解嵌套调用的执行流程</p>
</li>
</ol>
<p>所谓函数嵌套调用指的是一个函数里面又调用了另外一个函数</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ea195f39.png" alt=" " style="zoom: 50%;" />
<p>执行效果：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ea25ea18.png" alt="" style="zoom:50%;" /></p>
<p><strong>执行过程</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ea3416b7.png" alt=" " style="zoom: 50%;" />
<blockquote>
<p>如果函数A中，调用了另外一个函数B，那么先把函数B中的任务都执行完毕之后才会回到上次 函数A执行的位置</p>
</blockquote>
<h3 id="变量的作用域">变量的作用域</h3>
<p>1.知道什么是局部变量</p>
<p>2.知道什么是全局变量</p>
<p>变量作用域指的是变量的作用范围（变量在哪里可用，在哪里不可用）</p>
<p>主要分为两类：局部变量和全局变量</p>
<p><strong>局部变量</strong></p>
<p>所谓局部变量是<strong>定义在函数体内部</strong>的变量，即<strong>只在函数体内部</strong>生效</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ea41e93f.png" alt=" " style="zoom:50%;" />
<p>变量a是定义在<code>testA</code>函数内部的变量，在函数外部访问则立即报错.</p>
<blockquote>
<p>局部变量的作用：在函数体内部，临时保存数据，即当函数调用完成后，则销毁局部变量</p>
</blockquote>
<p><strong>全局变量</strong></p>
<p>所谓全局变量，指的是在函数体内、外都能生效的变量</p>
<p>思考：如果有一个数据，在函数A和函数B中都要使用，该怎么办？</p>
<p>答：将这个数据存储在一个全局变量里面</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ea50cd24.png" alt=" " style="zoom: 50%;" />
<p><strong>global关键字</strong></p>
<p>思考：<code>testB</code>函数需要修改变量num的值为200，如何修改程序？</p>
<p>☆ 使用 global关键字 可以在函数内部声明变量为全局变量, 如下所示</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ea5f033e.png" alt=" " style="zoom:50%;" />
<p><strong>综合案例：黑马ATM</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ea6c4ac3.png" alt=" " style="zoom: 80%;" />
<ul>
<li>
<p>定义一个全局变量：money，用来记录银行卡余额（默认5000000）</p>
</li>
<li>
<p>定义一个全局变量：name，用来记录客户姓名（启动程序时输入）</p>
</li>
<li>
<p>定义如下的函数：</p>
<ul>
<li>查询余额函数</li>
<li>存款函数</li>
<li>取款函数</li>
<li>主菜单函数</li>
</ul>
</li>
<li>
<p>要求：</p>
</li>
</ul>
<ol>
<li>程序启动后要求输入客户姓名</li>
<li>查询余额、存款、取款后都会返回主菜单</li>
<li>存款、取款后，都应显示一下当前余额</li>
<li>客户选择退出或输入错误，程序会退出，否则一直运行</li>
</ol>
<h2 id="2-5-Python数据容器（-增删改查-）">2.5 Python数据容器（==增删改查==）</h2>
<h3 id="1-数据容器入门">1. 数据容器入门</h3>
<p>1.了解数据容器是什么</p>
<p><strong>为什么学习数据容器</strong></p>
<p>思考一个问题：如果我想要在程序中，记录5名学生的信息，如姓名。</p>
<p>如何做呢？<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ea79c832.png" alt=" " style="zoom:50%;" /></p>
<p><strong>不高级且低效</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ea88cf10.png" alt=" " style="zoom: 67%;" />
<p><strong>优雅、高效</strong></p>
<blockquote>
<p><strong>这就是数据容器，一个容器可以容纳多份数据</strong></p>
<p><strong>学习数据容器，就是为了批量存储或批量使用多份数据</strong></p>
</blockquote>
<p><strong>数据容器</strong></p>
<p>Python中的数据容器：</p>
<p>一种可以容纳多份数据的数据类型，容纳的每一份数据称之为1个元素</p>
<p><strong>每一个元素</strong>，可以是<strong>任意类型</strong>的数据，如字符串、数字、布尔等。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ea986716.png" alt=" " style="zoom:50%;" />
<p><strong>数据容器根据特点的不同，如：</strong></p>
<ul>
<li>是否支持重复元素</li>
<li>是否可以修改</li>
<li>是否有序，等</li>
</ul>
<p>分为5类，分别是：</p>
<p>列表（list）、元组（tuple）、字符串（str）、集合（set）、字典（dict）</p>
<p>我们将一一学习它们</p>
<h3 id="2-数据容器：list-列表">2. 数据容器：list(列表)</h3>
<h4 id="1-列表的定义">1. 列表的定义</h4>
<p>1.掌握列表的定义格式</p>
<blockquote>
<p>思考：有一个人的姓名(TOM)怎么在程序中存储？</p>
<p>答：字符串变量</p>
<p>思考：如果一个班级100位学生，每个人的姓名都要存储，应该如何书写程序？声明100个变量吗？</p>
<p>答：No，我们使用列表就可以了， 列表一次可以存储多个数据</p>
<p>列表（list）类型，是数据容器的一类，我们来详细学习它。</p>
</blockquote>
<p><strong>基本语法：</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eaa6b347.png" alt=" " style="zoom:50%;" />
<p>列表内的每一个数据，称之为元素</p>
<ul>
<li>以 [] 作为标识</li>
<li>列表内每一个元素之间用, 逗号隔开</li>
</ul>
<p>案例演示：使用[]的方式定义列表</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eab3ed77.png" alt=" " style="zoom:80%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eac0f064.png" alt=" " style="zoom:80%;" />
<p><strong>嵌套列表的定义</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eaccb051.png" alt=" "></p>
<blockquote>
<p>注意事项</p>
<p>注意：列表可以一次存储多个数据，且可以为不同的数据类型，支持嵌套</p>
</blockquote>
<h4 id="2-列表的下标索引">2. <strong>列表的下标索引</strong></h4>
<p>1.掌握使用列表的下标索引从列表中取出元素</p>
<ul>
<li>如何从列表中取出特定位置的数据呢？</li>
</ul>
<p>​	我们可以使用：<strong>下标索引</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ead9f910.png" alt=" " style="zoom: 50%;" />
<p>如图，列表中的每一个元素，都有其位置下标索引，从前向后的方向，从0开始，依次递增</p>
<p>我们只需要按照下标索引，即可取得对应位置的元素。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eae97652.png" alt=" " style="zoom:67%;" />
<p><strong>或者，可以反向索引，也就是从后向前：从-1开始，依次递减（-1、-2、-3…）</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eaf6ba97.png" alt="" style="zoom:50%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eb04de0a.png" alt=" " style="zoom: 67%;" />
<p><strong>如果列表是嵌套的列表，同样支持下标索引</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eb1213dc.png" alt=" " style="zoom:50%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eb2123ff.png" alt=" " style="zoom: 67%;" />
<blockquote>
<p>要注意下标索引的取值范围，超出范围无法取出元素，并且会报错</p>
</blockquote>
<h4 id="3-列表的常用操作">3. <strong>列表的常用操作</strong></h4>
<p>1.掌握列表的常用操作（方法）和特点</p>
<blockquote>
<p>列表除了可以：</p>
<p>•定义</p>
<p>•使用下标索引获取值</p>
<p>以外，列表也提供了一系列功能：</p>
<p>•插入元素</p>
<p>•删除元素</p>
<p>•清空列表</p>
<p>•修改元素</p>
<p>•统计元素个数</p>
<p>等等功能，这些功能我们都称之为：列表的方法</p>
</blockquote>
<p><strong>列表的查询功能（方法）</strong></p>
<p>回忆：函数是一个封装的代码单元，可以提供特定功能。</p>
<p>在Python中，如果将函数定义为class（类）的成员，那么函数会称之为：方法</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eb2c1deb.png" alt=" " style="zoom:67%;" />
<p>方法和函数功能一样， 有传入参数，有返回值，只是方法的使用格式不同：</p>
<p><strong>函数的使用：</strong><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eb384010.png" alt=" " style="zoom:50%;" /></p>
<p><strong>方法的使用：</strong><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eb451156.png" alt=" " style="zoom:50%;" /></p>
<p>关于类和方法的定义，在面向对象章节我们学习，目前我们知道如何使用方法即可。</p>
<blockquote>
<ul>
<li>
<p><strong>查找某元素的下标</strong></p>
<p>功能：查找指定元素在列表的下标，如果找不到，报错ValueError</p>
<p>语法：列表.index(元素)</p>
</li>
</ul>
<p>​    <strong>index就是列表对象（变量）内置的方法（函数）</strong></p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eb5209ed.png" alt=" " style="zoom:67%;" />
<blockquote>
<ul>
<li>
<p><strong>修改特定位置（索引）的元素值：</strong></p>
<p>语法：列表[下标] = 值</p>
<p>可以使用如上语法，直接对指定下标（正向、反向下标均可）的值进行：重新赋值（修改）</p>
</li>
</ul>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eb602ba7.png" alt=" " style="zoom:50%;" />
<blockquote>
<ul>
<li>
<p><strong>插入元素：</strong></p>
<p>语法：列表.insert(下标, 元素)，在指定的下标位置，插入指定的元素。（后面的元素后移）</p>
</li>
</ul>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eb6af5a7.png" alt=" " style="zoom:80%;" />
<blockquote>
<ul>
<li>
<p>追加元素：</p>
<p>语法：列表.append(元素)，将指定元素，追加到列表的尾部</p>
</li>
</ul>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eb79beee.png" alt=" " style="zoom:67%;" />
<blockquote>
<ul>
<li>
<p>追加元素方式2：</p>
<p>语法：列表.extend(其它数据容器)，将其它数据容器的内容取出，依次追加到列表尾部</p>
</li>
</ul>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eb862b59.png" alt=" " style="zoom:67%;" />
<p><strong>==注意这两种追加方式的不同==</strong></p>
<blockquote>
<ul>
<li>
<p>删除元素：</p>
<p>语法1： del 列表[下标]</p>
<p>语法2：列表.pop(下标)</p>
</li>
</ul>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eb93dac5.png" alt=" " style="zoom: 67%;" />
<blockquote>
<ul>
<li>
<p>删除某元素在列表中的<strong>第一个</strong>匹配项</p>
<p>语法：列表.remove(元素)</p>
</li>
</ul>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eb9ee7a8.png" alt=" " style="zoom:50%;" />
<p>==<strong>注意这三种删除方式的不同，前面是根据下标索引，而remove方法是根据元素值</strong>==</p>
<blockquote>
<ul>
<li>
<p>清空列表内容</p>
<p>语法：列表.clear()</p>
</li>
</ul>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ebaa8703.png" alt=" " style="zoom:50%;" />
<blockquote>
<ul>
<li>
<p>统计某元素在列表内的数量</p>
<p>语法：列表.count(元素)</p>
</li>
</ul>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ebb67e4d.png" alt=" " style="zoom:67%;" />
<blockquote>
<ul>
<li>
<p>统计列表内，有多少元素</p>
<p>语法：len(列表)</p>
<p>可以得到一个int数字，表示列表内的元素数量</p>
</li>
</ul>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ebc3e917.png" alt=" " style="zoom:67%;" />
<h4 id="4-列表的方法-总览">4. <strong>列表的方法</strong> <strong>-</strong> <strong>总览</strong></h4>
<table>
<thead>
<tr>
<th><strong>编号</strong></th>
<th><strong>使用方式</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>列表.append(元素)</td>
<td>向列表中追加一个元素</td>
</tr>
<tr>
<td>2</td>
<td>列表.extend(容器)</td>
<td>将数据容器的内容依次取出，追加到列表尾部</td>
</tr>
<tr>
<td>3</td>
<td>列表.insert(下标, 元素)</td>
<td>在指定下标处，插入指定的元素</td>
</tr>
<tr>
<td>4</td>
<td>del 列表[下标]</td>
<td>删除列表指定下标元素</td>
</tr>
<tr>
<td>5</td>
<td>列表.pop(下标)</td>
<td>删除列表指定下标元素（不指定下标的话默认删除最后一个）</td>
</tr>
<tr>
<td>6</td>
<td>列表.remove(元素)</td>
<td>从前向后，删除此元素第一个匹配项</td>
</tr>
<tr>
<td>7</td>
<td>列表.clear()</td>
<td>清空列表</td>
</tr>
<tr>
<td>8</td>
<td>列表.count(元素)</td>
<td>统计此元素在列表中出现的次数</td>
</tr>
<tr>
<td>9</td>
<td>列表.index(元素)</td>
<td>查找指定元素在列表的下标  找不到报错ValueError</td>
</tr>
<tr>
<td>10</td>
<td>len(列表)</td>
<td>统计容器内有多少元素</td>
</tr>
<tr>
<td>11</td>
<td>元素 in 列表 ；元素 not in 列表</td>
<td>查询列表中的元素是否存在</td>
</tr>
<tr>
<td>12</td>
<td>列表.sort() ; 列表.sort(reverse = Ture)</td>
<td>列表按从小到大顺序重新排列；列表按从大到小重新排列</td>
</tr>
<tr>
<td>13</td>
<td>列表.reverse()</td>
<td>将列表倒序</td>
</tr>
</tbody>
</table>
<p><strong>一定要注意！append方法（还有别的）只是在恰当的位置修改原来的列表！！！</strong></p>
<p><strong>这意味着，他不是返回一个列表，而只是修改原来的列表，所以如果用 等式 输出的话，返回是None ，也就意味着不会又返回值！！</strong></p>
<p><strong>经过上述对列表的学习，可以总结出列表有如下特点：</strong></p>
<ul>
<li>可以容纳多个元素（上限为2**63-1、9223372036854775807个）</li>
<li>可以容纳不同类型的元素（混装）</li>
<li>数据是有序存储的（有下标序号）</li>
<li>允许重复数据存在</li>
<li>可以修改（增加或删除元素等）</li>
</ul>
<h3 id="3-list（列表）的遍历">3. list（列表）的遍历</h3>
<ol>
<li>
<p>掌握使用while循环，遍历列表的元素</p>
</li>
<li>
<p>掌握使用for循环，遍历列表的元素</p>
</li>
</ol>
<blockquote>
<p>既然数据容器可以存储多个元素，那么，就会有需求从容器内依次取出元素进行操作。</p>
<p>将容器内的元素依次取出进行处理的行为，称之为：遍历、迭代。</p>
</blockquote>
<p><strong>如何遍历列表的元素呢？</strong></p>
<ul>
<li>可以使用前面学过的while循环</li>
</ul>
<p><strong>如何在循环中取出列表的元素呢？</strong></p>
<ul>
<li>使用列表[下标]的方式取出</li>
</ul>
<p><strong>循环条件如何控制？</strong></p>
<ul>
<li>定义一个变量表示下标，从0开始</li>
<li>循环条件为 下标值 &lt; 列表的元素数量</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ebd2df08.png" alt=" " style="zoom:50%;" />
<blockquote>
<p>除了while循环外，Python中还有另外一种循环形式：for循环。</p>
<p><strong>对比while，for循环更加适合对列表等数据容器进行遍历。</strong></p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/czzczzczz/image@main/202302081934202.png" alt=" " style="zoom:80%;" /><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ebde8b6a.png" alt=" " style="zoom: 67%;" /></p>
<blockquote>
<p>从容器内，依次取出元素并赋值到临时变量上。</p>
<p>在每一次的循环中，我们可以对临时变量（元素）进行处理。</p>
</blockquote>
<p><strong>while循环和for循环的对比</strong></p>
<p>while循环和for循环，都是循环语句，但细节不同：<br>
<strong>在循环控制上：</strong></p>
<ul>
<li>while循环可以自定循环条件，并自行控制</li>
<li>for循环不可以自定循环条件，只可以一个个从容器内取出数据</li>
</ul>
<p><strong>在无限循环上：</strong></p>
<ul>
<li>while循环可以通过条件控制做到无限循环</li>
<li>for循环理论上不可以，因为被遍历的容器容量不是无限的</li>
</ul>
<p><strong>在使用场景上：</strong></p>
<ul>
<li>while循环适用于任何想要循环的场景</li>
<li>for循环适用于，<strong>遍历数据容器的场景</strong>或简单的<strong>固定次数循环场景</strong></li>
</ul>
<p><strong>应用</strong></p>
<p>一个学校，有3个办公室，现在有8位老师等待工位的分配，请编写程序，完成随机的分配</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个列表用来保存 3 个办公室</span></span><br><span class="line">offices = [[], [], []]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个列表用来存储 8 位老师的名字</span></span><br><span class="line">names = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历所有的老师，随机安排到 0、1、2 号办公室</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">    random_num = random.randint(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    offices [random_num].append(name)</span><br><span class="line"></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> office_names <span class="keyword">in</span> offices:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;办公室%d 的人数为:%d&#x27;</span> % (i, <span class="built_in">len</span>(office_names)))</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> office_names:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;%s&quot;</span> % name, end =<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-&quot;</span> * <span class="number">20</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果如下: (因为是随机 所以每次运行结果都可以不同)</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">办公室 1 的人数为: 1</span><br><span class="line">G </span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">办公室 2 的人数为: 2</span><br><span class="line">A B </span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line">办公室 3 的人数为: 5</span><br><span class="line">C D E F H </span><br></pre></td></tr></table></figure>
<h3 id="4-数据容器：tuple-元组">4. 数据容器：tuple(元组)</h3>
<h4 id="1-元组的定义">1. <strong>元组的定义</strong></h4>
<p>1.掌握元组的定义格式</p>
<p><strong>为什么需要元组</strong></p>
<blockquote>
<p>思考：列表是可以修改的。</p>
<p>如果想要传递的信息，不被篡改，列表就不合适了。</p>
<p>元组同列表一样，都是可以封装多个、不同类型的元素在内。</p>
<p>但最大的不同点在于：</p>
<p>元组一旦定义完成，就不可修改</p>
<p>所以，当我们需要在程序内封装数据，又不希望封装的数据被篡改，那么元组就非常合适了</p>
</blockquote>
<p><strong>元组定义：定义元组使用小括号，且使用逗号隔开各个数据，数据可以是不同的数据类型。</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ebef3450.png" alt=" " style="zoom:50%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ebfc81e4.png" alt=" " style="zoom:50%;" />
<blockquote>
<p>注意：元组只有一个数据，这个数据后面要添加逗号</p>
</blockquote>
<p><strong>元组也支持嵌套：</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ec09360c.png" alt=" " style="zoom: 67%;" />
<p><strong>元组的相关操作</strong></p>
<table>
<thead>
<tr>
<th><strong>编号</strong></th>
<th><strong>方法</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>index()</td>
<td>查找某个数据，如果数据存在返回对应的下标，否则报错</td>
</tr>
<tr>
<td>2</td>
<td>count()</td>
<td>统计某个数据在当前元组出现的次数</td>
</tr>
<tr>
<td>3</td>
<td>len(元组)</td>
<td>统计元组内的元素个数</td>
</tr>
</tbody>
</table>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ec22169f.png" alt=" " style="zoom:50%;" />
<blockquote>
<p><strong>==元组由于不可修改的特性，所以其操作方法非常少==</strong></p>
</blockquote>
<ul>
<li><strong>不可以修改元组的内容，否则会直接报错</strong></li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ec2d8d13.png" alt=" " style="zoom:67%;" />
<ul>
<li><strong>可以修改元组内的list的内容（修改元素、增加、删除、反转等）</strong></li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ec3a86b8.png" alt=" " style="zoom:67%;" />
<ul>
<li><strong>不可以替换list为其它list或其它类型</strong></li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ec47a293.png" alt=" " style="zoom:67%;" />
<blockquote>
<p>同列表一样，元组也可以被遍历。</p>
<p>可以使用while循环和for循环遍历它</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ec561116.png" alt=" " style="zoom: 67%;" />
<p><strong>元组的特点</strong></p>
<p>经过上述对元组的学习，可以总结出列表有如下特点：</p>
<ul>
<li>可以容纳多个数据</li>
<li>可以容纳不同类型的数据（混装）</li>
<li>数据是有序存储的（下标索引）</li>
<li>允许重复数据存在</li>
<li>不可以修改（增加或删除元素等）</li>
<li>支持for循环</li>
</ul>
<blockquote>
<p>多数特性和list一致，不同点在于不可修改的特性。</p>
</blockquote>
<h3 id="5-数据容器：str-字符串">5. 数据容器：str(字符串)</h3>
<ol>
<li>掌握字符串的常见操作</li>
</ol>
<p><strong>再识字符串</strong></p>
<blockquote>
<p>尽管字符串看起来并不像：列表、元组那样，一看就是存放了许多数据的容器。</p>
<p>但不可否认的是，字符串同样也是数据容器的一员。</p>
</blockquote>
<ul>
<li>
<p>字符串是<strong>字符的容器</strong>，一个字符串可以存放任意数量的字符。</p>
<p>如，字符串：“itheima”</p>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ec61e3f5.png" alt=" " style="zoom:67%;" />
<p><strong>字符串的下标（索引）</strong></p>
<blockquote>
<p>和其它容器如：列表、元组一样，字符串也可以通过下标进行访问</p>
<p>•从前向后，下标从0开始</p>
<p>•从后向前，下标从-1开始</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ec6ced4c.png" alt=" " style="zoom:67%;" />
<p>同元组一样，字符串是一个：<strong>无法修改的数据容器</strong>。</p>
<p>所以：</p>
<ul>
<li>修改指定下标的字符 （如：字符串[0] = “a”）</li>
<li>移除特定下标的字符 （如：del 字符串[0]、字符串.remove()、字符串.pop()等）</li>
<li>追加字符等 （如：字符串.append()）</li>
</ul>
<p>均无法完成。如果必须要做，只能<strong>得到一个新的字符串，旧的字符串是无法修改</strong></p>
<h4 id="字符串常用操作汇总">==<strong>字符串常用操作汇总</strong>==</h4>
<table>
<thead>
<tr>
<th><strong>编号</strong></th>
<th><strong>操作</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>字符串[下标]</td>
<td>根据下标索引取出特定位置字符</td>
</tr>
<tr>
<td>2</td>
<td>字符串.index(字符串）</td>
<td>查找给定字符的第一个匹配项的下标</td>
</tr>
<tr>
<td>3</td>
<td>字符串.replace(字符串1, 字符串2)</td>
<td>将字符串内的全部字符串1，替换为字符串2  不会修改原字符串，而是得到一个新的</td>
</tr>
<tr>
<td>4</td>
<td>字符串.split(字符串)</td>
<td>按照给定字符串，对字符串进行分隔  不会修改原字符串，而是得到一个新的列表</td>
</tr>
<tr>
<td>5</td>
<td>字符串.strip()  字符串.strip(字符串)</td>
<td>移除首尾的空格和换行符或指定字符串</td>
</tr>
<tr>
<td>6</td>
<td>字符串.count(字符串)</td>
<td>统计字符串内某字符串的出现次数</td>
</tr>
<tr>
<td>7</td>
<td>len(字符串)</td>
<td>统计字符串的字符个数</td>
</tr>
<tr>
<td>8</td>
<td>字符串1.find(字符串2)</td>
<td>检测中字符串1中是否含有字符串2，如果有返回开始的索引值，否则返回<code>-1</code></td>
</tr>
<tr>
<td>9</td>
<td>字符串.lower() ； 字符串.upper()</td>
<td>将字符串中所有字母转化为小写；将字符串中所有字母转化为大写</td>
</tr>
<tr>
<td>10</td>
<td>字符串.splitlines()</td>
<td>按照行分隔，返回一个包含各行作为元素的列表</td>
</tr>
<tr>
<td>11</td>
<td>字符串1.join(字符串2)</td>
<td>用于将字符串2中的元素以字符串1连接生成一个新的字符串。</td>
</tr>
</tbody>
</table>
<p>同列表、元组一样，字符串也支持while循环和for循环进行遍历</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ec794225.png" alt=" " style="zoom: 67%;" />
<p><strong>字符串的特点</strong></p>
<p>作为数据容器，字符串有如下特点：</p>
<ul>
<li>只可以存储字符串</li>
<li>长度任意（取决于内存大小）</li>
<li>支持下标索引</li>
<li>允许重复字符串存在</li>
<li>不可以修改（增加或删除元素等）</li>
<li>支持for循环</li>
</ul>
<blockquote>
<p>基本和列表、元组相同</p>
<p>不同与列表和元组的在于：字符串容器可以容纳的类型是<strong>单一的</strong>，只能是字符串类型。</p>
<p>不同于列表，相同于元组的在于：字符串不可修改</p>
</blockquote>
<h3 id="6-数据容器（序列）的切片">6. 数据容器（序列）的切片</h3>
<p>1.了解什么是序列</p>
<p>2.掌握序列的切片操作</p>
<blockquote>
<p>序列是指：内容连续、有序，可使用下标索引的一类数据容器</p>
<p>列表、元组、字符串，均可以可以视为序列。</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ec863656.png" alt=" " style="zoom:67%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ec92ae5b.png" alt=" " style="zoom:67%;" />
<p><strong>如图，序列的典型特征就是：有序并可用下标索引，字符串、元组、列表均满足这个要求</strong></p>
<p><strong>序列的常用操作切片</strong></p>
<blockquote>
<p>序列支持切片，即：列表、元组、字符串，均支持进行切片操作<br>
切片：从一个序列中，取出一个子序列</p>
<p>语法：==序列[起始下标:结束下标:步长]【左闭右开）==<br>
表示从序列中，从指定位置开始，依次取出元素，到指定位置结束，得到一个新序列：</p>
<ul>
<li>起始下标表示从何处开始，可以留空，留空视作从头开始</li>
<li>结束下标（不含）表示何处结束，可以留空，留空视作截取到结尾</li>
<li>步长表示，依次取元素的间隔</li>
<li>步长1表示，一个个取元素</li>
<li>步长2表示，每次跳过1个元素取</li>
<li>步长N表示，每次跳过N-1个元素取</li>
<li>步长为负数表示，反向取（注意，起始下标和结束下标也要反向标记）
<ul>
<li>切片两个下标可以超过序列的长度，如a = [1,2,3,4,5]则a[3:100]正常输出为[4,5]</li>
</ul>
</li>
</ul>
<p>注意，此<strong>操作不会影响序列本身，而是会得到一个新的序列（列表、元组、字符串）</strong></p>
</blockquote>
<p><strong>序列的切片演示</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ec9de763.png" alt=" " style="zoom:67%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eca9417b.png" alt=" " style="zoom:67%;" />
<blockquote>
<p><strong>可以看到，这个操作对列表、元组、字符串是通用的</strong></p>
<p><strong>同时非常灵活，根据需求，起始位置，结束位置，步长（正反序）都是可以自行控制的</strong></p>
<p><strong>注意[::1]这种写法是包含最右边的</strong></p>
</blockquote>
<h3 id="7-set-集合">7. set(集合)</h3>
<p>掌握集合的定义格式</p>
<p>掌握集合的特点</p>
<p>掌握集合的常见操作</p>
<p><strong>为什么使用集合</strong></p>
<p>我们目前接触到了列表、元组、字符串三个数据容器了。基本满足大多数的使用场景。</p>
<p>为何又需要学习新的集合类型呢？</p>
<p><strong>通过特性来分析：</strong></p>
<ul>
<li>
<p>列表可修改、支持重复元素且有序</p>
</li>
<li>
<p>元组、字符串不可修改、支持重复元素且有序</p>
</li>
</ul>
<p>同学们，有没有看出一些<strong>局限</strong>？</p>
<p>局限就在于：它们都支持重复元素。</p>
<blockquote>
<p>如果场景需要对内容做去重处理，列表、元组、字符串就不方便了。</p>
<p>而集合，最主要的特点就是：不支持元素的重复（==自带<strong>去重</strong>功能）、并且内容<strong>无序</strong>==</p>
</blockquote>
<p><strong>基本语法：</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ecb60312.png" alt=" " style="zoom:50%;" />
<blockquote>
<p>和列表、元组、字符串等定义基本相同：</p>
<p>•列表使用：[]</p>
<p>•元组使用：()</p>
<p>•字符串使用：“”</p>
<p>•集合使用：{}</p>
</blockquote>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ecc1ab91.png" alt=" " style="zoom: 80%;" />
<blockquote>
<p><strong>结果中可见：去重且无序</strong></p>
<p><strong>因为要对元素做去重处理</strong></p>
<p><strong>所以无法保证顺序和创建的时候一致</strong></p>
</blockquote>
<p><strong>集合的常用操作修改</strong>==(集合仅支持增删改但没有查)==</p>
<p>首先，因为集合是无序的，所以集合不支持：下标索引访问</p>
<p>但是集合和列表一样，是允许修改的，所以我们来看看集合的修改方法。</p>
<table>
<thead>
<tr>
<th><strong>编号</strong></th>
<th><strong>操作</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>集合.add(元素)</td>
<td>集合内添加一个元素</td>
</tr>
<tr>
<td>2</td>
<td>集合.remove(元素)</td>
<td>移除集合内指定的元素</td>
</tr>
<tr>
<td>3</td>
<td>集合.pop()</td>
<td>从集合中随机取出一个元素</td>
</tr>
<tr>
<td>4</td>
<td>集合.clear()</td>
<td>将集合清空</td>
</tr>
<tr>
<td>5</td>
<td>集合1.difference(集合2)</td>
<td>得到一个新集合，内含2个集合的差集  原有的2个集合内容不变</td>
</tr>
<tr>
<td>6</td>
<td>集合1.difference_update(集合2)</td>
<td>在集合1中，删除集合2中存在的元素  集合1被修改，集合2不变</td>
</tr>
<tr>
<td>7</td>
<td>集合1.union(集合2)</td>
<td>得到1个新集合，内含2个集合的全部元素  原有的2个集合内容不变</td>
</tr>
<tr>
<td>8</td>
<td>len(集合)</td>
<td>得到一个整数，记录了集合的元素数量</td>
</tr>
</tbody>
</table>
<p><strong>集合同样支持使用for循环遍历</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eccc9a22.png" alt=" " style="zoom: 67%;" />
<blockquote>
<p>要注意：集合不支持下标索引，所以也就不支持使用while循环</p>
</blockquote>
<p><strong>集合的特点</strong></p>
<p>经过上述对集合的学习，可以总结出集合有如下特点：</p>
<ul>
<li>可以容纳多个数据</li>
<li>可以容纳不同类型的数据（混装）</li>
<li>数据是无序存储的（不支持下标索引）</li>
<li>不允许重复数据存在</li>
<li>可以修改（增加或删除元素等）</li>
<li>支持for循环</li>
</ul>
<h3 id="8-数据容器：dict-字典、映射">8. 数据容器：dict(字典、映射)</h3>
<h4 id="1-字典的定义">1. <strong>字典的定义</strong></h4>
<p>掌握字典的定义格式</p>
<blockquote>
<p><strong>为什么需要字典</strong></p>
<p>因为可以使用字典，实现用key取出Value的操作</p>
</blockquote>
<p><strong>字典的定义，同样使用{}，不过存储的元素是一个个的：==键值对，==如下语法：</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ecd9d0be.png" alt=" " style="zoom:50%;" />
<ul>
<li>使用{}存储原始，每一个元素是一个键值对</li>
<li>每一个键值对包含Key和Value（用冒号分隔）</li>
<li>键值对之间使用逗号分隔</li>
<li>Key和Value可以是任意类型的数据（key不可为字典，和列表）</li>
<li>Key不可重复，重复会对原有数据覆盖</li>
</ul>
<p><strong>字典数据的获取</strong></p>
<p>字典同集合一样，不可以使用下标索引</p>
<p>但是字典可以通过Key值来取得对应的Value</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ece87210.png" alt=" " style="zoom:67%;" />
<h4 id="2-字典的常用操作">2. <strong>字典的常用操作</strong></h4>
<p>掌握字典的常用操作</p>
<p>掌握字典的特点</p>
<p><strong>字典的常用操作总结（==增删改查==）</strong></p>
<table>
<thead>
<tr>
<th><strong>编号</strong></th>
<th><strong>操作</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>字典[Key]</td>
<td>获取指定Key对应的Value值</td>
</tr>
<tr>
<td>2</td>
<td>字典[Key] = Value</td>
<td>添加或更新键值对</td>
</tr>
<tr>
<td>3</td>
<td>字典.pop(Key)</td>
<td>取出Key对应的Value并在字典内删除此Key的键值对</td>
</tr>
<tr>
<td>4</td>
<td>字典.clear()</td>
<td>清空字典</td>
</tr>
<tr>
<td>5</td>
<td>字典.keys()</td>
<td>获取字典的全部Key，可用于for循环遍历字典</td>
</tr>
<tr>
<td>6</td>
<td>len(字典)</td>
<td>计算字典内的元素数量</td>
</tr>
<tr>
<td>7</td>
<td>字典.values()</td>
<td>获取字典的全部value,可用for循环遍历打印value</td>
</tr>
<tr>
<td>8</td>
<td>字典.items()</td>
<td>获取字典的全部元素,可用for循环遍历打印元素</td>
</tr>
<tr>
<td>9</td>
<td>del 字典[key]</td>
<td>删除指定的元素</td>
</tr>
</tbody>
</table>
<blockquote>
<p>•遍历字典</p>
<p>语法：for key in 字典.keys()</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ecf4d7bf.png" alt=" " style="zoom:50%;" /><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/czzczzczz/image@main/202302082033014.png" alt=" " style="zoom:67%;" /></p>
<p><strong>注意：字典不支持下标索引，所以同样不可以用while循环遍历</strong></p>
</blockquote>
<p><strong>经过上述对字典的学习，可以总结出字典有如下特点：</strong></p>
<ul>
<li>可以容纳多个数据</li>
<li>可以容纳不同类型的数据</li>
<li>每一份数据是KeyValue键值对</li>
<li>可以通过Key获取到Value，Key不可重复（重复会覆盖）</li>
<li>不支持下标索引</li>
<li>可以修改（增加或删除更新元素等）</li>
<li>支持for循环，不支持while循环</li>
</ul>
<h3 id="9-数据容器的对比和通用操作">9. 数据容器的对比和通用操作</h3>
<p><strong>数据容器特点对比</strong></p>
<table>
<thead>
<tr>
<th></th>
<th><strong>列表</strong></th>
<th><strong>元组</strong></th>
<th><strong>字符串</strong></th>
<th><strong>集合</strong></th>
<th><strong>字典</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>元素数量</td>
<td>支持多个</td>
<td>支持多个</td>
<td>支持多个</td>
<td>支持多个</td>
<td>支持多个</td>
</tr>
<tr>
<td>元素类型</td>
<td>任意</td>
<td>任意</td>
<td>仅字符</td>
<td>任意</td>
<td>Key：Value  Key：除字典外任意类型  Value：任意类型</td>
</tr>
<tr>
<td>下标索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>重复元素</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
</tr>
<tr>
<td>可修改性</td>
<td>支持</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>数据有序</td>
<td>是</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>使用场景</td>
<td>可修改、可重复的一批数据记录场景</td>
<td>不可修改、可重复的一批数据记录场景</td>
<td>一串字符的记录场景</td>
<td>不可重复的数据记录场景</td>
<td>以Key检索Value的数据记录场景</td>
</tr>
</tbody>
</table>
<p><strong>数据容器的通用操作</strong> <strong>-</strong> <strong>遍历</strong></p>
<p>数据容器尽管各自有各自的特点，但是它们也有通用的一些操作。</p>
<blockquote>
<p><strong>首先，在遍历上：</strong></p>
<ul>
<li>
<p><strong>5类数据容器都支持for循环遍历</strong></p>
</li>
<li>
<p>列表、元组、字符串支持while循环，集合、字典不支持（无法下标索引）</p>
</li>
</ul>
<p><strong>尽管遍历的形式各有不同，但是，它们都支持遍历操作。</strong></p>
</blockquote>
<p><strong>数据容器的通用统计功能</strong></p>
<table>
<thead>
<tr>
<th><strong>功能</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>通用for循环</td>
<td>遍历容器（字典是遍历key）</td>
</tr>
<tr>
<td>max</td>
<td>容器内最大元素</td>
</tr>
<tr>
<td>min()</td>
<td>容器内最小元素</td>
</tr>
<tr>
<td>len()</td>
<td>容器元素个数</td>
</tr>
<tr>
<td>list()</td>
<td>转换为列表</td>
</tr>
<tr>
<td>tuple()</td>
<td>转换为元组</td>
</tr>
<tr>
<td>str()</td>
<td>转换为字符串</td>
</tr>
<tr>
<td>set()</td>
<td>转换为集合</td>
</tr>
<tr>
<td>sorted(序列, [reverse=True])</td>
<td>排序，reverse=True表示降序  得到一个排好序的列表</td>
</tr>
</tbody>
</table>
<p><strong>容器类型的类型互转</strong></p>
<p><strong>引入</strong></p>
<p>所谓互转，就是把一种数据类型在数值不变的情况下 转换为另外一种表示方式</p>
<p><strong>当前容器类型的互转不包含字典！！！（好像也不包括字符串）</strong></p>
<p><strong>基本使用</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]  <span class="comment"># 定义列表</span></span><br><span class="line">nums2 = (<span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>)  <span class="comment"># 定义元组</span></span><br><span class="line">nums3 = &#123;<span class="number">77</span>, <span class="number">88</span>, <span class="number">99</span>&#125;  <span class="comment"># 定义集合</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表转换为元组、集合</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------&quot;</span>)</span><br><span class="line">nums1_tuple = <span class="built_in">tuple</span>(nums1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(nums1_tuple))</span><br><span class="line">nums1_set = <span class="built_in">set</span>(nums1)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(nums1_set))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元组转换为列表、集合</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------&quot;</span>)</span><br><span class="line">nums2_list = <span class="built_in">list</span>(nums2)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(nums2_list))</span><br><span class="line">nums2_set = <span class="built_in">set</span>(nums2)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(nums2_set))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合转换为列表、元组</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-----------&quot;</span>)</span><br><span class="line">nums3_list = <span class="built_in">list</span>(nums3)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(nums3_list))</span><br><span class="line">nums3_tuple = <span class="built_in">tuple</span>(nums3)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(nums3_tuple))</span><br></pre></td></tr></table></figure>
<p><strong>快速去重</strong></p>
<p>使用<code>set</code>，可以快速的完成对<code>list</code>、<code>tuple</code>中的元素去重复的功能</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums1 = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">55</span>, <span class="number">666</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>]</span><br><span class="line">nums2 = (<span class="number">11</span>, <span class="number">22</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">55</span>, <span class="number">666</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(nums1))  <span class="comment"># 将 nums1 转换为集合的时候，就自动去重了</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">set</span>(nums2))  <span class="comment"># 将 nums2 转换为集合的时候，就自动去重了</span></span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;33, 11, 44, 22, 55, 666&#125;</span><br><span class="line">&#123;33, 11, 44, 22, 55, 666&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通用类型转换里没有字典</p>
</blockquote>
<h3 id="10-推导式">10. 推导式</h3>
<p><strong>引入</strong></p>
<p>推导式：就是一种能够快速生成数据的方式</p>
<p>例如，想要快速生成由1~20内所有偶数数组成的列表，就可以用&quot;推导式&quot;，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]</span><br></pre></td></tr></table></figure>
<p><strong>分类</strong></p>
<p>推导式，根据最终要生成的数据，简单划分为</p>
<ul>
<li>列表推导式</li>
<li>集合推导式</li>
<li>字典推导式</li>
</ul>
<p>注意：==没有元组推导式==，而是生成器（在Python高级进阶课程中在学习）</p>
<h4 id="列表推导式">列表推导式</h4>
<p>列表推导式：一种可以快速生成列表的方式</p>
<p>代码格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[变量 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 可迭代对象]</span><br></pre></td></tr></table></figure>
<p>基本使用：</p>
<p>案例一：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: a = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: a</span><br><span class="line">Out [<span class="number">2</span>]: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: a = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">4</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: a</span><br><span class="line">Out [<span class="number">4</span>]: [<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: a = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">19</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: a</span><br><span class="line">Out [<span class="number">6</span>]: [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: a = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">19</span>, <span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">8</span>]: a</span><br><span class="line">Out [<span class="number">8</span>]: [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">15</span>, <span class="number">17</span>]</span><br></pre></td></tr></table></figure>
<p>案例二：列表推导式中用到了 <code>if</code></p>
<p>注意：列表推导式如果<code>for</code>中用到了<code>if</code>，<code>for</code>不用写<code>:</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">9</span>]: a = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">10</span>]: a</span><br><span class="line">Out [<span class="number">10</span>]: [<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">11</span>]: a = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, <span class="number">10</span>) <span class="keyword">if</span> x % <span class="number">2</span> != <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">12</span>]: a</span><br><span class="line">Out [<span class="number">12</span>]: [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>
<p>案例三：在列表推导式中使用两个 <code>for</code> 循环</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">13</span>]: a = [(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>) <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">14</span>]: a</span><br><span class="line">Out [<span class="number">14</span>]: [(<span class="number">1</span>, <span class="number">0</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>)]</span><br></pre></td></tr></table></figure>
<p>案例四：在列表推导式中使用三个 <code>for</code> 循环</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">15</span>]: a = [(x, y, z) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">3</span>) <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>) <span class="keyword">for</span> z <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>, <span class="number">6</span>)]</span><br><span class="line"></span><br><span class="line">In [<span class="number">16</span>]: a</span><br><span class="line">Out [<span class="number">16</span>]: </span><br><span class="line">[(<span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">0</span>, <span class="number">5</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">0</span>, <span class="number">5</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line"> (<span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>)]</span><br></pre></td></tr></table></figure>
<p><strong>练习</strong></p>
<p>请写出一段 Python 代码实现分组：一个 list 里面的元素,比如<code> [1,2,3,...100]</code>变成<code> [[1,2,3],[4,5,6]....]</code></p>
<p>参考答案：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">101</span>)]</span><br><span class="line">b = [a[x: x+<span class="number">3</span>] <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(a),<span class="number">3</span>)]</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<h4 id="集合推导式">集合推导式</h4>
<p>集合推导式：一种快速生成集合的方式</p>
<p>示例代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">5</span>]: a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: <span class="built_in">type</span>(a)</span><br><span class="line">Out [<span class="number">6</span>]: <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">7</span>]: a</span><br><span class="line">Out [<span class="number">7</span>]: &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure>
<p>集合推导式中也可以用<code>if</code>等，与列表推导式在格式上很类似，这里就不做过多的介绍，请类别列表推导式进行学习</p>
<h4 id="字典推导式">字典推导式</h4>
<p>字典推导式：一种快速生成字典的方式</p>
<p>案例一：快速生成一个1~10内key为某个数此时value为平方的字典</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;x: x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81, 10: 100&#125;</span><br></pre></td></tr></table></figure>
<p>案例二：快速生成一个1~10内key可以1时value为2，key为2时value3…依次类推的字典</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;x: (x + <span class="number">1</span>) <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>)&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 7, 7: 8, 8: 9, 9: 10, 10: 11&#125;</span><br></pre></td></tr></table></figure>
<p><strong>练习</strong></p>
<p>编写代码用推导式，实现如下效果（列表中嵌套字典）</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[&#123;1: 1&#125;,</span><br><span class="line"> &#123;2: 4&#125;,</span><br><span class="line"> &#123;3: 9&#125;,</span><br><span class="line"> &#123;4: 16&#125;,</span><br><span class="line"> &#123;5: 25&#125;,</span><br><span class="line"> &#123;6: 36&#125;,</span><br><span class="line"> &#123;7: 49&#125;,</span><br><span class="line"> &#123;8: 64&#125;,</span><br><span class="line"> &#123;9: 81&#125;,</span><br><span class="line"> &#123;10: 100&#125;]</span><br></pre></td></tr></table></figure>
<p>参考代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#123;x: x ** <span class="number">2</span>&#125; <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br></pre></td></tr></table></figure>
<h4 id="拆包">拆包</h4>
<p><strong>引入</strong></p>
<p>拆包：是一种快速提取数据的方式</p>
<p>例如，有一个元组<code>(11, 22, 33, 44)</code>想快速的提取每个元素且赋值给<code>num1, num2, num3, num4</code>这4个变量</p>
<p>普通的做法，较为繁琐：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nums = (<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>)  <span class="comment"># 定义一个元组</span></span><br><span class="line">num1 = nums [<span class="number">0</span>]  <span class="comment"># 通过下标来提取</span></span><br><span class="line">num2 = nums [<span class="number">1</span>]  <span class="comment"># 通过下标来提取</span></span><br><span class="line">num3 = nums [<span class="number">2</span>]  <span class="comment"># 通过下标来提取</span></span><br><span class="line">num4 = nums [<span class="number">3</span>]  <span class="comment"># 通过下标来提取</span></span><br></pre></td></tr></table></figure>
<p>拆包的方式，可以见非常简洁：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num1, num2, num3, num4 = (<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>)  <span class="comment"># 一行代码搞定</span></span><br></pre></td></tr></table></figure>
<p><strong>列表拆包</strong></p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a, b = [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11</span><br><span class="line">22</span><br></pre></td></tr></table></figure>
<p><strong>元组拆包</strong></p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a, b = (<span class="number">11</span>, <span class="number">22</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11</span><br><span class="line">22</span><br></pre></td></tr></table></figure>
<p><strong>集合拆包</strong></p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a, b = &#123;<span class="number">11</span>, <span class="number">22</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11</span><br><span class="line">22</span><br></pre></td></tr></table></figure>
<p><strong>字典拆包</strong></p>
<blockquote>
<p>一般用法</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a, b = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;顾安&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name</span><br><span class="line">age</span><br></pre></td></tr></table></figure>
<p><strong>默认取到的是字典的key，而不是value</strong></p>
<blockquote>
<p>常见用法</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">teacher_info = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;顾安&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> teacher_info.items():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;k = %s, v = %s&#x27;</span> % (k, v))</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k = name, v = 顾安</span><br><span class="line">k = age, v = 18</span><br></pre></td></tr></table></figure>
<p><strong>注意点</strong></p>
<p><code>=</code>右边要拆的数据元素的个数 要 与<code>=</code>左边存的变量个数相同</p>
<p>错误示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a, b = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ValueError                                Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-19-887c339c8076&gt; in &lt;module&gt;</span><br><span class="line"><span class="meta prompt_">----&gt; </span><span class="language-bash">1 a, b = [11, 22, 33]</span></span><br><span class="line"></span><br><span class="line">ValueError: too many values to unpack (expected 2)</span><br></pre></td></tr></table></figure>
<p><strong>经典面试题：交换两个变量的值</strong></p>
<p>方式一：普通方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">4</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;交换之前 a =%d, b =%d&quot;</span> % (a, b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 额外定义一个变量，用来临时使用</span></span><br><span class="line">c = a</span><br><span class="line">a = b</span><br><span class="line">b = c</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;交换之后 a =%d, b =%d&quot;</span> % (a, b))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交换之前 a = 4, b = 5</span><br><span class="line">交换之后 a = 5, b = 4</span><br></pre></td></tr></table></figure>
<p>方式二：巧妙方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">4</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;交换之前 a =%d, b =%d&quot;</span> % (a, b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 巧妙之处（没有用额外的变量）</span></span><br><span class="line">a = a+b</span><br><span class="line">b = a-b</span><br><span class="line">a = a-b</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;交换之后 a =%d, b =%d&quot;</span> % (a, b))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交换之前 a = 4, b = 5</span><br><span class="line">交换之后 a = 5, b = 4</span><br></pre></td></tr></table></figure>
<p>方式三：拆包方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">4</span></span><br><span class="line">b = <span class="number">5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;交换之前 a =%d, b =%d&quot;</span> % (a, b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 独到之处</span></span><br><span class="line">a, b = b, a  <span class="comment"># </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;交换之后 a =%d, b =%d&quot;</span> % (a, b))</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">交换之前 a = 4, b = 5</span><br><span class="line">交换之后 a = 5, b = 4</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ul>
<li><code>a, b = b, a</code>首先要计算<code>=</code>右边<code>b, a</code>此时他们会被当做一个元组即<code>(b, a)</code>就相当于<code>(5, 4)</code></li>
<li>然后再将<code>a, b = (5, 4)</code>进行计算，此时a为<code>5</code>，b为<code>4</code></li>
</ul>
<h2 id="2-6-Python函数进阶">2.6 Python函数进阶</h2>
<h3 id="1-函数多返回值">1. 函数多返回值</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ed016109.png" alt="image-20230216140003769" style="zoom:67%;" />
<ul>
<li>按照返回值的顺序，写对应顺序的多个变量接收即可（拆包）</li>
<li>变量之间用逗号隔开</li>
<li>支持不同类型的数据return</li>
</ul>
<h3 id="2-函数多种传参方式">2. 函数多种传参方式</h3>
<h4 id="1-位置参数">1. <strong>位置参数</strong></h4>
<ul>
<li>
<p>调用函数时根据函数定义的参数位置来传递参数</p>
</li>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ed0de810.png" alt="image-20230216140147012" style="zoom:50%;" />
</li>
<li>
<p>注意：</p>
<p>传递的参数和定义的参数的<strong>顺序及个数</strong>必须一致</p>
</li>
</ul>
<h4 id="2-关键字参数">2. <strong>关键字参数</strong></h4>
<ul>
<li>
<p>函数调用时通过“键=值”形式传递参数.</p>
</li>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ed1cb8ba.png" alt="image-20230216140238228" style="zoom:50%;" />
</li>
<li>
<p>注意：</p>
<p>​    函数调用时，如果有位置参数时，位置参数必须在关键字参数的前面，但关键字参数之间不存在先后顺序</p>
</li>
</ul>
<h4 id="3-缺省参数">3. <strong>缺省参数</strong></h4>
<ul>
<li>
<p>缺省参数也叫默认参数，用于定义函数，为参数提供默认值，调用函数时可不传该默认参数的值（注意：所有位置参数必须出现在默认参数前，包括函数定义和调用）</p>
</li>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ed29fb90.png" alt="image-20230216140343482" style="zoom:50%;" />
</li>
<li>
<p>注意：</p>
<p>​    函数调用时，如果为缺省参数传值则修改默认参数值, 否则使用这个默认值</p>
</li>
</ul>
<h4 id="4-不定长参数">4. <strong>不定长参数</strong></h4>
<ul>
<li>
<p>不定长参数也叫可变参数. 用于不确定调用的时候会传递多少个参数(不传参也可以)的场景.</p>
</li>
<li>
<p><strong>不定长参数的类型</strong></p>
<ul>
<li>
<p>①位置传递</p>
<ul>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ed3678ed.png" alt="image-20230216140511954" style="zoom:50%;" />
</li>
<li>
<p>注意：</p>
<p>传进的所有参数都会被args变量收集，它会根据传进参数的位置合并为一个元组(tuple)，args是<strong>元组类型</strong>，这就是位置传递</p>
</li>
</ul>
</li>
<li>
<p>②关键字传递</p>
<ul>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ed4311ab.png" alt="image-20230216140558310" style="zoom:50%;" />
</li>
<li>
<p>注意：</p>
<p>参数是“键=值”形式的形式的情况下, 所有的“键=值”都会被kwargs接受, 同时会根据“键=值”组成<strong>字典.</strong></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-匿名函数">3. 匿名函数</h3>
<h4 id="1-函数作为参数传递">1. <strong>函数作为参数传递</strong></h4>
<p>如下代码：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/czzczzczz/image@main/202302161409892.png" alt="image-20230216140923831" style="zoom:50%;" /><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ed4ea1f5.png" alt="image-20230216140933790" style="zoom:50%;" /><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/czzczzczz/image@main/202302161409931.png" alt="image-20230216140950863" style="zoom:50%;" /></p>
<p><strong>函数compute，作为参数，传入了test_func函数中使用。</strong></p>
<ul>
<li>test_func需要一个函数作为参数传入，这个函数需要接收2个数字进行计算，计算逻辑由这个被传入函数决定</li>
<li>compute函数接收2个数字对其进行计算，compute函数作为参数，传递给了test_func函数使用</li>
<li>最终，在test_func函数内部，由传入的compute函数，完成了对数字的计算操作</li>
<li>所以，这是一种，计算逻辑的传递，而非数据的传递。</li>
<li>就像上述代码那样，不仅仅是相加，相见、相除、等任何逻辑都可以自行定义并作为函数传入。</li>
</ul>
<h4 id="2-lambda匿名函数">2. <strong>lambda</strong>匿名函数</h4>
<blockquote>
<p>函数的定义中</p>
<ul>
<li>def关键字，可以定义带有名称的函数</li>
<li>lambda关键字，可以定义匿名函数（无名称）</li>
</ul>
<p>有名称的函数，可以基于名称重复使用。</p>
<p>无名称的匿名函数，只可临时使用一次。</p>
</blockquote>
<p><strong>匿名函数定义语法：</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ed5a74e0.png" alt="image-20230216141158767" style="zoom:67%;" />
<ul>
<li>传入参数表示匿名函数的形式参数，如：x, y 表示接收2个形式参数</li>
<li>函数体，就是函数的执行逻辑，要注意：<strong>只能写一行</strong>，无法写多行代码</li>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ed67151a.png" alt="image-20230216141351771" style="zoom:50%;" />
</li>
</ul>
<h4 id="3-函数返回值拆包">3. 函数返回值拆包</h4>
<h4 id="什么是函数返回值拆包">什么是函数返回值拆包</h4>
<p>函数返回值拆包：如果一个函数通过<code>return</code>返回了一个元组、列表、集合，可以通过拆包的方式将返回值进行拆分到每个变量中，这就是返回值拆包。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span></span><br><span class="line"></span><br><span class="line">a, b, c = test()</span><br><span class="line"><span class="built_in">print</span>(a, b, c)</span><br></pre></td></tr></table></figure>
<h4 id="返回值拆包的作用">返回值拆包的作用</h4>
<p>通过函数返回值拆包，可以快速的将具体的数据用变量进行存储，这样对数据的处理会更加方便</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="keyword">return</span> <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过返回值拆包，快速使用每个数据</span></span><br><span class="line">a, b, c = test()</span><br><span class="line"><span class="built_in">print</span>(a + b + c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有通过返回值拆包，这样用数据时稍微复杂</span></span><br><span class="line">ret = test()</span><br><span class="line"><span class="built_in">print</span>(ret [<span class="number">0</span>] + ret [<span class="number">1</span>] + ret [<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p><strong>拆包的使用</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_my_info</span>():</span><br><span class="line">    high = <span class="number">178</span></span><br><span class="line">    weight = <span class="number">100</span></span><br><span class="line">    age = <span class="number">18</span></span><br><span class="line">    <span class="keyword">return</span> high, weight, age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># result = get_my_info()</span></span><br><span class="line"><span class="comment"># print(result)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过返回值拆包，能够更加方便的对每个数据使用</span></span><br><span class="line">my_high, my_weight, my_age = get_my_info()</span><br><span class="line"><span class="built_in">print</span>(my_high)</span><br><span class="line"><span class="built_in">print</span>(my_weight)</span><br><span class="line"><span class="built_in">print</span>(my_age)</span><br></pre></td></tr></table></figure>
<p><strong>使用拆包时的注意点</strong></p>
<ul>
<li>拆包时要注意，需要拆的数据的个数要与变量的个数相同，否则程序会异常</li>
</ul>
<h4 id="通过星号拆包">通过星号拆包</h4>
<p><strong>通过普通方式拆包</strong></p>
<p>假如有以下函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b + c)</span><br></pre></td></tr></table></figure>
<p>现在自己拥有的数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br></pre></td></tr></table></figure>
<p>怎样才能在调用<code>test</code>函数的时候，将<code>nums</code>给传递过去呢?</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b + c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br><span class="line">test(nums [<span class="number">0</span>], nums [<span class="number">1</span>], nums [<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<p>上述代码用的方式虽然能行，但不是很简洁</p>
<p>为了能够用更加简洁的方式实现上述场景需求，Python可以通过<code>*</code>、<code>**</code>将数据拆包后传递</p>
<p><strong>使用<code>*</code>拆包</strong></p>
<p>有时在调用函数时，这个函数需要的是多个参数，而自己拥有的是一个列表或者集合这样的数据，此时就用可以用<code>*</code>拆包</p>
<p>使用方式：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*列表</span><br><span class="line">*元组</span><br><span class="line">*集合</span><br></pre></td></tr></table></figure>
<p>用<code>*</code>拆包的方式实现上述功能：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b + c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br><span class="line">test(*nums)  <span class="comment"># 此时的* 的作用就是拆包，此时*nums 相当于 11, 22, 33 即 test(11, 22, 33)</span></span><br></pre></td></tr></table></figure>
<p>如果为数据元组时使用方式与上述代码一致：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b + c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = (<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>)</span><br><span class="line">test(*nums)</span><br></pre></td></tr></table></figure>
<p>集合类型同上：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b + c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;</span><br><span class="line">test(*nums)</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li><code>*</code>对列表、元组、集合可以拆包，但一般都是在调用函数时用</li>
</ul>
<p><strong>使用<code>**</code>拆包</strong></p>
<p>使用<code>**</code>可以对字典进行拆包，拆包的结果是命名参数</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">name, age, address</span>):</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line">    <span class="built_in">print</span>(age)</span><br><span class="line">    <span class="built_in">print</span>(address)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">info = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;顾安&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&quot;address&quot;</span>: <span class="string">&quot;长沙&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(**info)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">当前**info 相当于以下代码：</span></span><br><span class="line"><span class="string">	name =&#x27;顾安&#x27;</span></span><br><span class="line"><span class="string">	age = 18</span></span><br><span class="line"><span class="string">	address =&#x27;长沙&#x27;</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">** 主要对字典进行拆包</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>难点</strong></p>
<p>学习不定长参数时，掌握了<code>*args</code>、<code>**kwargs</code></p>
<p>现在学习拆包时，也用到了<code>*</code>、<code>**</code></p>
<p>那它们之间有什么关系呢？</p>
<p>答：没有任何关系，只是长得像罢了</p>
<p>示例一：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----在 test1 函数中----&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;args:&quot;</span>, args)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;kwargs&quot;</span>, kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----在 test2 函数中----&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;args:&quot;</span>, args)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;kwargs&quot;</span>, kwargs)</span><br><span class="line">    test1(args, kwargs)  <span class="comment"># 在函数 test1 传递参数时没有进行拆包</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test2(<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, name = <span class="string">&quot;顾安&quot;</span>, age = <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----在 test2 函数中----</span><br><span class="line">args: (11, 22, 33)</span><br><span class="line">kwargs &#123;&#x27;name&#x27;: &#x27;顾安&#x27;, &#x27;age&#x27;: 18&#125;</span><br><span class="line">----在 test1 函数中----</span><br><span class="line">args: ((11, 22, 33), &#123;&#x27;name&#x27;: &#x27;顾安&#x27;, &#x27;age&#x27;: 18&#125;)</span><br><span class="line">kwargs &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>示例二：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----在 test1 函数中----&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;args:&quot;</span>, args)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;kwargs&quot;</span>, kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----在 test2 函数中----&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;args:&quot;</span>, args)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;kwargs&quot;</span>, kwargs)</span><br><span class="line">    test1(*args, **kwargs)  <span class="comment"># 对参数进行了拆包</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test2(<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, name = <span class="string">&quot;顾安&quot;</span>, age = <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">----在 test2 函数中----</span><br><span class="line">args: (11, 22, 33)</span><br><span class="line">kwargs &#123;&#x27;name&#x27;: &#x27;顾安&#x27;, &#x27;age&#x27;: 18&#125;</span><br><span class="line">----在 test1 函数中----</span><br><span class="line">args: (11, 22, 33)</span><br><span class="line">kwargs &#123;&#x27;name&#x27;: &#x27;顾安&#x27;, &#x27;age&#x27;: 18&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-Python语言中的引用">4. <code>Python</code>语言中的引用</h4>
<p><strong>引入</strong></p>
<p>如下代码中，最后b的值为多少？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>如下代码中，最后b的值为多少？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<h4 id="什么是引用">什么是引用</h4>
<p>引用：就是地址</p>
<p>那地址是什么呢？可以理解为存放数据的空间在内存中的编号</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>怎样知道它的地址呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">id</span>(a)</span><br></pre></td></tr></table></figure>
<p>可以直接将上述的结果打印：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br></pre></td></tr></table></figure>
<p>运行结果（在不同机器上输出的地址可能不相同）：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4347271232</span><br></pre></td></tr></table></figure>
<p>当我们知道了原来引用就是地址之后，再来看如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>我们可以用<code>id(a)</code>取它的地址：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))  <span class="comment"># 获取变量存储的引用（地址）是多少</span></span><br></pre></td></tr></table></figure>
<p>接下来定义变量b并且赋值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))  <span class="comment"># 获取变量存储的引用（地址）是多少</span></span><br><span class="line"></span><br><span class="line">b = a</span><br></pre></td></tr></table></figure>
<p>此时输出变量b的引用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))</span><br><span class="line"></span><br><span class="line">b = a</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b))</span><br></pre></td></tr></table></figure>
<p>运行结果（不同机器上的内存地址可能不相同）：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4558971360</span><br><span class="line">4558971360</span><br></pre></td></tr></table></figure>
<p>这说明，此时变量a、b存储的引用都是相同的</p>
<p>由此我们可以得出一个结论：<strong>Python中的变量并不是真正存储数据，而是存储的数据所在内存中的地址，我们一般称之为引用</strong></p>
<p>既然变量a、b都指向同一个列表，那么接下来</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.append(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>此时变量a、b指向的同一个列表中多了一个数据，即此时列表为<code>[1, 2, 3]</code></p>
<p>所以a、b此时用<code>print</code>输出相同的结果</p>
<blockquote>
<p>补充内容</p>
<p>大家自己试试看a=257, b=257时它们的id还是否会相等。事实上Python 为了优化速度，使用了小整数对象池，避免为整数频繁申请和销毁内存空间。而Python 对小整数的定义是 [-5, 257)，只有数字在-5到256之间它们的id才会相等，超过了这个范围就不行了，同样的道理，字符串对象也有一个类似的缓冲池，超过区间范围内自然不会相等了。**</p>
<p>总的来说，只有数值型和字符串型，并且在通用对象池中的情况下，a is b才为True，否则当a和b是int，str，tuple，list，dict或set型时，a is b均为False。</p>
</blockquote>
<p><strong>赋值运算符<code>=</code></strong></p>
<p>赋值运算符<code>=</code>，之前为了更好的理解变量，把<code>a=100</code>理解为变量a中存放了<code>100</code>，事实上变量<code>a</code>存储是<code>100</code>的引用</p>
<p>也就是说：在Python中只要用<code>=</code>那么就表示<code>=</code>左边的变量存储了一个新的引用（==‘=’可以看作➡==）</p>
<p>大白话讲：就是<code>=</code>左边的变量指向了右边的数据</p>
<p>想想下面的代码运行的结果是什么？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">b = a</span><br><span class="line">b.append(<span class="number">3</span>)</span><br><span class="line">b = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[100, 200, 300]</span><br></pre></td></tr></table></figure>
<p>而不是：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure>
<h4 id="引用当做实参">引用当做实参</h4>
<p>Python中调用函数时，传递实参实际上都是是引用，即传递的都是地址</p>
<p>只要是传递的引用，那么也就是说在函数中是可以直接对指向的数据进行修改</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">p</span>):</span><br><span class="line">    <span class="comment"># 此时变量 p 也指向 nums 指向的列表</span></span><br><span class="line">    p.append(<span class="number">44</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;在函数 test 中，p =&quot;</span>, p)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;调用 test 函数之前，nums =&quot;</span>, nums)</span><br><span class="line">test(nums)  <span class="comment"># 此时将列表的引用当做了实参进行传递</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;调用 test 函数之后，nums =&quot;</span>, nums)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用 test 函数之前，nums = [11, 22, 33]</span><br><span class="line">在函数 test 中，p = [11, 22, 33, 44]</span><br><span class="line">调用 test 函数之后，nums = [11, 22, 33, 44]</span><br></pre></td></tr></table></figure>
<h4 id="函数名也是引用">函数名也是引用</h4>
<p><strong>引入</strong></p>
<p>阅读如下代码，思考会输出什么结果</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是 test1 函数哦。。。。&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;我是 test2 函数哦。。。。&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test1()</span><br><span class="line"></span><br><span class="line">test1 = test2</span><br><span class="line">test1()</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我是 test1 函数哦。。。。</span><br><span class="line">我是 test2 函数哦。。。。</span><br></pre></td></tr></table></figure>
<p>你可能会惊讶，为什么第9行调用<code>test1</code>函数输出的是<code>我是test1函数哦。。。。</code>，反而到了第12行再次调用<code>test1</code>函数时变成了<code>我是test2函数哦。。。。</code></p>
<p>上述问题的原因核心点是：==在Python中即使是函数名也是一个变量名，只不过这个变量没有指向普通的数据，而是指向了一段代码==；也就是说如果定义了一个函数名字叫做<code>test1</code>就好比是一个变量名<code>test1</code>指向了那个代码块而已，所以当上述代码第11行<code>test1 = test2</code>时，就相当于让<code>test1</code>变量不在指向原本的代码块，而是指向新的代码块即<code>test2</code>指向的代码块，所以当第12行执行<code>test1</code>函数时，会输出<code>我是test2函数哦。。。。</code></p>
<h4 id="引用的作用">引用的作用</h4>
<p>看完上述的引入知识后，相信你会对什么是函数的引入有一个大体的认知了</p>
<p>在此简单总结：所谓函数名当做引用，其实是指在Python中所有的函数名实际上是一个变量名，只不过这个变量名指向的不是常见的数据，而是一段代码，当我们用<code>函数名()</code>是实际上就是让指向的这块代码开始执行，当我们只用<code>函数名</code>时其实就是这个函数的引用</p>
<p>记住：既然函数名也是变量名，那么就可以给它赋值获取它的引用给别的变量</p>
<p>总结：</p>
<ol>
<li>使用<code>def</code>定义的函数名，实际就是个变量名它存储了函数的引用</li>
<li>如果将另外一个变量，例如<code>b</code>保存了函数的引用，即也指向了同一个函数，那么<code>b()</code>就是调用函数</li>
</ol>
<h2 id="2-7-Python文件操作">2.7 Python文件操作</h2>
<h3 id="1-文件的编码">1. 文件的编码</h3>
<p>编码技术即：<strong>翻译的规则</strong>，==记录了如何将内容翻译成二进制，以及如何将二进制翻译回可识别内容。==</p>
<p>计算机中有许多可用编码：</p>
<ul>
<li>UTF-8</li>
<li>GBK</li>
<li>Big5</li>
<li>等</li>
</ul>
<p><strong>不同的编码，将内容翻译成二进制也是不同的。</strong></p>
<h3 id="2-文件的读取">2. 文件的读取</h3>
<p>想想我们平常对文件的基本操作，大概可以分为三个步骤（简称文件操作三步走）：</p>
<p>① 打开文件</p>
<p>② 读写文件</p>
<p>③ 关闭文件</p>
<blockquote>
<p>注意：可以只打开和关闭文件，不进行任何读写</p>
</blockquote>
<p><strong>open()打开函数</strong></p>
<ul>
<li>
<p>open(name, mode, encoding)</p>
<ul>
<li>
<p>name：是要打开的目标文件名的字符串(可以包含文件所在的具体路径)。</p>
</li>
<li>
<p>mode：设置打开文件的模式(访问模式)：只读、写入、追加等。</p>
</li>
<li>
<p>encoding:编码格式（推荐使用UTF-8）</p>
</li>
</ul>
</li>
</ul>
<p>示例代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;python.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding =”UTF-<span class="number">8</span>)</span><br><span class="line"><span class="comment"># encoding 的顺序不是第三位，所以不能用位置参数，用关键字参数直接指定</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：此时的<code>f</code>是<code>open</code>函数的文件对象，对象是Python中一种特殊的数据类型，拥有属性和方法，可以使用对象.属性或对象.方法对其进行访问，后续面向对象课程会给大家进行详细的介绍。</p>
</blockquote>
<p><strong>mode常用的三种基础访问模式</strong></p>
<table>
<thead>
<tr>
<th><strong>模式</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>r</td>
<td>以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td>
</tr>
<tr>
<td>w</td>
<td>打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，<strong>原有内容会被删除</strong>。  如果该文件不存在，创建新文件。</td>
</tr>
<tr>
<td>a</td>
<td>打开一个文件用于追加。如果该文件已存在，新的内容将会被写入到已有内容之后。  如果该文件不存在，创建新文件进行写入。</td>
</tr>
</tbody>
</table>
<p><strong>mode常用的模式：</strong></p>
<ul>
<li>r：表示文件只能读取</li>
<li>w：表示文件只能写入</li>
<li>a：表示打开文件，在原有内容的基础上追加内容，在末尾写入</li>
<li>w+:表示可以对文件进行读写双重操作</li>
</ul>
<p><strong>mode二进制常用模式：</strong></p>
<ul>
<li>rb：以二进制格式打开一个文件，用于只读</li>
<li>wb：以二进制格式打开一个文件，用于只写</li>
<li>ab：以二进制格式打开一个文件，用于追加</li>
<li>wb+:以二进制格式打开一个文件，用于读写</li>
</ul>
<p>使用<code>open</code>函数时，明确指定读模式和什么模式都不指定的效果是一样的，我们在前面的示例中已经验证。</p>
<p>使用写模式可以向文件写入内容。<code>+</code>参数可以用到其他任何模式中，指明读和写都是允许的。比如<code>w+</code>可以在打开一个文件时用于文件的读写。</p>
<p>当参数带上字母<code>b</code>时，表示可以用来读取一个二进制文件。<code>Python</code>在一般情况下处理的都是<strong>文本文件</strong>，有时也不能避免处理其他格式的文件。</p>
<p><strong>读取操作相关方法</strong></p>
<p>read()方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件对象.read(num)</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>num表示要从文件中读取的数据的长度（单位是字节），如果没有传入num，那么就表示读取文件中所有的数据。</p>
</li>
<li>
<p><strong>readlines()方法：</strong></p>
<ul>
<li>
<p>readlines可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表，其中每一行的数据为一个元素。</p>
</li>
<li>
<pre><code class="language-python">f = open('python.txt')
content = f.readlines()

# ['hello world\n', 'abcdefg\n', 'aaa\n', 'bbb\n', 'ccc']
print(content)

# 关闭文件
f.close()

<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- <span class="built_in">readline</span>()方法：**一次读取一行内容**</span><br><span class="line"></span><br><span class="line">  - ``` python</span><br><span class="line">    f = open(&#x27;python.txt&#x27;)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">content</span> = f.<span class="built_in">readline</span>()</span><br><span class="line">    <span class="built_in">print</span>(f&#x27;第一行：&#123;<span class="built_in">content</span>&#125;&#x27;)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">content</span> = f.<span class="built_in">readline</span>()</span><br><span class="line">    <span class="built_in">print</span>(f&#x27;第二行：&#123;<span class="built_in">content</span>&#125;&#x27;)</span><br><span class="line">    </span><br><span class="line">    # 关闭文件</span><br><span class="line">    f.<span class="built_in">close</span>()</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p>for循环读取文件行</p>
<ul>
<li>
<pre><code class="language-python">for line in open(&quot;python.txt&quot;, &quot;r&quot;):
    print(line)

# 每一个 line 临时变量，就记录了文件的一行数据
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- <span class="keyword">close</span>() 关闭文件对象</span><br><span class="line"></span><br><span class="line">  - ``` <span class="keyword">python</span></span><br><span class="line">    <span class="keyword">f</span> = <span class="keyword">open</span>(<span class="string">&quot;python.txt&quot;</span>, <span class="string">&quot;r&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">f</span>.<span class="keyword">close</span>()</span><br><span class="line">    </span><br><span class="line">    # 最后通过 <span class="keyword">close</span>，关闭文件对象，也就是关闭对文件的占用</span><br><span class="line">    # 如果不调用 <span class="keyword">close</span>, 同时程序没有停止运行，那么这个文件将一直被 Python 程序占用。</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>with open 语法</strong></p>
</li>
<li>
<pre><code class="language-python">with open(&quot;python.txt&quot;, &quot;r&quot;) as f:
    f.readlines()

# 通过在 with open 的语句块中对文件进行操作
# 可以在操作完成后自动关闭 close 文件，避免遗忘掉 close 方法
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="symbol">*</span><span class="symbol">*</span>操作汇总<span class="symbol">*</span><span class="symbol">*</span></span><br><span class="line"></span><br><span class="line">|<span class="string"> 操作                                   </span>|<span class="string"> 功能                                     </span>|</span><br><span class="line">|<span class="string"> -------------------------------------- </span>|<span class="string"> ---------------------------------------- </span>|</span><br><span class="line">|<span class="string"> 文件对象  = open(file, mode, encoding) </span>|<span class="string"> 打开文件获得文件对象                     </span>|</span><br><span class="line">|<span class="string"> 文件对象.read(num)                     </span>|<span class="string"> 读取指定长度字节  不指定num读取文件全部  </span>|</span><br><span class="line">|<span class="string"> 文件对象.readline()                    </span>|<span class="string"> 读取一行                                 </span>|</span><br><span class="line">|<span class="string"> 文件对象.readlines()                   </span>|<span class="string"> 读取全部行，得到列表                     </span>|</span><br><span class="line">|<span class="string"> for line in 文件对象                   </span>|<span class="string"> for循环文件行，一次循环得到一行数据      </span>|</span><br><span class="line">|<span class="string"> 文件对象.close()                       </span>|<span class="string"> 关闭文件对象                             </span>|</span><br><span class="line">|<span class="string"> with open() as f                       </span>|<span class="string"> 通过with  open语法打开文件，可以自动关闭 </span>|</span><br><span class="line"></span><br><span class="line"><span class="comment">### 3. 文件的写入</span></span><br><span class="line"></span><br><span class="line">``` python</span><br><span class="line"><span class="comment"># 1. 打开文件</span></span><br><span class="line">f = open(&#x27;python.txt&#x27;, &#x27;w&#x27;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.文件写入</span></span><br><span class="line">f.write(&#x27;hello world&#x27;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 内容刷新</span></span><br><span class="line">f.flush()</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<blockquote>
<p>注意：</p>
<ul>
<li>
<p>直接调用write，内容并未真正写入文件，而是会积攒在程序的内存中，称之为缓冲区</p>
</li>
<li>
<p>当调用flush的时候，内容会真正写入文件</p>
</li>
<li>
<p>这样做是避免频繁的操作硬盘，导致效率下降（攒一堆，一次性写磁盘）</p>
</li>
</ul>
</blockquote>
<ul>
<li>文件如果不存在，使用”w”模式，<strong>会创建新文件</strong></li>
<li>文件如果存在，使用”w”模式，<strong>会将原有内容清空</strong></li>
</ul>
<h3 id="4-文件的追加">4. 文件的追加</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 打开文件，通过 a 模式打开即可</span></span><br><span class="line">f = <span class="built_in">open</span>(<span class="string">&#x27;python.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.文件写入</span></span><br><span class="line">f.write(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 内容刷新</span></span><br><span class="line">f.flush()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ul>
<li>a模式，文件不存在会创建文件</li>
<li>a模式，文件存在会在最后，<strong>追加写入文件</strong></li>
<li>可以使用”\n”来写出换行符</li>
</ul>
</blockquote>
<h2 id="2-8-Python异常、模块与包">2.8 Python异常、模块与包</h2>
<h3 id="1-异常的捕获方法">1. 异常的捕获方法</h3>
<blockquote>
<p><strong>为什么需要捕获异常</strong></p>
<p>当我们的程序遇到了BUG, 那么接下来有两种情况:</p>
<p>​    ① 整个程序因为一个BUG停止运行</p>
<p>​    ② <strong>对BUG进行提醒, 整个程序继续运行</strong></p>
<p>显然在之前的学习中, 我们所有的程序遇到BUG就会出现①的这种情况, 也就是整个程序直接奔溃.</p>
<p>但是在真实工作中, 我们肯定不能因为一个小的BUG就让整个程序全部奔溃, 也就是我们希望的是达到② 的这种情况</p>
<p>那这里我们就需要使用到<strong>捕获异常</strong></p>
<p><strong>捕获异常的作用在于：提前假设某处会出现异常，做好提前准备，当真的出现异常的时候，可以有后续手段。</strong></p>
</blockquote>
<p>基本语法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    可能发生错误的代码</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    如果出现异常执行的代码</span><br></pre></td></tr></table></figure>
<p><strong>捕获指定异常</strong></p>
<p>基本语法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;name 变量名称未定义错误&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>① 如果尝试执行的代码的异常类型和要捕获的异常类型不一致，则无法捕获异常。</p>
<p>② 一般try下方只放一行尝试执行的代码。</p>
<p><strong>捕获多个异常</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"><span class="keyword">except</span> (NameError, ZeroDivisionError):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ZeroDivision 错误...&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>捕获所有异常</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure>
<p><strong>异常else</strong></p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">try</span></span>:</span><br><span class="line">    <span class="function"><span class="title">print</span>(<span class="number">1</span>)</span></span><br><span class="line"><span class="variable"><span class="keyword">except</span></span> <span class="variable">Exception</span> <span class="variable">as</span> <span class="variable">e</span>:</span><br><span class="line">    <span class="function"><span class="title">print</span>(<span class="variable">e</span>)</span></span><br><span class="line"><span class="variable"><span class="keyword">else</span></span>:</span><br><span class="line">    <span class="function"><span class="title">print</span>(<span class="string">&#x27;我是 else，是没有异常的时候执行的代码&#x27;</span>)</span></span><br></pre></td></tr></table></figure>
<p><strong>自定义异常</strong></p>
<p>尽管内建异常类包括大部分异常，而且可满足很多要求，但有时还是要创建自己的异常类。比如需要精确知道问题的根源，就需要使用自定义异常精确定位问题。可以通过创建一个新<code>exception</code>类拥有自己的异常。异常应该继承自<code>Exception</code>类，可以直接继承，也可以间接继承。</p>
<p>因为错误就是类，捕获一个错误就是捕获该类的一个实例，因此错误并不是凭空产生的，而是由一些不合理的部分导致的。<code>Python</code>的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。如果要抛出错误，那么可以根据需要定义一个错误的类，选择好继承关系，然后用<code>raise</code>语句抛出一个错误的实例。</p>
<p>例如（my_error.py）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyError</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;this is self define error&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_error_test</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">raise</span> MyError()</span><br><span class="line">    <span class="keyword">except</span> MyError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;exception info: &#x27;</span>, e)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_error_test()</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exception info:  this is self define error</span><br></pre></td></tr></table></figure>
<p>由程序和执行结果看到，程序正确执行了自定义的异常，并且需要继承<code>Exception</code>类。</p>
<p>这只是一个简单的示例，还有不少细节需要琢磨，此处不做深入探讨，有兴趣的同学可以查阅相关资料进行实践。</p>
<p>**提示：**异常最好以<code>Error</code>结尾，一方面贴近标准异常的命名，另一方面便于见名知意。</p>
<p><strong>异常的finally</strong></p>
<p>finally表示的是无论是否异常都要执行的代码，例如关闭文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;test.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;没有异常，真开心&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>
<h3 id="2-异常的传递">2. 异常的传递</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ed74a713.png" alt="image-20230216144219305" style="zoom:50%;" />
<p>利用异常具有传递性的特点, 当我们想要保证程序不会因为异常崩溃的时候,</p>
<p>就可以在main函数中设置异常捕获, 由于无论在整个程序哪里发生异常, 最终都</p>
<p>会传递到main函数中, 这样就可以确保所有的异常都会被捕获</p>
<h3 id="3-Python模块">3. Python模块</h3>
<h4 id="1-模块的导入">1. 模块的导入</h4>
<ul>
<li>
<p><strong>什么是模块</strong></p>
<ul>
<li>Python 模块(Module)，是一个 Python 文件，以 .py 结尾. 模块能定义函数，类和变量，模块里也能包含可执行的代码.</li>
</ul>
</li>
<li>
<p><strong>模块的作用</strong></p>
<ul>
<li>
<p>python中有很多各种不同的模块, 每一个模块都可以帮助我</p>
<p>们快速的实现一些功能, 比如实现和时间相关的功能就可以使用time模块</p>
</li>
<li>
<p>我们可以认为一个模块就是一个工具包, 每一个工具包中都有各种不同的</p>
<p>工具供我们使用进而实现各种不同的功能.</p>
</li>
</ul>
<blockquote>
<p>大白话：模块就是一个Python文件，里面有类、函数、变量等，我们可以</p>
<p>拿过来用（导入模块去使用）</p>
</blockquote>
</li>
<li>
<p><strong>模块的导入方式</strong></p>
</li>
<li>
<p>模块在使用前需要先导入 导入的语法如下:</p>
<ul>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ed7f3e62.png" alt="image-20230216144532711" style="zoom:67%;" />
</li>
</ul>
</li>
<li>
<p><strong>常用的组合形式</strong>：</p>
<ul>
<li>import 模块名</li>
<li>from 模块名 import 类、变量、方法等</li>
<li>from 模块名 import *</li>
<li>import 模块名 as 别名</li>
<li>from 模块名 import 功能名 as 别名</li>
</ul>
</li>
</ul>
<h4 id="2-自定义模块">2. <strong>自定义模块</strong></h4>
<p>Python中已经帮我们实现了很多的模块. 不过有时候我们需要一些个性化的模块, 这里就可以通过自定义模块实现, 也就是自己制作一个模块</p>
<ul>
<li>
<p><strong>案例</strong>：新建一个Python文件，命名为my_module1.py，并定义test函数</p>
<ul>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/czzczzczz/image@main/202302161448829.png" alt="image-20230216144854770" style="zoom:50%;" /><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ed8a70f6.png" alt="image-20230216144901673" style="zoom:50%;" /></li>
</ul>
</li>
<li>
<p><strong>注意</strong></p>
<p>每个Python文件都可以作为一个模块，模块的名字就是文件的名字. 也就是说<strong>自定义模块名必须要符合标识符命名规则</strong></p>
</li>
</ul>
<p><strong>测试模块</strong></p>
<ul>
<li>
<p>在实际开发中，当一个开发人员编写完一个模块后，为了让模块能够在项目中达到想要的效果，</p>
<p>这个开发人员会自行在py文件中添加一些测试信息，例如，在my_module1.py文件中添加测试代码test(1,1)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b)</span><br><span class="line">test(<span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>问题</strong></p>
<p>此时，无论是当前文件，还是其他已经导入了该模块的文件，在运行的时候都会自动执行<code>test</code>函数的调用</p>
</li>
<li>
<p><strong>解决方案：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a + b)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只在当前文件中调用该函数，其他导入的文件内不符合该条件，则不执行 test 函数调用</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    test (<span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意事项：当导入多个模块的时候，且模块内有同名功能. 当调用这个同名功能的时候，调用到的是后面导入的模块的功能</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ed97ca9b.png" alt="image-20230216145240839" style="zoom:33%;" />
</blockquote>
</li>
</ul>
<p><strong>__all__</strong></p>
<p>如果一个模块文件中有<code>__all__</code>变量，当使用<code>from xxx import *</code>导入时，只能导入这个列表中的元素</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eda59139.png" alt="image-20230216145426170" style="zoom:50%;" />
<h4 id="3-Python包">3. Python包</h4>
<h4 id="自定义包"><strong>自定义包</strong></h4>
<blockquote>
<p>基于Python模块，我们可以在编写代码的时候，导入许多外部代码来丰富功能。</p>
<p>但是，如果Python的模块太多了，就可能造成一定的混乱，那么如何管理呢？</p>
<p>通过Python包的功能来管理。</p>
</blockquote>
<ul>
<li>
<p><strong>什么是Python包</strong></p>
</li>
<li>
<p>从物理上看，包就是一个文件夹，在该文件夹下包含了一个 <strong>init</strong>.py 文件，该文件夹可用于包含多个模块文件</p>
</li>
<li>
<p>从逻辑上看，包的本质依然是模块</p>
</li>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398edb10f9e.png" alt="image-20230216145640826" style="zoom:50%;" />
</li>
<li>
<p><strong>包的作用</strong></p>
<p>当我们的模块文件越来越多时,包可以帮助我们<strong>管理这些模块</strong>, 包的作用就是包含多个模块，但<strong>包的本质依然是模块</strong></p>
</li>
</ul>
<p><strong>快速入门</strong></p>
<p><strong>步骤如下</strong></p>
<p>① 新建包<code>my_package</code></p>
<p>② 新建包内模块：<code>my_module1</code> 和 <code>my_module2</code></p>
<p>③ 模块内代码如下</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398edbd2e81.png" alt="image-20230216145801148" style="zoom:80%;" />
<blockquote>
<p>注意：新建包后，包内部会自动创建<code>__init__.py</code>文件，这个文件控制着包的导入行为</p>
</blockquote>
<p><strong>导入包</strong></p>
<ul>
<li>
<p>方式一：</p>
</li>
<li>
<pre><code class="language-python">import 包名.模块名

包名.模块名.目标
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &lt;img src=<span class="string">&quot;https://bu.dusays.com/2023/04/15/64398edced382.png&quot;</span> alt=<span class="string">&quot;image-20230216150041019&quot;</span> style=<span class="string">&quot;zoom:33%;&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">- 方式二：</span><br><span class="line"></span><br><span class="line">  注意：必须在`__init__.py`文件中添加`__all__ = []`，控制允许导入的模块列表</span><br><span class="line"></span><br><span class="line">- ``` python</span><br><span class="line">  from 包名 import *</span><br><span class="line">  模块名.目标</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eddc6d87.png" alt="image-20230216150158513" style="zoom:50%;" />
</li>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398edeafecc.png" alt="image-20230216150213691" style="zoom:50%;" />
</li>
<li>
<p>my_module1报红证明不可用</p>
<blockquote>
<p><strong>注意</strong></p>
<p>__all__针对的是 ’ from … import * ‘ 这种方式</p>
<p>对 ‘ import xxx ’ 这种方式无效</p>
</blockquote>
</li>
</ul>
<h4 id="安装第三方包"><strong>安装第三方包</strong></h4>
<p><strong>什么是第三方包</strong></p>
<p>我们知道，包可以包含一堆的Python模块，而每个模块又内含许多的功能。</p>
<p>所以，我们可以认为：一个包，就是一堆同类型功能的集合体。</p>
<p>在Python程序的生态中，有许多非常多的第三方包（非Python官方），可以极大的帮助我们提高开发效率，如：</p>
<ul>
<li>科学计算中常用的：numpy包</li>
<li>数据分析中常用的：pandas包</li>
<li>大数据计算中常用的：pyspark、apache-flink包</li>
<li>图形可视化常用的：matplotlib、pyecharts</li>
<li>人工智能常用的：tensorflow</li>
<li>等</li>
</ul>
<p>这些第三方的包，极大的丰富了Python的生态，提高了开发效率。</p>
<p>但是由于是第三方，所以Python没有内置，所以我们需要安装它们才可以导入使用哦。</p>
<p><strong>安装第三方包</strong> <strong>- pip</strong></p>
<p>第三方包的安装非常简单，我们只需要使用Python内置的pip程序即可。</p>
<p>打开我们许久未见的：命令提示符程序，在里面输入：</p>
<p>pip install 包名称</p>
<p>即可通过网络快速安装第三方包</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398edf74c72.png" alt="image-20230216150521146" style="zoom:67%;" />
<p><strong>pip的网络优化</strong></p>
<p>由于pip是连接的国外的网站进行包的下载，所以有的时候会速度很慢。</p>
<p>我们可以通过如下命令，让其连接国内的网站进行包的安装：</p>
<p>pip install -i <a target="_blank" rel="noopener" href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> 包名称</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ee045876.png" alt="image-20230216150605965" style="zoom:67%;" />
<p><a target="_blank" rel="noopener" href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> 是清华大学提供的一个网站，可供pip程序下载第三方包</p>
<h2 id="2-9-面向对象">2.9 面向对象</h2>
<h3 id="1-初识对象">1. 初识对象</h3>
<ol>
<li>
<p>生活中或是程序中，我们都可以使用设计表格、生产表格、填写表格的形式组织数据</p>
</li>
<li>
<p>进行对比，在程序中：</p>
<ol>
<li>设计表格，称之为：设计类（class）</li>
<li>打印表格，称之为：创建对象</li>
<li>填写表格，称之为：对象属性赋值</li>
</ol>
</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ee114c1e.png" alt="image-20230216151114139" style="zoom:67%;" />
<h3 id="2-成员方法">2. 成员方法</h3>
<ul>
<li>
<p><strong>类的定义和使用</strong>（冒+空）</p>
</li>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ee1b0629.png" alt="image-20230216151227366" style="zoom:50%;" />
- class是关键字，表示要定义类了
- 类的属性，即定义在类中的变量（成员变量）
- 类的行为，即定义在类中的函数（成员方法）
</li>
<li>
<p>创建类对象的语法：</p>
<ul>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ee25c80b.png" alt="image-20230216151316195" style="zoom:50%;" />
</li>
</ul>
</li>
</ul>
<p><strong>成员变量和成员方法</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ee326bf4.png" alt="image-20230216151456934" style="zoom:50%;" />
<ul>
<li>
<p>可以看出，类中：</p>
<ul>
<li>不仅可以定义属性用来记录数据</li>
<li>也可以定义函数，用来记录行为</li>
</ul>
<p>其中：</p>
<p>类中定义的属性（变量），我们称之为：成员变量</p>
<p>类中定义的行为（函数），我们称之为：成员方法</p>
</li>
</ul>
<p><strong>成员方法的定义语法</strong></p>
<ul>
<li>在类中定义成员方法和定义函数基本一致，但仍有细微区别：</li>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ee3e72d6.png" alt="image-20230216151638727" style="zoom:50%;" />
</li>
<li>可以看到，在方法定义的参数列表中，有一个：==self关键字==
<ul>
<li>self关键字是成员方法定义的时候，必须填写的。</li>
<li>它用来表示==类对象自身==的意思</li>
<li>当我们使用类对象调用方法的是，self会自动被python传入</li>
</ul>
</li>
<li>在方法内部，想要访问类的成员变量，必须使用self</li>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ee4a3d4b.png" alt="image-20230216151712895" style="zoom:50%;" />
</li>
</ul>
<blockquote>
<p><strong>注意事项</strong></p>
<p>self关键字，尽管在参数列表中，但是传参的时候可以忽略它。</p>
</blockquote>
<h3 id="3-类和对象">3. 类和对象</h3>
<p><strong>现实世界的事物和类</strong></p>
<ul>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ee54c38b.png" alt="image-20230216151914043" style="zoom:50%;" />
</li>
<li>现实世界的事物也有属性和行为，类也有属性和行为。</li>
<li>使用程序中的类，可以完美的描述现实世界的事物</li>
</ul>
<p><strong>类和对象</strong></p>
<p>基于类创建对象的语法:<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ee609cdd.png" alt="image-20230216152224650" style="zoom:67%;" /></p>
<ul>
<li>
<p>为什么非要创建对象才能使用呢？</p>
</li>
<li>
<p><strong>类只是一种程序内的设计图纸</strong>，需要基于图纸生产实体（对象），才能正常工作</p>
</li>
<li>
<p><strong>这种套路，称之为：面向对象编程</strong></p>
</li>
</ul>
<blockquote>
<p>感悟：万物皆是对象。所谓对象其实就是把有相同特征的个体抽象成同一个对象类型，它们有着相同的属性或者方法，而这里所谓的个体其实也是下一级的对象，这样分类有利于对万物进行操作。例如，’生命‘是一个对象，它有自己的特征（代谢，繁殖等），这些构成的相应的属性或者方法，它包含许多的下级，如人类，猫，狗等，而人类也是一个对象，包含自己的属性和方法，人类又可以分为男女，分别有自己的特征，也就是对应的属性和方法，最终分到每一个人，还是一个对象，有自己的特征，而这样分类是为了便于操作，例如我想要所有人类醒来，那我就喊一句’人都醒过来’（代码是 people.wake_up)就可以，而不用去把每一个人的名字都叫一遍，或者没有现成的对象，你可以根据你的需求的属性和方法自己定义一个对象（类），例如我定义‘三只脚两个鼻子的生命叫做qqq’，那么我就可以对对象qqq操作，如qqq.代谢（继承的生命类的方法）。也可以反过来看，如果我们事先不了解一个变量x它是什么，但是我们得知了它是什么对象（type），那么它一定具有该类对象所共有的属性和方法（就像一个黑盒里装的是什么我不知道，但是我知道了它是生命，不是石头啥的，那么他一定可以代谢繁殖等）。——2024，11，28</p>
</blockquote>
<h3 id="4-构造方法">4. 构造方法</h3>
<p><strong>属性（成员变量）的赋值</strong></p>
<ul>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ee6c48e6.png" alt="image-20230216152442226" style="zoom:33%;" />
</li>
<li>
<p>上侧代码中，为对象的属性赋值需要依次进行，略显繁琐。</p>
<p>有没有更加高效的方式，能够一行代码就完成呢？</p>
<p>思考：<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ee77f61c.png" alt="image-20230216152616931" style="zoom:67%;" /></p>
<p>这个括号，能否像函数（方法）那样，通过传参的形式对属性赋值呢？</p>
<p><strong>可以，需要使用构造方法：__init__()</strong></p>
</li>
</ul>
<p><strong>Python类可以使用：init()方法，称之为构造方法。</strong></p>
<p>可以实现：</p>
<ul>
<li>在创建类对象（构造类）的时候，会自动执行。</li>
<li>在创建类对象（构造类）的时候，将传入参数自动传递给__init__方法使用。</li>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ee8525cc.png" alt="image-20230216152725229" style="zoom:50%;" />
</li>
</ul>
<blockquote>
<p>构建类时传入的参数会自动提供给__init__方法</p>
<p>构建类的时候__init__方法会自动执行</p>
</blockquote>
<p><strong>构造方法注意事项</strong></p>
<ul>
<li>重要的事情说三遍，构造方法名称：__init__， 千万不要忘记<strong>前后都有2个下划线</strong></li>
<li>构造方法也是成员方法，不要忘记在参数列表中提供：<strong>self</strong></li>
<li>在构造方法内定义成员变量，需要使用<strong>self</strong>关键字
<ul>
<li>​</li>
<li>这是因为：变量是定义在构造方法内部，如果要成为成员变量，需要用self来表示。</li>
</ul>
</li>
</ul>
<h4 id="对象关联">对象关联</h4>
<p><strong>引入</strong></p>
<p>大家知道，我们在上学的时候，每个同学是一个对象，那么教室也是一个对象对吗？每个同学肯定是属于某一个教室的对吧，例如张三是205班的；那么怎样才能用代码来实现他们之间的关系呢</p>
<p>如下代码，创建了1个教室对象，1个学生对象，该怎样将它们2个联系起来呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Classroom</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.classroom_name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.student_name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个教室对象</span></span><br><span class="line">class205 = Classroom(<span class="string">&quot;205 班&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个学生对象</span></span><br><span class="line">stu01 = Student(<span class="string">&quot;学生 1&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="将两个对象进行关联">将两个对象进行关联</h4>
<p>在上述的代码中，我们发现如果当前的教室对象与学生对象是没有任何关系关联的，如果想要实现学生属于教室，那么只需要2步就能实现</p>
<ol>
<li>搞清楚<code>谁属于谁</code>，例如上述示例中，学生属于教室</li>
<li>在范围大的那个对象中，定义一个属性存储范围小的对象引用即可</li>
</ol>
<p>示例一：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Classroom</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.classroom_name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.student_name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个教室对象</span></span><br><span class="line">class205 = Classroom(<span class="string">&quot;205 班&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个学生对象</span></span><br><span class="line">stu01 = Student(<span class="string">&quot;学生 1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接给教室对象添加属性</span></span><br><span class="line">class205.stu = stu01</span><br></pre></td></tr></table></figure>
<h4 id="调用关联的对象">调用关联的对象</h4>
<p>上述代码已经完成了对象学生与教室的关联，那么怎样调用呢？格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果 A 对象中的某个属性指向了 B 对象，那么调用方式</span></span><br><span class="line">A.xxx  <span class="comment"># 此时就是指的 B 对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想要调用 B 对象中的某方法，那么就再接着.yyy 方法即可</span></span><br><span class="line">A.xxx.yyy()</span><br></pre></td></tr></table></figure>
<p>代码示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Classroom</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.classroom_name = name</span><br><span class="line">        <span class="variable language_">self</span>.stu = <span class="literal">None</span>  <span class="comment"># 一般情况下在本类的其它方法中用到的实例属性，都要在 __init__ 方法中定义</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_new_stu</span>(<span class="params">self, stu</span>):</span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot;定义新方法用来完成关联&quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.stu = stu</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.student_name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个教室对象</span></span><br><span class="line">class205 = Classroom(<span class="string">&quot;205 班&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个学生对象</span></span><br><span class="line">stu01 = Student(<span class="string">&quot;学生 1&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用方法将学生添加到对象中</span></span><br><span class="line">class205.add_new_stu(stu01)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用学生的姓名</span></span><br><span class="line"><span class="comment"># 205 教室.学生.姓名</span></span><br><span class="line"><span class="built_in">print</span>(class205.stu.student_name)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">学生 1</span><br></pre></td></tr></table></figure>
<h4 id="关联多个对象">关联多个对象</h4>
<p>既然关联1个对象搞懂了，那么关联多个也就手到擒来，方式如下：</p>
<ol>
<li>在范围大的那个对象中再定义一个新的属性，通过设置属性指向新的对象</li>
<li>如果关联的新的对象与之前关联的对象类型相同，可以考虑用列表、字典、集合等方式将它们关联</li>
</ol>
<p>实现将多个学生关联到一个教室：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Classroom</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.classroom_name = name</span><br><span class="line">        <span class="variable language_">self</span>.stus = []  <span class="comment"># 一般情况下在本类的其它方法中用到的实例属性，都要在 __init__ 方法中定义</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_new_stu</span>(<span class="params">self, stu</span>):</span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot;定义新方法用来完成关联&quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment"># self.stu = stu</span></span><br><span class="line">        <span class="variable language_">self</span>.stus.append(stu)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.student_name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个教室对象</span></span><br><span class="line">class205 = Classroom(<span class="string">&quot;205 班&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建多个学生对象</span></span><br><span class="line">stu01 = Student(<span class="string">&quot;学生 1&quot;</span>)</span><br><span class="line">stu02 = Student(<span class="string">&quot;学生 2&quot;</span>)</span><br><span class="line">stu03 = Student(<span class="string">&quot;学生 3&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用方法将学生添加到对象中</span></span><br><span class="line">class205.add_new_stu(stu01)</span><br><span class="line">class205.add_new_stu(stu02)</span><br><span class="line">class205.add_new_stu(stu03)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用学生的姓名</span></span><br><span class="line"><span class="comment"># 205 教室.列表 [下标].姓名</span></span><br><span class="line"><span class="built_in">print</span>(class205.stus [<span class="number">0</span>].student_name)</span><br><span class="line"><span class="built_in">print</span>(class205.stus [<span class="number">1</span>].student_name)</span><br><span class="line"><span class="built_in">print</span>(class205.stus [<span class="number">2</span>].student_name)</span><br></pre></td></tr></table></figure>
<h3 id="5-其它内置方法">5. 其它内置方法</h3>
<p><strong>魔术方法</strong></p>
<p>上文学习的__init__ 构造方法，是Python类内置的方法之一。</p>
<p>这些内置的类方法，各自有各自特殊的功能，这些内置方法我们称之为：魔术方法</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ee9d6c5b.png" alt="image-20230216153143072" style="zoom: 67%;" />
<h4 id="1-str-字符串方法">1. <strong><strong>str</strong></strong> <strong>字符串方法</strong></h4>
<ul>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eeaa2ad2.png" alt="image-20230216153332072" style="zoom:50%;" />
</li>
<li>当类对象<strong>需要被转换为字符串之时</strong>，会输出如上结果（内存地址）</li>
<li>内存地址没有多大作用，我们可以通过__str__方法，控制类转换为字符串的行为。</li>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eeb84711.png" alt="image-20230216153416258" style="zoom:50%;" />
- **方法名：\_\_str\_\_**
- **返回值：字符串**
- **内容：自行定义**
</li>
</ul>
<h4 id="2-lt-小于符号比较方法">2. <strong>__lt__ 小于符号比较方法</strong></h4>
<ul>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eec545d9.png" alt="image-20230216153845478" style="zoom:50%;" />
</li>
<li>
<p><strong>方法名：__lt__</strong></p>
</li>
<li>
<p>传入参数：other，另一个类对象</p>
</li>
<li>
<p>返回值：True或False</p>
</li>
<li>
<p>内容：自行定义</p>
</li>
</ul>
<blockquote>
<p>比较大于符号的魔术方法是：__gt__</p>
<p><strong>不过，实现了__lt__，__gt__就没必要实现了</strong></p>
</blockquote>
<h4 id="3-le-小于等于比较符号方法">3. <strong>__le__ 小于等于比较符号方法</strong></h4>
<ul>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eed2f562.png" alt="image-20230216154250564" style="zoom:50%;" />
</li>
<li>
<p><strong>方法名：__le__</strong></p>
</li>
<li>
<p>传入参数：other，另一个类对象</p>
</li>
<li>
<p>返回值：True或False</p>
</li>
<li>
<p>内容：自行定义</p>
</li>
</ul>
<blockquote>
<p>比较大于符号的魔术方法是：__ge__</p>
<p><strong>不过，实现了__le__，__ge__就没必要实现了</strong></p>
</blockquote>
<h4 id="4-eq-比较运算符方法">4. <strong>__eq__ 比较运算符方法</strong></h4>
<ul>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eee04b0d.png" alt="image-20230216154500616" style="zoom:50%;" />
</li>
<li>
<p><strong>方法名：__eq__</strong></p>
</li>
<li>
<p>传入参数：other，另一个类对象</p>
</li>
<li>
<p>返回值：True或False</p>
</li>
<li>
<p>内容：自行定义</p>
</li>
<li>
<blockquote>
<p>不实现__eq__方法，对象之间可以比较，但是是比较内存地址，也即是：不同对象==比较一定是False结果。</p>
<p>实现了__eq__方法，就可以按照自己的想法来决定2个对象是否相等了。</p>
</blockquote>
</li>
</ul>
<h3 id="6-封装">6. 封装</h3>
<p>面向对象编程，是许多编程语言都支持的一种编程思想。</p>
<p>简单理解是：<strong>基于模板（类）去创建实体（对象），==使用对象完成功能开发==。</strong></p>
<p>面向对象包含3大主要特性：</p>
<ul>
<li><strong>封装</strong></li>
<li><strong>继承</strong></li>
<li><strong>多态</strong></li>
</ul>
<p>封装表示的是，将现实世界事物的：</p>
<ul>
<li>
<p>属性</p>
</li>
<li>
<p>行为</p>
</li>
</ul>
<p>封装到类中，描述为：</p>
<ul>
<li>成员变量</li>
<li>成员方法</li>
</ul>
<p>从而完成程序对现实世界事物的描述</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eeec027b.png" alt="image-20230216154755397" style="zoom:67%;" />
<p><strong>私有成员</strong></p>
<ul>
<li>
<p>既然现实事物有不公开的属性和行为，那么作为现实事物在程序中映射的类，也应该支持。</p>
</li>
<li>
<p>类中提供了私有成员的形式来支持。</p>
<ul>
<li>私有成员变量</li>
<li>私有成员方法</li>
</ul>
</li>
<li>
<p>定义私有成员的方式非常简单，只需要：</p>
<ul>
<li>私有成员变量：变量名以__开头（2个下划线）</li>
<li>私有成员方法：方法名以__开头（2个下划线)</li>
<li>即可完成私有成员的设置</li>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398eef94b57.png" alt="image-20230216155031468" style="zoom:50%;" />
</li>
</ul>
</li>
<li>
<p><strong>使用私有成员</strong></p>
</li>
<li>
<p>私有方法无法直接被类对象使用</p>
<ul>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ef063064.png" alt="image-20230216155214959" style="zoom:67%;" />
</li>
</ul>
</li>
<li>
<p>私有变量无法赋值，也无法获取值</p>
<ul>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ef13a262.png" alt="image-20230216155238205" style="zoom:50%;" />
</li>
</ul>
</li>
<li>
<p>私有成员无法被类对象使用，但是可以被其它的成员使用。</p>
<ul>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ef209877.png" alt="image-20230216155315600" style="zoom:50%;" />
</li>
</ul>
</li>
</ul>
<blockquote>
<p>添加额外对属性操作的方法</p>
</blockquote>
<p>想要实现对私有属性的操作，我们需要定义方法，在方法中操作</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = <span class="string">&quot;顾安&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>.__age = <span class="number">18</span>  <span class="comment"># 这个属性就是私有属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_age</span>(<span class="params">self, new_age</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="number">1</span> &lt;= new_age &lt;= <span class="number">120</span>:</span><br><span class="line">            <span class="variable language_">self</span>.__age = new_age</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;设置年龄成功&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;年龄数据有误...&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = Teacher()</span><br><span class="line">t.set_age(<span class="number">20</span>)  <span class="comment"># 设置年龄</span></span><br><span class="line"><span class="built_in">print</span>(t.get_age())  <span class="comment"># 获取年龄</span></span><br></pre></td></tr></table></figure>
<h4 id="简单总结">简单总结</h4>
<p>1.操作属性有2种方法</p>
<ul>
<li>直接通过对象名修改</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.属性名 = 数据</span><br></pre></td></tr></table></figure>
<ul>
<li>通过方法间接修改</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象名.方法名(数据)</span><br></pre></td></tr></table></figure>
<p>2.<strong>通过使用方法来进行修改，就可以在方法中进行数据合法性的检查</strong></p>
<p>3.通过<code>__</code>可以将属性变为私有属性，这样就防止了通过对象直接操作属性时可能带来的隐患</p>
<h3 id="7-继承">7. 继承</h3>
<h4 id="1-继承的基础语法">1. 继承的基础语法</h4>
<p><strong>单继承</strong></p>
<ul>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ef2b3e50.png" alt="image-20230216155602042" style="zoom: 67%;" />
</li>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ef36dff1.png" alt="image-20230216155621406" style="zoom:67%;" />
</li>
<li>
<p>继承分为：单继承和多继承</p>
<p>使用如图语法，可以完成类的单继承。</p>
<p>继承表示：将从父类那里继承（复制）来成员变量和成员方法（不含私有）</p>
</li>
</ul>
<p><strong>多继承</strong></p>
<ul>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ef436938.png" alt="image-20230216155748863" style="zoom: 50%;" />
</li>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ef4ef987.png" alt="image-20230216155806207" style="zoom:50%;" />
</li>
<li>
<p><strong>多继承注意事项</strong></p>
<ul>
<li>
<p>多个父类中，如果有同名的成员，那么默认以继承顺序（从左到右）为优先级。</p>
<p>即：先继承的保留，后继承的被覆盖</p>
</li>
</ul>
</li>
<li>
<p><strong>pass关键字</strong></p>
<p>pass是占位语句，用来保证函数（方法）或类定义的完整性，表示无内容，空的意思</p>
</li>
</ul>
<h4 id="2-复写和使用父类成员">2. 复写和使用父类成员</h4>
<p><strong>复写</strong></p>
<ul>
<li>
<p>子类继承父类的成员属性和成员方法后，如果对其“不满意”，那么可以进行复写。</p>
<p>即：在子类中重新定义同名的属性或方法即可。</p>
</li>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ef5c1ec4.png" alt="image-20230216160043871" style="zoom:50%;" />
</li>
</ul>
<p><strong>调用父类同名成员</strong></p>
<ul>
<li>
<p>一旦复写父类成员，那么类对象调用成员的时候，就会调用复写后的新成员</p>
<p>如果需要使用被复写的父类的成员，需要特殊的调用方式:</p>
</li>
<li>
<p>方式1：</p>
<ul>
<li>
<p>调用父类成员</p>
<p>使用成员变量：父类名.成员变量</p>
<p>使用成员方法：父类名.成员方法(self)</p>
</li>
</ul>
</li>
<li>
<p>方式2：</p>
<ul>
<li>
<p>使用super()调用父类成员</p>
<p>使用成员变量：super().成员变量</p>
<p>使用成员方法：super().成员方法()</p>
</li>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ef6904c5.png" alt="image-20230216160312133" style="zoom: 67%;" />
</li>
<li>
<p><strong>只能在子类内调用父类的同名成员。</strong></p>
<p><strong>子类的类对象直接调用会调用子类复写的成员</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="8-类型注解">8. 类型注解</h3>
<h4 id="1-变量的类型注解">1. 变量的类型注解</h4>
<ol>
<li>什么是类型注解，有什么作用？</li>
</ol>
<p>​	在代码中涉及数据交互之时，对数据类型进行显式的说明，可以帮助：</p>
<p>​	PyCharm等开发工具对代码做类型推断协助做代码提示</p>
<p>​	开发者自身做类型的备注</p>
<ol start="2">
<li>类型注解支持：</li>
</ol>
<p>​	变量的类型注解</p>
<p>​	函数（方法）的形参和返回值的类型注解</p>
<ol start="3">
<li>变量的类型注解语法</li>
</ol>
<p>​	语法1： 变量: 类型</p>
<p>​	语法2： 在注释中，# type: 类型</p>
<ol start="4">
<li>注意事项</li>
</ol>
<p>​	类型注解只是提示性的，并非决定性的。数据类型和注解类型无法对应也不会导致错误</p>
<h4 id="2-函数（方法）的类型注解">2. 函数（方法）的类型注解</h4>
<ol>
<li>函数（方法）可以为哪里添加注解？</li>
</ol>
<p>​	形参的类型注解</p>
<p>​	返回值的类型注解</p>
<ol start="2">
<li>函数（方法）的类型注解语法？</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ef756cdc.png" alt="image-20230216163611390" style="zoom:50%;" />
<h4 id="3-Union类型">3. Union类型</h4>
<ol>
<li>什么是Union类型？</li>
</ol>
<p>​	使用Union可以定义联合类型注解</p>
<ol start="2">
<li>Union的使用方式</li>
</ol>
<p>​	导包：from typing import Union</p>
<p>​	使用：Union[类型, …, 类型]</p>
<h3 id="9-多态">9. 多态</h3>
<p>多态，指的是：多种状态，即完成某个行为时，使用不同的对象会得到不同的状态。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ef824cc3.png" alt="image-20230216163850121" style="zoom:67%;" />
<p><strong>多态常作用在继承关系上.</strong></p>
<p>比如</p>
<ul>
<li>函数(方法)形参声明接收父类对象</li>
<li>实际传入父类的子类对象进行工作</li>
</ul>
<p>即:</p>
<ul>
<li>以父类做定义声明</li>
<li>以子类做实际工作</li>
<li>用以获得同一行为, 不同状态</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ef8cbdbc.png" alt="image-20230216163926392" style="zoom:50%;" />
<h4 id="简单总结-2">简单总结</h4>
<p>想要实现多态，需要的条件如下：</p>
<ol>
<li><strong>有继承</strong></li>
<li><strong>有重写</strong></li>
</ol>
<p><strong>抽象类（接口）</strong></p>
<p>细心的同学可能发现了，父类Animal的speak方法，是空实现</p>
<p>这种设计的含义是：</p>
<ul>
<li>
<p>父类用来确定有哪些方法</p>
</li>
<li>
<p>具体的方法实现，由子类自行决定</p>
</li>
</ul>
<p>这种写法，就叫做抽象类（也可以称之为接口）</p>
<p>抽象类：<strong>含有抽象方法的类</strong>称之为抽象类</p>
<p>抽象方法：**方法体是空实现的（pass）**称之为抽象方法</p>
<ul>
<li>
<p>抽象类就好比定义一个标准，</p>
</li>
<li>
<p>包含了一些抽象的方法，要求子类必须实现。</p>
</li>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398ef99a1f4.png" alt="image-20230216164211668" style="zoom: 67%;" />
</li>
<li>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2023/04/15/64398efa85ff6.png" alt="image-20230216164232083" style="zoom:67%;" />
</li>
<li>
<p>配合多态，完成</p>
<ul>
<li>抽象的父类设计（设计标准）</li>
<li>具体的子类实现（实现标准）</li>
</ul>
</li>
</ul>
<h3 id="10-静态方法">10. 静态方法</h3>
<h4 id="引入-2">引入</h4>
<p>默认情况下，python类中定义的方法是实例方法，即这个方法有一个默认的形参<code>self</code>，这个<code>self</code>会在方法被调用的时候指向对象</p>
<p>但是有些时候，我们并不需要对象的引用，即<code>self</code>没用，那该怎么处理呢？能不写<code>self</code>吗？</p>
<p>答：可以</p>
<h4 id="静态方法的概念">静态方法的概念</h4>
<p>如果一个方法不写<code>self</code>即不需要实例对象的引用，此时在定义方法的时候可以用<code>@staticmethod</code>对函数进行修饰，被修饰的函数就可以不写<code>self</code></p>
<p>一句话：被<code>@staticmethod</code>修饰的方法，就是<code>静态方法</code></p>
<h4 id="代码示例">代码示例</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Calculator</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;</span> <span class="string">&quot;计算器类&quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 定义 2 个默认值</span></span><br><span class="line">        <span class="variable language_">self</span>.num1 = <span class="number">0</span></span><br><span class="line">        <span class="variable language_">self</span>.num2 = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_menu</span>():</span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot;因为打印菜单功能方法并不需要 self 指向的对象，所以就考虑使用静态方法&quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;    双双牌计算机 V2022.10&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;1. 加法&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;2. 减法&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;3. 乘法&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;4. 除法&quot;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;5. 退出&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_nums</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.num1 = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入第 1 个数:&quot;</span>))</span><br><span class="line">        <span class="variable language_">self</span>.num2 = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入第 2 个数:&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.num1 + <span class="variable language_">self</span>.num2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">min</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.num1 - <span class="variable language_">self</span>.num2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.num1 * <span class="variable language_">self</span>.num2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.num1 / <span class="variable language_">self</span>.num2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="variable language_">self</span>.show_menu()</span><br><span class="line">            op = <span class="built_in">input</span>(<span class="string">&quot;请输入要进行的操作:&quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> op == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">                <span class="variable language_">self</span>.get_nums()</span><br><span class="line">                <span class="variable language_">self</span>.add()</span><br><span class="line">            <span class="keyword">elif</span> op == <span class="string">&quot;2&quot;</span>:</span><br><span class="line">                <span class="variable language_">self</span>.get_nums()</span><br><span class="line">                <span class="variable language_">self</span>.<span class="built_in">min</span>()</span><br><span class="line">            <span class="keyword">elif</span> op == <span class="string">&quot;3&quot;</span>:</span><br><span class="line">                <span class="variable language_">self</span>.get_nums()</span><br><span class="line">                <span class="variable language_">self</span>.mul()</span><br><span class="line">            <span class="keyword">elif</span> op == <span class="string">&quot;4&quot;</span>:</span><br><span class="line">                <span class="variable language_">self</span>.get_nums()</span><br><span class="line">                <span class="variable language_">self</span>.div()</span><br><span class="line">            <span class="keyword">elif</span> op == <span class="string">&quot;5&quot;</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个计算器对象</span></span><br><span class="line">cal = Calculator()</span><br><span class="line"><span class="comment"># 调用计算器的运行方法</span></span><br><span class="line">cal.run()</span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    双双牌计算机 V2022.10</span><br><span class="line">1. 加法</span><br><span class="line">2. 减法</span><br><span class="line">3. 乘法</span><br><span class="line">4. 除法</span><br><span class="line">5. 退出</span><br><span class="line">请输入要进行的操作:</span><br></pre></td></tr></table></figure>
<h4 id="简单总结-3">简单总结</h4>
<p>如果不需要用到对象，那么就可以将方法用<code>@staticmethod</code>进行修饰，如此一来此方法就变成了静态方法。</p>
<blockquote>
<p>所谓的静态方法其实就是一个普通的函数 相对于实例方法来说没有调用权限的限制， 可以使用一个对象去调用静态方法，也可以类名.静态方法名() 就可以进行调用<br>
<strong>如果类中的方法无需访问类属性与实例属性的话 则可以使用静态方法</strong></p>
</blockquote>
<h3 id="11-类属性">11. 类属性</h3>
<h4 id="引入-3">引入</h4>
<p>默认情况下 ，当通过同一个类创建了多个实例对象之后，每个实例对象之间是相互隔离的</p>
<p>但是有时候有些数据需要在多个对象之间共享，此时该怎么办呢？</p>
<p>答：类属性</p>
<h4 id="类属性的概念">类属性的概念</h4>
<p>想要在多个对象之间共享数据，即一些属性需要在<code>多个对象</code>之间<code>共享</code>，这样的<code>属性</code>就是<code>类属性</code></p>
<p>那怎样定义类属性呢？格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>:</span><br><span class="line">    类属性 = ....</span><br></pre></td></tr></table></figure>
<p>即在<code>class</code>内且在<code>def</code>之外定义的变量，就叫做<code>类属性</code></p>
<h4 id="代码示例-2">代码示例</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    tools_num = <span class="number">0</span>  <span class="comment"># 定义一个类属性，用来存储共享的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        Tool.tools_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;工具的总数为：&quot;</span>, Tool.tools_num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_info2</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;工具的总数为：&quot;</span>, Tool.tools_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tieqiao = Tool(<span class="string">&quot;铁锹&quot;</span>)</span><br><span class="line">chutou = Tool(<span class="string">&quot;锄头&quot;</span>)</span><br><span class="line">dianciluo = Tool(<span class="string">&quot;电磁炉&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;工具的总数为：&quot;</span>, Tool.tools_num)  <span class="comment"># 可以直接通过 类名.类属性操作</span></span><br><span class="line">tieqiao.print_info()  <span class="comment"># 可以通过 Tool 创建的任意实例对象调用方法，在方法中获取</span></span><br><span class="line">Tool.print_info2()  <span class="comment"># 通过类名调用时，可以看到这个方法在 pycharm 中提示错误</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>类属性一般情况下是创建在类的方法之外的</li>
<li>除了静态方法之外的其它方法是可以访问类属性的</li>
<li>类属性在类中是共享的</li>
</ol>
</blockquote>
<h3 id="12-类方法">12. 类方法</h3>
<h4 id="引入-4">引入</h4>
<p>为了更好的对<code>类属性</code>进行操作，Python中提供了另外一种方法<code>类方法</code></p>
<h4 id="类方法的概念">类方法的概念</h4>
<p>之前在学习<code>静态方法</code>的时候我们知道可以在方法的名字前面添加<code>@staticmethod</code>此时这个方法就是静态方法，</p>
<p>与这种添加<code>@</code>的方式很类似，如果想要让一个方法成为<code>类方法</code>我们只需要在这个方法的前面添加<code>@classmethod</code>即可，与此同时需要在方法的第1个形参位置添加<code>cls</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>:</span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">类方法名</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h4 id="示例代码">示例代码</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tool</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    tools_num = <span class="number">0</span>  <span class="comment"># 定义一个类属性，用来存储共享的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        Tool.tools_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_info</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;工具的总数为：&quot;</span>, Tool.tools_num)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_info2</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;工具的总数为：&quot;</span>, cls.tools_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tieqiao = Tool(<span class="string">&quot;铁锹&quot;</span>)</span><br><span class="line">chutou = Tool(<span class="string">&quot;锄头&quot;</span>)</span><br><span class="line">dianciluo = Tool(<span class="string">&quot;电磁炉&quot;</span>)</span><br><span class="line"></span><br><span class="line">tieqiao.print_info()</span><br><span class="line">Tool.print_info2()</span><br><span class="line">tieqiao.print_info2()</span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">工具的总数为： 3</span><br><span class="line">工具的总数为： 3</span><br><span class="line">工具的总数为： 3</span><br></pre></td></tr></table></figure>
<h4 id="简单总结-4">简单总结</h4>
<ul>
<li>定义类方法时，前面添加<code>@classmethod</code></li>
<li>类方法的第1个形参，一般都叫做<code>cls</code>（当然了叫什么名字可以任意，但一般都用<code>cls</code>）</li>
<li>调用类方法的时候，可以用<code>实例对象</code>、<code>类对象</code>调用，但无论用哪种方式调用，类方法中的<code>cls</code>指向类对象</li>
</ul>
<h3 id="13-类对象">13. 类对象</h3>
<h4 id="引入-5">引入</h4>
<p>之前在学习类属性的时候，我们提到过：类属性是可以在多个实例对象之间共享的属性</p>
<p>那么问题来了，类属性到底存在哪里呢？</p>
<p>答：类对象</p>
<h4 id="类对象的概念">类对象的概念</h4>
<p>之前我们说到通过<code>class</code>定义的就是类（就是一个要创建的商品的模板），通过<code>类名()</code>创建出来的叫做<code>实例对象</code></p>
<p>其实，定义的类（即用<code>class</code>定义的类）实际上也是一个对象（试想即使我们把 类称之为模板，模板也不是空的啊，也是需要占用内存的对吗）</p>
<p>定义的类其实就是一个对象，为了能够将这个对象与其创建出来的实例对象进行区分，将这个class定义的类叫做<code>类对象</code></p>
<h4 id="类对象的作用">类对象的作用</h4>
<p>我们知道实例对象是类 （即类对象）创建出来的，所以类对象对于实例对象而言是共享的，既然是共享的那么就干脆将实例对象都有的而且不变化的内容存储到 类对象 即可，这样会减少内容的占用</p>
<p>那，哪些东西在类对象中存储呢？</p>
<ul>
<li>类属性</li>
<li>所有的方法</li>
</ul>
<p>对你没有看错，除了熟知的类属性之外，类对象中存储了<code>class</code>定义的所有的方法（无论是魔法方法、实例方法、静态方法 、类方法都在类对象中存储），因为方法(即函数)的代码是不变的，变化的仅仅是数据而已。</p>
<h4 id="实例对象怎么用类对象">实例对象怎么用类对象</h4>
<p>每个实例对象中都会有1个额外默认的属性<code>__class__</code>，这个属性指向了创建当前对象的模板即类对象，所以当调用<code>实例对象.xxx()</code>时，实际上<code>实例对象.__class__.xxx()</code></p>
<h4 id="dir-方法"><code>dir()</code> 方法</h4>
<p>既然我们知道了实例对象中有默认的<code>__class__</code>，那除了它之外还有哪些呢？怎么查看呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dir</span>(实例对象)</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;__weakref__&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>这么多的<code>__</code>开始的属性，用到什么我们就研究 什么，不用现在立刻研究。</p>
<blockquote>
<p>在没有创建实例方法之前我可以直接使用类对象调用静态方法与类方法<br>
那么也就是说，当前关于方法的代码不是存储在实例对象中的。</p>
<p>实例方法也是在类对象中的！！！</p>
</blockquote>
<p>注意区分类对象和实例对象</p>
<h3 id="简单总结-5">简单总结</h3>
<h4 id="类属性、实例属性">类属性、实例属性</h4>
<p>它们在定义和使用中有所区别，而最本质的区别是内存中保存的位置不同，</p>
<ul>
<li>
<p>实例属性属于对象</p>
</li>
<li>
<p>类属性属于类</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Province</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 类属性</span></span><br><span class="line">    country = <span class="string">&#x27;中国&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="comment"># 实例属性</span></span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个实例对象</span></span><br><span class="line">obj = Province(<span class="string">&#x27;山东省&#x27;</span>)</span><br><span class="line"><span class="comment"># 直接访问实例属性</span></span><br><span class="line"><span class="built_in">print</span>(obj.name)</span><br><span class="line"><span class="comment"># 直接访问类属性</span></span><br><span class="line">Province.country </span><br></pre></td></tr></table></figure>
<p>由上述代码可以看出【<strong>实例属性需要通过对象来访问</strong>】【<strong>类属性通过类访问</strong>】，在使用上可以看出实例属性和类属性的归属是不同的。</p>
<p>其在内容的存储方式类似如下图：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2024/04/09/661519bd0a211.png" alt="image-20240409183435717"></p>
<p>由上图看出：</p>
<ul>
<li>类属性在内存中只保存一份</li>
<li>实例属性在每个对象中都要保存一份</li>
</ul>
<p><strong>应用场景：</strong></p>
<blockquote>
<p>通过类创建实例对象时，如果每个对象需要具有相同名字的属性，那么就使用类属性，用一份既可</p>
</blockquote>
<h4 id="实例方法、静态方法和类方法">实例方法、静态方法和类方法</h4>
<p>方法包括：实例方法、静态方法和类方法，三种方法在内存中都归属于类，区别在于调用方式不同。</p>
<ul>
<li>实例方法：由对象调用；至少一个self参数；执行实例方法时，自动将调用该方法的对象赋值给self；</li>
<li>类方法：由类调用； 至少一个cls参数；执行类方法时，自动将调用该方法的类赋值给cls；</li>
<li>静态方法：由类调用；无默认参数；</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ord_func</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot; 定义实例方法，至少有一个 self 参数 &quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment"># print(self.name)</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;实例方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">class_func</span>(<span class="params">cls</span>):</span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot; 定义类方法，至少有一个 cls 参数 &quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;类方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">static_func</span>():</span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot; 定义静态方法 ，无默认参数&quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;静态方法&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f = Foo(<span class="string">&quot;中国&quot;</span>)</span><br><span class="line"><span class="comment"># 调用实例方法</span></span><br><span class="line">f.ord_func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用类方法</span></span><br><span class="line">Foo.class_func()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用静态方法</span></span><br><span class="line">Foo.static_func() </span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2024/04/09/66151a44b78d9.png" alt="image-20240409183651645" style="zoom:67%;" />
<p><strong>对比</strong></p>
<ul>
<li>相同点：对于所有的方法而言，均属于类，所以 在内存中也只保存一份</li>
<li>不同点：方法调用者不同、调用方法时自动传入的参数不同。</li>
</ul>
<blockquote>
<p>好像只有实例属性才保存在实例对象中,实例方法、类方法，类属性，静态方法都保存在类对象中</p>
</blockquote>
<h3 id="14-多继承以及MRO顺序">14. 多继承以及MRO顺序</h3>
<h4 id="多继承中调用父类方式不同结果不同">多继承中调用父类方式不同结果不同</h4>
<blockquote>
<p>单独调用父类的方法</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot; ******多继承使用类名.__init__发生的状态******&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;parent 的 init 开始被调用&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;parent 的 init 结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Son1 的 init 开始被调用&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">        Parent.__init__(<span class="variable language_">self</span>, name)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Son1 的 init 结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, gender</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Son2 的 init 开始被调用&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.gender = gender</span><br><span class="line">        Parent.__init__(<span class="variable language_">self</span>, name)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Son2 的 init 结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grandson</span>(Son1, Son2):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, gender</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Grandson 的 init 开始被调用&#x27;</span>)</span><br><span class="line">        Son1.__init__(<span class="variable language_">self</span>, name, age)  <span class="comment"># 单独调用父类的初始化方法</span></span><br><span class="line">        Son2.__init__(<span class="variable language_">self</span>, name, gender)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Grandson 的 init 结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gs = Grandson(<span class="string">&#x27;grandson&#x27;</span>, <span class="number">12</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;姓名：&#x27;</span>, gs.name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;年龄：&#x27;</span>, gs.age)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;性别：&#x27;</span>, gs.gender)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; ******多继承使用类名.__init__发生的状态******\n\n &quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">******多继承使用类名.__init__发生的状态******</span><br><span class="line">Grandson 的 init 开始被调用</span><br><span class="line">Son1 的 init 开始被调用</span><br><span class="line">parent 的 init 开始被调用</span><br><span class="line">parent 的 init 结束被调用</span><br><span class="line">Son1 的 init 结束被调用</span><br><span class="line">Son2 的 init 开始被调用</span><br><span class="line">parent 的 init 开始被调用</span><br><span class="line">parent 的 init 结束被调用</span><br><span class="line">Son2 的 init 结束被调用</span><br><span class="line">Grandson 的 init 结束被调用</span><br><span class="line">姓名： grandson</span><br><span class="line">年龄： 12</span><br><span class="line">性别： 男</span><br><span class="line">******多继承使用类名.__init__发生的状态******</span><br></pre></td></tr></table></figure>
<blockquote>
<p>多继承中<code>super</code>调用被重写的父类方法</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot; ******多继承使用 super().__init__发生的状态******&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, *args, **kwargs</span>):  <span class="comment"># 为避免多继承报错，使用不定长参数，接受参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;parent 的 init 开始被调用&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;parent 的 init 结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, *args, **kwargs</span>):  <span class="comment"># 为避免多继承报错，使用不定长参数，接受参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Son1 的 init 开始被调用&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, *args, **kwargs)  <span class="comment"># 为避免多继承报错，使用不定长参数，接受参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Son1 的 init 结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, gender, *args, **kwargs</span>):  <span class="comment"># 为避免多继承报错，使用不定长参数，接受参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Son2 的 init 开始被调用&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.gender = gender</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, *args, **kwargs)  <span class="comment"># 为避免多继承报错，使用不定长参数，接受参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Son2 的 init 结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grandson</span>(Son1, Son2):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, gender</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Grandson 的 init 开始被调用&#x27;</span>)</span><br><span class="line">        <span class="comment"># 多继承时，相对于使用类名.__init__ 方法，要把每个父类全部写一遍</span></span><br><span class="line">        <span class="comment"># 而 super 只用一句话，执行了全部父类的方法，这也是为何多继承需要全部传参的一个原因</span></span><br><span class="line">        <span class="comment"># super(Grandson, self).__init__(name, age, gender)</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age, gender)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Grandson 的 init 结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(Grandson.__mro__)</span><br><span class="line"></span><br><span class="line">gs = Grandson(<span class="string">&#x27;grandson&#x27;</span>, <span class="number">12</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;姓名：&#x27;</span>, gs.name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;年龄：&#x27;</span>, gs.age)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;性别：&#x27;</span>, gs.gender)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; ******多继承使用 super().__init__发生的状态******\n\n &quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">******多继承使用 super().__init__发生的状态******</span><br><span class="line">(&lt;class &#x27;__main__.Grandson&#x27;&gt;, &lt;class &#x27;__main__.Son1&#x27;&gt;, &lt;class &#x27;__main__.Son2&#x27;&gt;, &lt;class &#x27;__main__.Parent&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)</span><br><span class="line">Grandson 的 init 开始被调用</span><br><span class="line">Son1 的 init 开始被调用</span><br><span class="line">Son2 的 init 开始被调用</span><br><span class="line">parent 的 init 开始被调用</span><br><span class="line">parent 的 init 结束被调用</span><br><span class="line">Son2 的 init 结束被调用</span><br><span class="line">Son1 的 init 结束被调用</span><br><span class="line">Grandson 的 init 结束被调用</span><br><span class="line">姓名： grandson</span><br><span class="line">年龄： 12</span><br><span class="line">性别： 男</span><br><span class="line">******多继承使用 super().__init__发生的状态******</span><br></pre></td></tr></table></figure>
<p>上述两种调用父类的方法是有区别的</p>
<ol>
<li>如果2个子类中都继承了父类，当在子类中通过父类名调用时，parent被执行了2次</li>
<li>如果2个子类中都继承了父类，当在子类中通过super调用时，parent被执行了1次</li>
</ol>
<h4 id="单继承中的super">单继承中的<code>super</code></h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot; ******单继承使用 super().__init__发生的状态******&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;parent 的 init 开始被调用&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;parent 的 init 结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Son1 的 init 开始被调用&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.age = age</span><br><span class="line">        <span class="built_in">super</span>().__init__(name)  <span class="comment"># 单继承不能提供全部参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Son1 的 init 结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Grandson</span>(<span class="title class_ inherited__">Son</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age, gender</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Grandson 的 init 开始被调用&#x27;</span>)</span><br><span class="line">        <span class="variable language_">self</span>.gender = gender</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, age)  <span class="comment"># 单继承不能提供全部参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Grandson 的 init 结束被调用&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gs = Grandson(<span class="string">&#x27;grandson&#x27;</span>, <span class="number">12</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;姓名：&#x27;</span>, gs.name)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;年龄：&#x27;</span>, gs.age)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;性别：&#x27;</span>, gs.gender)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot; ******单继承使用 super().__init__发生的状态******\n\n &quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">******单继承使用 super().__init__发生的状态******</span><br><span class="line">Grandson 的 init 开始被调用</span><br><span class="line">Son1 的 init 开始被调用</span><br><span class="line">parent 的 init 开始被调用</span><br><span class="line">parent 的 init 结束被调用</span><br><span class="line">Son1 的 init 结束被调用</span><br><span class="line">Grandson 的 init 结束被调用</span><br><span class="line">姓名： grandson</span><br><span class="line">年龄： 12</span><br><span class="line">性别： 男</span><br><span class="line">******单继承使用 super().__init__发生的状态******</span><br></pre></td></tr></table></figure>
<h4 id="简单总结-6">简单总结</h4>
<ol>
<li><code>super().__init__</code>相对于<code>类名.__init__</code>，在单继承上用法基本没有区别</li>
<li>但在多继承上有区别，<code>super</code>方法能保证每个父类的方法只会执行一次，而使用类名的方法会导致方法被执行多次，具体看前面的输出结果</li>
<li>多继承时，使用<code>super</code>方法，对父类的传参，由于<code>super</code>的算法导致的原因，必须把参数全部传递，否则会报错</li>
<li>单继承时，使用<code>super</code>方法，则不能全部传递，只能传父类方法所需的参数，否则会报错</li>
<li>多继承时，相对于使用<code>类名.__init__</code>方法，要把每个父类全部写一遍, 而使用<code>super</code>方法，只需写一句话便执行了全部父类的方法，这也是为何多继承需要全部传参的一个原因</li>
</ol>
<h4 id="面试题">面试题</h4>
<p>以下代码将会输出什么？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    x = <span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child1</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child2</span>(<span class="title class_ inherited__">Parent</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(Parent.x, Child1.x, Child2.x)</span><br><span class="line">Child1.x = <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(Parent.x, Child1.x, Child2.x)</span><br><span class="line">Parent.x = <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(Parent.x, Child1.x, Child2.x)</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 1 1</span><br><span class="line">1 2 1</span><br><span class="line">3 2 3</span><br></pre></td></tr></table></figure>
<p>使你困惑或是惊奇的是关于最后一行的输出是 3 2 3 而不是 3 2 1。为什么改变了 Parent.x 的值还会改变 Child2.x 的值，但是同时 Child1.x 值却没有改变？</p>
<p>这个答案的关键是，在 Python 中，类变量在内部是作为字典处理的。如果一个变量的名字没有在当前类的字典中发现，将搜索祖先类（比如父类）直到被引用的变量名被找到（如果这个被引用的变量名既没有在自己所在的类又没有在祖先类中找到，会引发一个 AttributeError 异常 ）。</p>
<p>因此，在父类中设置 x = 1 会使得类变量 x 在引用该类和其任何子类中的值为 1。这就是因为第一个 print 语句的输出是 1 1 1。</p>
<p>随后，如果任何它的子类重写了该值（例如，我们执行语句 Child1.x = 2），然后，该值仅仅在子类中被改变。这就是为什么第二个 print 语句的输出是 1 2 1。</p>
<p>最后，如果该值在父类中被改变（例如，我们执行语句 Parent.x = 3），这个改变会影响到任何未重写该值的子类当中的值（在这个示例中被影响的子类是 Child2）。这就是为什么第三个 print 输出是 3 2 3。</p>
<h3 id="15-单例模式">15. 单例模式</h3>
<blockquote>
<p>如果对一个类进行了多次的实例化，那么在内存中产生多个实例对象。在某些场景下，并不需要多个实例对象。而是重用第一次创建的实例对象。例如：在一个类中创建了多个关于云服务器的连接信息，这些信息是不变的。那么只是需要一个实例对象来访问这些信息，而不是创建多个来占用内存。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单例模式代码示例</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Single</span>:</span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> cls._instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls._instance = <span class="built_in">object</span>._ _new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">single_1 = Single()</span><br><span class="line">single_2 = Single()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(single_1) == <span class="built_in">id</span>(single_2))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConnectionServer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&#x27;_instance&#x27;</span>):</span><br><span class="line">            cls._instance = <span class="built_in">super</span>()._ _new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, host, port, password</span>):</span><br><span class="line">        <span class="variable language_">self</span>.host = host</span><br><span class="line">        <span class="variable language_">self</span>.port = port</span><br><span class="line">        <span class="variable language_">self</span>.password = password</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server_1 = ConnectionServer(<span class="string">&#x27;192.168.1.1&#x27;</span>, <span class="number">1234</span>, <span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">server_2 = ConnectionServer(<span class="string">&#x27;192.168.1.2&#x27;</span>, <span class="number">3456</span>, <span class="string">&#x27;456&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(server_1) == <span class="built_in">id</span>(server_2))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(server_1.host, server_1.port, server_1.password)</span><br><span class="line"><span class="built_in">print</span>(server_2.host, server_2.port, server_2.password)</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ol>
<li><code>__new__</code>方法是一个特殊的方法，与<code>__init__</code>方法类似。如果在类中存在以双下划线开头并且双下划线结尾的方法名时，则这个方法我们称之为魔术方法。魔术方法在基类<code>object</code>中已经实现。</li>
<li>在类的实例化过程中，<code>__new__</code>方法比<code>__init__</code>方法先执行。</li>
<li><code>__new__</code>方法的第一个参数为<code>cls</code>，而不是<code>self</code>。在<code>object</code>基类源码中可以发现<code>__new__</code>方法是一个类方法。</li>
</ol>
<h3 id="16-object基类">16. <code>object</code>基类</h3>
<blockquote>
<p>在Python3中，所有定义的类都默认继承了<code>object</code>。在<code>object</code>类中实现了多个方法，包括了魔术方法。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># object 源码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">object</span>:</span><br><span class="line">    <span class="string">&quot;&quot;</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">    The base class of the class hierarchy.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    When called, it accepts no arguments and returns a new featureless</span></span><br><span class="line"><span class="string">    instance that has no instance attributes and cannot be given any.</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot; &quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delattr__</span>(<span class="params">self, *args, **kwargs</span>): <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot; Implement delattr(self, name). &quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__dir__</span>(<span class="params">self, *args, **kwargs</span>): <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot; Default dir() implementation. &quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, *args, **kwargs</span>): <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot; Return self == value. &quot;</span><span class="string">&quot; &quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__format__</span>(<span class="params">self, *args, **kwargs</span>): <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot; Default object formatter. &quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getattribute__</span>(<span class="params">self, *args, **kwargs</span>): <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot; Return getattr(self, name). &quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__ge__</span>(<span class="params">self, *args, **kwargs</span>): <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot; Return self &gt;= value. &quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__gt__</span>(<span class="params">self, *args, **kwargs</span>): <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot; Return self &gt; value. &quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self, *args, **kwargs</span>): <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot; Return hash(self). &quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init_subclass__</span>(<span class="params">self, *args, **kwargs</span>): <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">        This method is called when a class is subclassed.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        The default implementation does nothing. It may be</span></span><br><span class="line"><span class="string">        overridden to extend subclasses.</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot; &quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>): <span class="comment"># known special case of object.__init__</span></span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot; Initialize self.  See help(type(self)) for accurate signature. &quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__le__</span>(<span class="params">self, *args, **kwargs</span>): <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot; Return self &lt;= value. &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__lt__</span>(<span class="params">self, *args, **kwargs</span>): <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot; Return self &lt; value. &quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod </span><span class="comment"># known case of __new__</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__new__</span>(<span class="params">cls, *more</span>): <span class="comment"># known special case of object.__new__</span></span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot; Create and return a new object.  See help(type) for accurate signature. &quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__ne__</span>(<span class="params">self, *args, **kwargs</span>): <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot; Return self!= value. &quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce_ex__</span>(<span class="params">self, *args, **kwargs</span>): <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot; Helper for pickle. &quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__reduce__</span>(<span class="params">self, *args, **kwargs</span>): <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot; Helper for pickle. &quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self, *args, **kwargs</span>): <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot; Return repr(self). &quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setattr__</span>(<span class="params">self, *args, **kwargs</span>): <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot; Implement setattr(self, name, value). &quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__sizeof__</span>(<span class="params">self, *args, **kwargs</span>): <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot; Size of object in memory, in bytes. &quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self, *args, **kwargs</span>): <span class="comment"># real signature unknown</span></span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot; Return str(self). &quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod </span><span class="comment"># known case</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__subclasshook__</span>(<span class="params">cls, subclass</span>): <span class="comment"># known special case of object.__subclasshook__</span></span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">        Abstract classes can override this to customize issubclass().</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        This is invoked early on by abc.ABCMeta.__subclasscheck__().</span></span><br><span class="line"><span class="string">        It should return True, False or NotImplemented.  If it returns</span></span><br><span class="line"><span class="string">        NotImplemented, the normal algorithm is used.  Otherwise, it</span></span><br><span class="line"><span class="string">        overrides the normal algorithm (and the outcome is cached).</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot; &quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    __class__ = <span class="literal">None</span> <span class="comment"># (!) forward: type, real value is &quot;&lt;class &#x27;type&#x27;&gt;&quot;</span></span><br><span class="line">    __dict__ = &#123;&#125;</span><br><span class="line">    __doc__ = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    __module__ = <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="2-10-Python高阶技巧">2.10 Python高阶技巧</h2>
<h3 id="1-迭代器">1. 迭代器</h3>
<h4 id="引入-6">引入</h4>
<p>如果开发中有以下需求，如何解决？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StuSystem</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">    学生管理系统</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot; &quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stus = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">        添加一个新的学生</span></span><br><span class="line"><span class="string">        : return:</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot; &quot;</span></span><br><span class="line">        name = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的姓名:&quot;</span>)</span><br><span class="line">        tel = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的手机号:&quot;</span>)</span><br><span class="line">        address = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的住址:&quot;</span>)</span><br><span class="line"></span><br><span class="line">        new_stu = <span class="built_in">dict</span>()</span><br><span class="line">        new_stu [<span class="string">&quot;name&quot;</span>] = name</span><br><span class="line">        new_stu [<span class="string">&quot;tel&quot;</span>] = tel</span><br><span class="line">        new_stu [<span class="string">&quot;address&quot;</span>] = address</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.stus.append(new_stu)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建管理系统对象</span></span><br><span class="line">stu_sys = StuSystem()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 3 个学生信息到系统中</span></span><br><span class="line">stu_sys.add()</span><br><span class="line">stu_sys.add()</span><br><span class="line">stu_sys.add()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 问题 1：怎样才能实现用 for 循环遍历系统中所有的学生信息呢？下面的方式能实现吗？</span></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> stu_sys:</span><br><span class="line">    <span class="built_in">print</span>(temp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 问题 2：如果需要一个列表，这个列表 样子例如 [&#123;&#x27;name&#x27;: &#x27;张三&#x27;, &#x27;id&#x27;: 10086&#125;, &#123;&#x27;name&#x27;: &#x27;李四&#x27;: &#x27;id&#x27;: 10087&#125;]</span></span><br><span class="line"><span class="comment"># stu_list = [ ...列表推导式...]</span></span><br><span class="line"><span class="comment"># 这个列表推导式该怎样写才能实现呢？</span></span><br></pre></td></tr></table></figure>
<p>在实际开发工作中，经常需要快速的将对象转化问其他的不同的数据类型，此时如果能快速的遍历出自定义的对象，这样大大减少代码的冗余，而且可读性会更优美</p>
<p>问题是，怎样实现呢？</p>
<p>今天我们要学习的知识只有1个，那就是<code>迭代器</code></p>
<h4 id="什么是迭代">什么是迭代</h4>
<p>迭代是访问序列类型元素的一种方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以通过 for 循环将 nums 列表中的每个数据依次获取</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="built_in">print</span>(num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">name = <span class="string">&quot;teacher&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> name:</span><br><span class="line">    <span class="built_in">print</span>(temp)</span><br></pre></td></tr></table></figure>
<p>我们已经知道可以对<code>list</code>、<code>tuple</code>、<code>str</code>等类型的数据使用<code>for...in...</code>的循环语法从其中依次拿到数据进行使用，我们把这样的过程称为遍历，也叫<code>迭代</code></p>
<h4 id="可迭代对象">可迭代对象</h4>
<p>是否所有的数据类型都可以放到<code>for...in...</code>的语句中，然后让<code>for...in...</code>每次从中取出一条数据供我们使用呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">weight = <span class="number">160</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> weight:</span><br><span class="line">    <span class="built_in">print</span>(item)  <span class="comment"># 报错</span></span><br></pre></td></tr></table></figure>
<p>通过运行可以发现，并不是所有的类型都可以通过<code>for...in...</code>的方式进行遍历</p>
<p>我们可以通俗的认为：只要是可以通过for…in…的形式进行遍历的，那么这个数据类型就是可以迭代的</p>
<p>例如，下面的是可以迭代的数据类型</p>
<ul>
<li>列表</li>
<li>元组</li>
<li>字典</li>
<li>字符串</li>
</ul>
<p>而下面的则不是可以迭代的数据类型</p>
<ul>
<li>整型</li>
<li>浮点型</li>
</ul>
<p>那是否可以通过某种方式能够测量出一个数据类型到底是否是可以迭代呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">50</span>]: <span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line">In [<span class="number">51</span>]: <span class="built_in">isinstance</span>([], Iterable)</span><br><span class="line">Out [<span class="number">51</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">52</span>]: <span class="built_in">isinstance</span>(&#123;&#125;, Iterable)</span><br><span class="line">Out [<span class="number">52</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">53</span>]: <span class="built_in">isinstance</span>(<span class="string">&#x27;abc&#x27;</span>, Iterable)</span><br><span class="line">Out [<span class="number">53</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">54</span>]: <span class="built_in">isinstance</span>(mylist, Iterable)</span><br><span class="line">Out [<span class="number">54</span>]: <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">55</span>]: <span class="built_in">isinstance</span>(<span class="number">100</span>, Iterable)</span><br><span class="line">Out [<span class="number">55</span>]: <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>只要是通过<code>isinstance</code>来判断出是<code>Iterable</code>类的实例，即<code>isinstance</code>的结果是<code>True</code>那么就表示，这个数据类型是可以迭代的数据类型</p>
<h4 id="迭代器">迭代器</h4>
<p>迭代器是一个可以记住遍历的位置的对象。迭代器对象从第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p>
<blockquote>
<p>可迭代对象的本质</p>
</blockquote>
<p>分析 可迭代对象 进行迭代的过程，发现每迭代一次（即在<code>for...in...</code>中每循环一次）都会返回对象中的下一条数据，一直向后读取数据直到迭代了所有数据后结束。</p>
<p>那么，在这个过程中就应该有一个“人”去记录每次访问到了第几条数据，以便每次迭代都可以返回下一条数据。我们把这个能帮助我们进行数据迭代的“人”称为迭代器(Iterator)</p>
<p>可迭代对象的本质就是可以向我们提供一个这样的中间“人”，即迭代器帮助我们对其进行迭代遍历使用。</p>
<p><code>list</code>、<code>tuple</code>等都是可迭代对象，我们可以通过<code>iter()</code>函数获取这些可迭代对象的迭代器。然后我们可以对获取到的迭代器不断使用<code>next()</code>函数来获取下一条数据。</p>
<blockquote>
<p>获取可迭代对象的迭代器</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(nums))</span><br><span class="line"></span><br><span class="line">nums_iter = <span class="built_in">iter</span>(nums)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(nums_iter))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nums&quot;</span>, <span class="built_in">isinstance</span>(nums, Iterator))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nums_iter&quot;</span>, <span class="built_in">isinstance</span>(nums_iter, Iterator))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>获取迭代器的数据</p>
</blockquote>
<p>上面提到，通过<code>iter()</code>能够得到一个可迭代对象的 迭代器，可以通过<code>next()</code>函数多次提取迭代器中的数据，下面我们就测试下</p>
<p>测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br><span class="line">nums_iter = <span class="built_in">iter</span>(nums)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nums&quot;</span>, <span class="built_in">isinstance</span>(nums, Iterator))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nums_iter&quot;</span>, <span class="built_in">isinstance</span>(nums_iter, Iterator))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num1 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line"><span class="built_in">print</span>(num1)</span><br><span class="line"></span><br><span class="line">num2 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line"><span class="built_in">print</span>(num2)</span><br><span class="line"></span><br><span class="line">num3 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line"><span class="built_in">print</span>(num3)</span><br><span class="line"></span><br><span class="line">num4 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line"><span class="built_in">print</span>(num4)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>StopIteration 异常</p>
</blockquote>
<p>如果将上面的代码，多写一次的<code>next()</code>会怎样呢？看如下测试代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br><span class="line">nums_iter = <span class="built_in">iter</span>(nums)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nums&quot;</span>, <span class="built_in">isinstance</span>(nums, Iterator))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;nums_iter&quot;</span>, <span class="built_in">isinstance</span>(nums_iter, Iterator))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num1 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line"><span class="built_in">print</span>(num1)</span><br><span class="line"></span><br><span class="line">num2 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line"><span class="built_in">print</span>(num2)</span><br><span class="line"></span><br><span class="line">num3 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line"><span class="built_in">print</span>(num3)</span><br><span class="line"></span><br><span class="line">num4 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line"><span class="built_in">print</span>(num4)</span><br><span class="line"></span><br><span class="line">num5 = <span class="built_in">next</span>(nums_iter)  <span class="comment"># 这里会产生异常</span></span><br><span class="line"><span class="built_in">print</span>(num5)</span><br></pre></td></tr></table></figure>
<p>可以看到23行，即第5次调用<code>next()</code>时，产生了异常。why？？？？？？</p>
<p>因为列表<code>nums</code>中只有4个数据，也就是说可以调用4次<code>next</code>是完全合理的，但是如果，调用的次数多了肯定是不合理，都没有5个数据，怎么可以能取5次呢！显然是不对的</p>
<p>此时估计想明白了，为什么会产生异常，其实就是一种告知迭代结束的标志而已</p>
<p>添加<code>try...except...</code>即可解决刚刚遇到的问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    num5 = <span class="built_in">next</span>(nums_iter)</span><br><span class="line">    <span class="built_in">print</span>(num5)</span><br><span class="line"><span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;迭代结束: <span class="subst">&#123;e&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="自定义迭代器">自定义迭代器</h4>
<p>大家是否还记得 在刚开学习今天的知识时，我们引入了一个学生管理系统的问题，该怎样实现呢</p>
<p>我们下面来谈谈</p>
<ul>
<li><code>__iter__</code>方法</li>
<li><code>__next__</code>方法</li>
</ul>
<blockquote>
<p><code>__iter__</code>方法</p>
</blockquote>
<p>上面提到<code>iter()</code>方法必须是对”可迭代“对象 才能 提取到 ”迭代器“对象，但是怎样保证自定义的对象是”可迭代“对象呢？</p>
<p>答：只要在类中定义<code>__iter__</code>方法，那么这个类创建出来的对象一定是可迭代对象</p>
<p>通俗的说：一个具备了<code>__iter__</code>方法的对象就是一个可以迭代的对象</p>
<p>测试代码一：无<code>__iter__</code>方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.container = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="variable language_">self</span>.container.append(item)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">mylist = MyList()</span><br><span class="line">mylist.add(<span class="number">11</span>)</span><br><span class="line">mylist.add(<span class="number">22</span>)</span><br><span class="line">mylist.add(<span class="number">33</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mylist 是否是可以迭代对象&quot;</span>, <span class="built_in">isinstance</span>(mylist, Iterable))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> mylist:</span><br><span class="line">    <span class="built_in">print</span>(temp)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mylist 是否是可以迭代对象 False</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/ubuntu/Desktop/stu_code/测试代码.py&quot;, line 19, in &lt;module&gt;</span><br><span class="line">    for temp in mylist:</span><br><span class="line">TypeError: &#x27;MyList&#x27; object is not iterable</span><br></pre></td></tr></table></figure>
<p>测试代码二：有<code>__iter__</code>方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.container = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="variable language_">self</span>.container.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">mylist = MyList()</span><br><span class="line">mylist.add(<span class="number">11</span>)</span><br><span class="line">mylist.add(<span class="number">22</span>)</span><br><span class="line">mylist.add(<span class="number">33</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mylist 是否是可以迭代对象&quot;</span>, <span class="built_in">isinstance</span>(mylist, Iterable))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> mylist:</span><br><span class="line">    <span class="built_in">print</span>(temp)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mylist 是否是可以迭代对象 True</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/home/ubuntu/Desktop/stu_code/测试代码.py&quot;, line 21, in &lt;module&gt;</span><br><span class="line">    for temp in mylist:</span><br><span class="line">TypeError: iter() returned non-iterator of type &#x27;NoneType&#x27;</span><br></pre></td></tr></table></figure>
<p>能够看出，一个类，只要有<code>__iter__</code>方法，那么这个类创建出来的对象就是可以迭代对象</p>
<p>其实，当我们调用<code>iter()</code>函数提取一个可迭代对象的 迭代器时，实际上会自动调用这个对象的<code>__iter__</code>方法，并且这个方法返回迭代器</p>
<blockquote>
<p><code>__next__</code>方法</p>
</blockquote>
<p>通过上面的分析，我们已经知道，迭代器是用来帮助我们记录每次迭代访问到的位置，当我们对迭代器使用<code>next()</code>函数的时候，迭代器会向我们返回它所记录位置的下一个位置的数据。</p>
<p>实际上，在使用<code>next()</code>函数的时候，调用的就是迭代器对象的<code>__next__</code>方法（Python3中是对象的<code>__next__</code>方法，Python2中是对象的<code>next()</code>方法）。</p>
<p>所以，我们要想构造一个迭代器，就要实现它的<code>__next__</code>方法。</p>
<p>但这还不够，python要求迭代器本身也是可迭代的，所以我们还要为迭代器实现<code>__iter__</code>方法，而<code>__iter__</code>方法要返回一个迭代器，迭代器自身正是一个迭代器，所以迭代器的<code>__iter__</code>方法返回自身即可。</p>
<p>一个实现了<code>__iter__</code>方法和<code>__next__</code>方法的对象，就是迭代器</p>
<p>如何判断一个对象是否是迭代器</p>
<p>可以使用 isinstance() 判断一个对象是否是 Iterator 对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">56</span>]: <span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line">In [<span class="number">57</span>]: <span class="built_in">isinstance</span>([], Iterator)</span><br><span class="line">Out [<span class="number">57</span>]: <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">58</span>]: <span class="built_in">isinstance</span>(<span class="built_in">iter</span>([]), Iterator)</span><br><span class="line">Out [<span class="number">58</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">59</span>]: <span class="built_in">isinstance</span>(<span class="built_in">iter</span>(<span class="string">&quot;abc&quot;</span>), Iterator)</span><br><span class="line">Out [<span class="number">59</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p>自定义迭代器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;</span> <span class="string">&quot;自定义的一个可迭代对象&quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.items = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="variable language_">self</span>.items.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> MyIterator()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyIterator</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;</span> <span class="string">&quot;自定义的供上面可迭代对象使用的一个迭代器&quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mylist = MyList()</span><br><span class="line">mylist_iter = <span class="built_in">iter</span>(mylist)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mylist 是否是可以迭代对象&quot;</span>, <span class="built_in">isinstance</span>(mylist, Iterable))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mylist 是否是迭代器&quot;</span>, <span class="built_in">isinstance</span>(mylist, Iterator))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mylist_iter 是否是可以迭代对象&quot;</span>, <span class="built_in">isinstance</span>(mylist_iter, Iterable))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;mylist_iter 是否是迭代器&quot;</span>, <span class="built_in">isinstance</span>(mylist_iter, Iterator))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mylist 是否是可以迭代对象 True</span><br><span class="line">mylist 是否是迭代器 False</span><br><span class="line">mylist_iter 是否是可以迭代对象 True</span><br><span class="line">mylist_iter 是否是迭代器 True</span><br></pre></td></tr></table></figure>
<blockquote>
<p>自定义<code>迭代器</code>案例</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;</span> <span class="string">&quot;自定义的一个可迭代对象&quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.items = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="variable language_">self</span>.items.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        myiterator = MyIterator(<span class="variable language_">self</span>)</span><br><span class="line">        <span class="keyword">return</span> myiterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyIterator</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;</span> <span class="string">&quot;自定义的供上面可迭代对象使用的一个迭代器&quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, mylist</span>):</span><br><span class="line">        <span class="variable language_">self</span>.mylist = mylist</span><br><span class="line">        <span class="comment"># current 用来记录当前访问到的位置</span></span><br><span class="line">        <span class="variable language_">self</span>.current = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.current &lt; <span class="built_in">len</span>(<span class="variable language_">self</span>.mylist.items):</span><br><span class="line">            item = <span class="variable language_">self</span>.mylist.items [<span class="variable language_">self</span>.current]</span><br><span class="line">            <span class="variable language_">self</span>.current += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    mylist = MyList()</span><br><span class="line">    mylist.add(<span class="number">1</span>)</span><br><span class="line">    mylist.add(<span class="number">2</span>)</span><br><span class="line">    mylist.add(<span class="number">3</span>)</span><br><span class="line">    mylist.add(<span class="number">4</span>)</span><br><span class="line">    mylist.add(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> mylist:</span><br><span class="line">        <span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>可迭代对象通过<code>__iter__</code>方法向我们返回一个迭代器，我们在迭代一个可迭代对象的时候，实际上就是先获取该对象提供的一个迭代器，然后通过这个迭代器来依次获取对象中的每一个数据。</p>
<h4 id="for-in-循环的本质"><code>for...in...</code>循环的本质</h4>
<ol>
<li>先调用<code>iter()</code>函数，它会自动调用可迭代对象中的<code>__iter__</code>方法，此方法返回这个可迭代对象的 迭代器对象</li>
<li>对获取到的迭代器不断调用<code>next()</code>函数，它会自动调用迭代器中的<code>__next__</code>方法来获取下一个值</li>
<li>当遇到<code>StopIteration</code>异常后循环结束</li>
</ol>
<h4 id="并不是只有for循环能接收可迭代对象">并不是只有<code>for</code>循环能接收可迭代对象</h4>
<p>除了<code>for</code>循环能接收可迭代对象，<code>list</code>、<code>tuple</code>等也能接收。</p>
<p>测试代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;</span> <span class="string">&quot;自定义的一个可迭代对象&quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.items = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, val</span>):</span><br><span class="line">        <span class="variable language_">self</span>.items.append(val)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        myiterator = MyIterator(<span class="variable language_">self</span>)</span><br><span class="line">        <span class="keyword">return</span> myiterator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyIterator</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;</span> <span class="string">&quot;自定义的供上面可迭代对象使用的一个迭代器&quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, mylist</span>):</span><br><span class="line">        <span class="variable language_">self</span>.mylist = mylist</span><br><span class="line">        <span class="comment"># current 用来记录当前访问到的位置</span></span><br><span class="line">        <span class="variable language_">self</span>.current = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.current &lt; <span class="built_in">len</span>(<span class="variable language_">self</span>.mylist.items):</span><br><span class="line">            item = <span class="variable language_">self</span>.mylist.items [<span class="variable language_">self</span>.current]</span><br><span class="line">            <span class="variable language_">self</span>.current += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> item</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    mylist = MyList()</span><br><span class="line">    mylist.add(<span class="number">1</span>)</span><br><span class="line">    mylist.add(<span class="number">2</span>)</span><br><span class="line">    mylist.add(<span class="number">3</span>)</span><br><span class="line">    mylist.add(<span class="number">4</span>)</span><br><span class="line">    mylist.add(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    nums = <span class="built_in">list</span>(mylist)</span><br><span class="line">    <span class="built_in">print</span>(nums)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>
<h4 id="简单总结-7">简单总结</h4>
<ul>
<li>凡是可作用于<code>for </code>循环的对象都是<code> Iterable</code> 类型</li>
<li>凡是可作用于 <code>next()</code> 函数的对象都是<code> Iterator</code> 类型</li>
<li>序列数据类型如<code> list</code> 、<code>dict</code>、<code>str</code>等是 <code>Iterable </code>但不是<code>Iterator</code>，不过可以通过 <code>iter() </code>函数获得一个 <code>Iterator </code>对象</li>
</ul>
<h4 id="随堂作业">随堂作业</h4>
<p>既然已经学习过了迭代器，那么今天刚开始的知识点也就自然有了答案</p>
<ul>
<li>实现用<code>for</code>循环遍历学生系统中的所有学生信息</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StuSystem</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">    学生管理系统</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot; &quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stus = []</span><br><span class="line">        <span class="variable language_">self</span>.current_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">        添加一个新的学生</span></span><br><span class="line"><span class="string">        : return:</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot; &quot;</span></span><br><span class="line">        name = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的姓名:&quot;</span>)</span><br><span class="line">        tel = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的手机号:&quot;</span>)</span><br><span class="line">        address = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的住址:&quot;</span>)</span><br><span class="line">        new_stu = <span class="built_in">dict</span>()</span><br><span class="line">        new_stu [<span class="string">&quot;name&quot;</span>] = name</span><br><span class="line">        new_stu [<span class="string">&quot;tel&quot;</span>] = tel</span><br><span class="line">        new_stu [<span class="string">&quot;address&quot;</span>] = address</span><br><span class="line">        <span class="variable language_">self</span>.stus.append(new_stu)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.current_num &lt; <span class="built_in">len</span>(<span class="variable language_">self</span>.stus):</span><br><span class="line">            ret = <span class="variable language_">self</span>.stus [<span class="variable language_">self</span>.current_num]</span><br><span class="line">            <span class="variable language_">self</span>.current_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.current_num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建管理系统对象</span></span><br><span class="line">stu_sys = StuSystem()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 3 个学生信息到系统中</span></span><br><span class="line">stu_sys.add()</span><br><span class="line">stu_sys.add()</span><br><span class="line">stu_sys.add()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 问题 1：怎样才能实现用 for 循环遍历系统中所有的学生信息呢？下面的方式能实现吗？</span></span><br><span class="line"><span class="keyword">for</span> temp <span class="keyword">in</span> stu_sys:</span><br><span class="line">    <span class="built_in">print</span>(temp)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(base) ubuntu@VM-16-5-ubuntu:~/Desktop/stu_code$ /home/ubuntu/miniconda3/bin/python /home/ubuntu/Desktop/stu_code/测试代码.py</span><br><span class="line">请输入新学生的姓名: 顾安</span><br><span class="line">请输入新学生的手机号: 13711111111</span><br><span class="line">请输入新学生的住址: 长沙</span><br><span class="line">请输入新学生的姓名: 安娜</span><br><span class="line">请输入新学生的手机号: 13711111112</span><br><span class="line">请输入新学生的住址: 长沙</span><br><span class="line">请输入新学生的姓名: 双双</span><br><span class="line">请输入新学生的手机号: 13711111113</span><br><span class="line">请输入新学生的住址: 长沙</span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;顾安&#x27;, &#x27;tel&#x27;: &#x27;13711111111&#x27;, &#x27;address&#x27;: &#x27;长沙&#x27;&#125;</span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;安娜&#x27;, &#x27;tel&#x27;: &#x27;13711111112&#x27;, &#x27;address&#x27;: &#x27;长沙&#x27;&#125;</span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;双双&#x27;, &#x27;tel&#x27;: &#x27;13711111113&#x27;, &#x27;address&#x27;: &#x27;长沙&#x27;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对输入的数据进行格式转换</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StuSystem</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="string">&quot;&quot;</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">    学生管理系统</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot; &quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.stus = []</span><br><span class="line">        <span class="variable language_">self</span>.current_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">        添加一个新的学生</span></span><br><span class="line"><span class="string">        : return:</span></span><br><span class="line"><span class="string">        &quot;</span><span class="string">&quot; &quot;</span></span><br><span class="line">        name = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的姓名:&quot;</span>)</span><br><span class="line">        tel = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的手机号:&quot;</span>)</span><br><span class="line">        address = <span class="built_in">input</span>(<span class="string">&quot;请输入新学生的住址:&quot;</span>)</span><br><span class="line">        new_stu = <span class="built_in">dict</span>()</span><br><span class="line">        new_stu [<span class="string">&quot;name&quot;</span>] = name</span><br><span class="line">        new_stu [<span class="string">&quot;tel&quot;</span>] = tel</span><br><span class="line">        new_stu [<span class="string">&quot;address&quot;</span>] = address</span><br><span class="line">        <span class="variable language_">self</span>.stus.append(new_stu)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.current_num &lt; <span class="built_in">len</span>(<span class="variable language_">self</span>.stus):</span><br><span class="line">            ret = <span class="variable language_">self</span>.stus [<span class="variable language_">self</span>.current_num]</span><br><span class="line">            <span class="variable language_">self</span>.current_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.current_num = <span class="number">0</span></span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu_sys = StuSystem()</span><br><span class="line"></span><br><span class="line">stu_sys.add()</span><br><span class="line">stu_sys.add()</span><br><span class="line">stu_sys.add()</span><br><span class="line"></span><br><span class="line">stu_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> stu_sys]</span><br><span class="line"><span class="built_in">print</span>(stu_list)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">请输入新学生的姓名: 顾安</span><br><span class="line">请输入新学生的手机号: 13711111111</span><br><span class="line">请输入新学生的住址: 长沙</span><br><span class="line">请输入新学生的姓名: 安娜</span><br><span class="line">请输入新学生的手机号: 13711111112</span><br><span class="line">请输入新学生的住址: 南京</span><br><span class="line">请输入新学生的姓名: 双双</span><br><span class="line">请输入新学生的手机号: 13711111113</span><br><span class="line">请输入新学生的住址: 上海</span><br><span class="line">[&#123;&#x27;name&#x27;: &#x27;顾安&#x27;, &#x27;tel&#x27;: &#x27;13711111111&#x27;, &#x27;address&#x27;: &#x27;长沙&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;安娜&#x27;, &#x27;tel&#x27;: &#x27;13711111112&#x27;, &#x27;address&#x27;: &#x27;南京&#x27;&#125;, &#123;&#x27;name&#x27;: &#x27;双双&#x27;, &#x27;tel&#x27;: &#x27;13711111113&#x27;, &#x27;address&#x27;: &#x27;上海&#x27;&#125;]</span><br></pre></td></tr></table></figure>
<h3 id="2-生成器">2. 生成器</h3>
<h4 id="引入-7">引入</h4>
<p>在<code>Python</code>中，使用生成器可以很方便的支持迭代器协议。生成器通过生成器函数产生，生成器函数可以通过常规的<code>def</code>语句来定义，但是不用<code>return</code>返回，而是用<code>yield</code>一次返回一个结果，在每个结果之间挂起和继续它们的状态，来自动实现迭代协议。</p>
<p>也就是说，<code>yield</code>是一个语法糖，内部实现支持了迭代器协议，同时<code>yield</code>内部是一个状态机，维护着挂起和继续的状态。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_range</span>(<span class="params">n</span>):</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">my_range = my_range(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(my_range)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_range))</span><br><span class="line"><span class="comment"># print([i for i in my_range])</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，定义了一个生成器函数，函数返回一个生成器对象，然后就可以通过<code>for</code>语句进行迭代访问了。</p>
<p>其实，生成器函数返回生成器的迭代器。 “生成器的迭代器&quot;这个术语通常被称作&quot;生成器”。要注意的是生成器就是一类特殊的迭代器。作为一个迭代器，生成器必须要定义一些方法，其中一个就是<code>__next__()</code>。如同迭代器一样，我们可以使用<code>__next__()</code>函数来获取下一个值。</p>
<h4 id="生成器工作流程">生成器工作流程</h4>
<p>下面就仔细看看生成器是怎么工作的。从上面的例子也可以看到，生成器函数跟普通的函数是有很大差别的。结合上面的例子我们加入一些打印信息，进一步看看生成器的执行流程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_range</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始迭代...&#x27;</span>)</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;迭代中...&#x27;</span>)</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;迭代结束...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_range = my_range(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># print(my_range)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_range))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_range))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(my_range))</span><br></pre></td></tr></table></figure>
<p>通过结果可以看到：</p>
<ol>
<li>
<p>当调用生成器函数的时候，函数只是返回了一个生成器对象，并没有执行。</p>
</li>
<li>
<p>当<code>next()</code>方法第一次被调用的时候，生成器函数才开始执行，执行到<code>yield</code>语句处停止: <code>next()</code>方法的返回值就是<code>yield</code>语句处的参数<code>yielded value</code></p>
</li>
<li>
<p>当继续调用<code>next()</code>方法的时候，函数将接着上一次停止的<code>yield</code>语句处继续执行，并到下一个<code>yield</code>处停止；如果后面没有<code>yield</code>就抛出<code>StopIteration</code>异常</p>
</li>
</ol>
<h4 id="生成器表达式">生成器表达式</h4>
<p>在开始介绍生成器表达式之前，先看看我们比较熟悉的列表解析<code>[List comprehensions]</code>，列表解析一般都是下面的形式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[expr <span class="keyword">for</span> iter_var <span class="keyword">in</span> iterable <span class="keyword">if</span> cond_expr]</span><br></pre></td></tr></table></figure>
<p>迭代<code>iterable</code>里所有内容，每一次迭代后，把<code>iterable</code>里满足<code>cond_expr</code>条件的内容放到<code>iter_var</code>中，再在表达式<code>expr</code>中获取<code>iter_var</code>的内容，最后用表达式的计算值生成一个列表。</p>
<p>例如，生成一个<code>list</code>包含50以内的所有奇数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>) <span class="keyword">if</span> i % <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>生成器表达式是在<code>python2.4</code>中引入的，当序列过长， 而每次只需要获取一个元素时，应当考虑使用生成器表达式而不是列表解析。生成器表达式的语法和列表解析一样，只不过生成器表达式是被<code>()</code>括起来的，而不是<code>[]</code>，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(expr <span class="keyword">for</span> iter_var <span class="keyword">in</span> iterable <span class="keyword">if</span> cond_expr)</span><br></pre></td></tr></table></figure>
<p>生成器表达式并不是创建一个列表， 而是返回一个生成器，这个生成器在每次计算出一个条目后，把这个条目&quot;产生&quot;<code>(yield)</code>出来。 生成器表达式使用了&quot;惰性计算&quot;<code>(lazy evaluation)</code>，只有在检索时才被赋值<code>(evaluated)</code>，所以在列表比较长的情况下使用生成器会在内存上更有效。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gen = (i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000</span>) <span class="keyword">if</span> i % <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__iter__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(gen))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;__next__&quot;</span> <span class="keyword">in</span> <span class="built_in">dir</span>(gen))</span><br><span class="line"><span class="comment"># 使用 sum 求和之后会导致再次迭代所获取的值为空</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sum</span>(gen))</span><br><span class="line"><span class="built_in">print</span>([i <span class="keyword">for</span> i <span class="keyword">in</span> gen])</span><br></pre></td></tr></table></figure>
<h4 id="生成器中的send-与close-方法">生成器中的<code>send()</code>与<code>close()</code>方法</h4>
<p>生成器中还有两个很重要的方法：<code>send()</code>和<code>close()</code>。</p>
<ul>
<li>
<p><code>send(value)</code>:</p>
<p>从前面了解到，<code>next()</code>方法可以恢复生成器状态并继续执行，其实<code>send()</code>是除<code>next()</code>外另一个恢复生成器的方法。</p>
<p><code>Python 2.5</code>中，<code>yield</code>语句变成了<code>yield</code>表达式，也就是说<code>yield</code>可以有一个值，而这个值就是<code>send()</code>方法的参数，所以<code>send(None)</code>和<code>next()</code>是等效的。同样，<code>next()</code>和<code>send()</code>的返回值都是<code>yield</code>语句处的参数<code>(yielded value)</code></p>
<p>关于<code>send()</code>方法需要注意的是：调用<code>send</code>传入非<code>None</code>值前，生成器必须处于挂起状态，否则将抛出异常。也就是说，第一次调用时，要使用<code>next()</code>语句或<code>send(None)</code>，因为没有<code>yield</code>语句来接收这个值。</p>
</li>
<li>
<p><code>close()</code>:</p>
<p>这个方法用于关闭生成器，对关闭的生成器后再次调用<code>next</code>或<code>send</code>将抛出<code>StopIteration</code>异常。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_range</span>(<span class="params">n</span>):</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        val = <span class="keyword">yield</span> i</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;val is: &#x27;</span>, val)</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_range = my_range(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_range.__next__())</span><br><span class="line"><span class="built_in">print</span>(my_range.__next__())</span><br><span class="line"><span class="built_in">print</span>(my_range.send(<span class="string">&#x27;hello&#x27;</span>))</span><br><span class="line">my_range.close()</span><br><span class="line"><span class="built_in">print</span>(my_range.send(<span class="string">&#x27;world&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>总结：</p>
<ul>
<li>生成器是一种特殊的迭代器，内部支持了生成器协议，不需要明确定义<code>__iter__()</code>和<code>__next__()</code>方法。</li>
<li>生成器通过生成器函数产生，生成器函数可以通过常规的def语句来定义，但是不用<code>return</code>返回，而是用<code>yield</code>一次返回一个结果。</li>
</ul>
<h3 id="3-闭包">3. 闭包</h3>
<h4 id="引入-8">引入</h4>
<p>想想看怎样用程序实现下面的功能呢？</p>
<p>在一个聊天软件中显示是谁发送了这条信息，即：一条信息标记了是谁发送的</p>
<p>今天我们要研究的知识点是<code>闭包</code>，实现上述功能的方式可能有多种，但是闭包会更简单。</p>
<h4 id="问题解决">问题解决</h4>
<blockquote>
<p>普通方式</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">user_name, content</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(%s):%s&quot;</span> % (user_name, content))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">user_name1 = <span class="string">&quot;安娜&quot;</span></span><br><span class="line">user_name2 = <span class="string">&quot;双双&quot;</span></span><br><span class="line"></span><br><span class="line">say(user_name1, <span class="string">&quot;今天吃了么？&quot;</span>)</span><br><span class="line">say(user_name2, <span class="string">&quot;吃了~&quot;</span>)</span><br><span class="line"></span><br><span class="line">say(user_name1, <span class="string">&quot;吃了啥？&quot;</span>)</span><br><span class="line">say(user_name2, <span class="string">&quot;半只牛~&quot;</span>)</span><br><span class="line"></span><br><span class="line">say(user_name1, <span class="string">&quot;为啥不给我吃？&quot;</span>)</span><br><span class="line">say(user_name2, <span class="string">&quot; 我一个人刚刚好~~&quot;</span>)</span><br><span class="line"></span><br><span class="line">say(user_name1, <span class="string">&quot;友谊的小船说翻就翻！&quot;</span>)</span><br><span class="line">say(user_name2, <span class="string">&quot; 我会游泳~~~&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行效果如下：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(安娜): 今天吃了么？</span><br><span class="line">(双双): 吃了~</span><br><span class="line">(安娜): 吃了啥？</span><br><span class="line">(双双): 半只牛~</span><br><span class="line">(安娜): 为啥不给我吃？</span><br><span class="line">(双双): 我一个人刚刚好~~</span><br><span class="line">(安娜): 友谊的小船说翻就翻！</span><br><span class="line">(双双): 我会游泳~~~</span><br></pre></td></tr></table></figure>
<p>小总结：</p>
<ul>
<li>上述代码已经实现了要求，但是每次发送信息时需要将用户名称传递到<code>say</code>函数中，相对比较麻烦</li>
</ul>
<blockquote>
<p>面向对象的方式解决上述问题</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.user_name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">self, content</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;(%s):%s&quot;</span> % (<span class="variable language_">self</span>.user_name, content))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = Person(<span class="string">&quot;安娜&quot;</span>)</span><br><span class="line">p2 = Person(<span class="string">&quot;双双&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1.say(<span class="string">&quot;今天吃了么？&quot;</span>)</span><br><span class="line">p2.say(<span class="string">&quot;吃了~&quot;</span>)</span><br><span class="line">p1.say(<span class="string">&quot;吃了啥？&quot;</span>)</span><br><span class="line">p2.say(<span class="string">&quot;半只牛~&quot;</span>)</span><br><span class="line">p1.say(<span class="string">&quot;为啥不给我吃？&quot;</span>)</span><br><span class="line">p2.say(<span class="string">&quot; 我一个人刚刚好~~&quot;</span>)</span><br><span class="line">p1.say(<span class="string">&quot;友谊的小船说翻就翻！&quot;</span>)</span><br><span class="line">p2.say(<span class="string">&quot; 我会游泳~~~&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(安娜): 今天吃了么？</span><br><span class="line">(双双): 吃了~</span><br><span class="line">(安娜): 吃了啥？</span><br><span class="line">(双双): 半只牛~</span><br><span class="line">(安娜): 为啥不给我吃？</span><br><span class="line">(双双): 我一个人刚刚好~~</span><br><span class="line">(安娜): 友谊的小船说翻就翻！</span><br><span class="line">(双双): 我会游泳~~~</span><br></pre></td></tr></table></figure>
<p>小总结：</p>
<ul>
<li>通过面向对象的方式能够实现上述要求，但是发现使用了类以及对象，总体感觉还是较为复杂，再者说继承的object类中有很多默认的方法，既然这个程序不需要，显然会造成一定的浪费</li>
</ul>
<blockquote>
<p>使用闭包解决上述问题</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">content</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;(%s):%s&quot;</span> % (name, content))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> say</span><br><span class="line"></span><br><span class="line">p1 = person(<span class="string">&quot;安娜&quot;</span>)</span><br><span class="line">p2 = person(<span class="string">&quot;双双&quot;</span>)</span><br><span class="line"></span><br><span class="line">p1(<span class="string">&quot;今天吃了么？&quot;</span>)</span><br><span class="line">p2(<span class="string">&quot;吃了~&quot;</span>)</span><br><span class="line">p1(<span class="string">&quot;吃了啥？&quot;</span>)</span><br><span class="line">p2(<span class="string">&quot;半只牛~&quot;</span>)</span><br><span class="line">p1(<span class="string">&quot;为啥不给我吃？&quot;</span>)</span><br><span class="line">p2(<span class="string">&quot; 我一个人刚刚好~~&quot;</span>)</span><br><span class="line">p1(<span class="string">&quot;友谊的小船说翻就翻！&quot;</span>)</span><br><span class="line">p2(<span class="string">&quot; 我会游泳~~~&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="函数引用">函数引用</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义函数可以理解为：</span></span><br><span class="line"><span class="comment"># 定义了一个全局变量，其变量名字是函数的名字，即 test</span></span><br><span class="line"><span class="comment"># 这个 test 变量指向了一个代码块，这个代码块是函数</span></span><br><span class="line"><span class="comment"># 其实就是说 test 保存了一个代码块的地址，即引用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--- in test func----&quot;</span>)</span><br><span class="line"></span><br><span class="line">test()  <span class="comment"># 这是调用函数</span></span><br><span class="line"></span><br><span class="line">ret = test <span class="comment"># 用另外一个变量 复制了 test 这个引用，导致 ret 变量也指向那个 函数代码块</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面输出的 2 个地址信息是相同的</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(ret))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(test))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过引用调用函数</span></span><br><span class="line">ret()</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--- <span class="keyword">in</span> test func----</span><br><span class="line"><span class="number">140212571149040</span></span><br><span class="line"><span class="number">140212571149040</span></span><br><span class="line">--- <span class="keyword">in</span> test func----</span><br></pre></td></tr></table></figure>
<h4 id="闭包的概念">闭包的概念</h4>
<p>闭包(closure) 定义非常抽象，很难看懂</p>
<p>下面尝试从概念上去理解一下闭包：</p>
<ul>
<li>在一些语言中，在函数中可以（嵌套）定义另一个函数时，如果内部的函数引用了外部的函数的变量，则可能产生闭包。闭包可以用来在一个函数与一组“私有”变量之间创建关联关系。在给定函数被多次调用的过程中，这些私有变量能够保持其持久性。 —— 维基百科<code>https://zh.wikipedia.org/wiki/闭包_(计算机科学)</code></li>
</ul>
<p>用比较容易懂的人话说：就是当某个函数被当成对象返回时，夹带了外部变量，就形成了一个闭包。可以这样理解，闭包就是能够读取其他函数内部变量的函数</p>
<p>看如下案例，便于理解什么是闭包：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">make_printer</span>(<span class="params">msg</span>):  <span class="comment"># 可以认为是 外部函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">printer</span>():  <span class="comment"># 可以认为是 内部函数</span></span><br><span class="line">        <span class="built_in">print</span>(msg)</span><br><span class="line">    <span class="keyword">return</span> printer  <span class="comment"># 返回的内部函数的引用</span></span><br><span class="line"></span><br><span class="line">printer = make_printer(<span class="string">&#x27;Good!&#x27;</span>)</span><br><span class="line">printer()</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Good</span><br></pre></td></tr></table></figure>
<h4 id="闭包案例">闭包案例</h4>
<p>代码示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">number</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_in</span>(<span class="params">number_in</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;in test_in 函数, number_in is %d&quot;</span> % number_in)</span><br><span class="line">        <span class="keyword">return</span> number + number_in</span><br><span class="line">    <span class="keyword">return</span> test_in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给 test 函数赋值，这个 20 就是给参数 number</span></span><br><span class="line">ret = test(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里的 100 其实给参数 number_in</span></span><br><span class="line"><span class="built_in">print</span>(ret(<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这里的 200 其实给参数 number_in</span></span><br><span class="line"><span class="built_in">print</span>(ret(<span class="number">200</span>))</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">in test_in 函数, number_in is 100</span><br><span class="line">120</span><br><span class="line">in test_in 函数, number_in is 200</span><br><span class="line">220</span><br></pre></td></tr></table></figure>
<h4 id="使用闭包需要注意的问题">使用闭包需要注意的问题</h4>
<p>由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。因此可以手动解除对匿名函数的引用，以便释放内存。</p>
<h4 id="使用闭包修改外部函数中的变量">使用闭包修改外部函数中的变量</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">counter</span>(<span class="params">start = <span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add_one</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> start  <span class="comment"># nonlocal 关键字用于在嵌套函数内部使用变量，其中变量不应属于内部函数。</span></span><br><span class="line">        start += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> start</span><br><span class="line">    <span class="keyword">return</span> add_one</span><br><span class="line"></span><br><span class="line">c1 = counter(<span class="number">5</span>)  <span class="comment"># 创建一个闭包</span></span><br><span class="line"><span class="built_in">print</span>(c1())</span><br><span class="line"><span class="built_in">print</span>(c1())</span><br><span class="line"></span><br><span class="line">c2 = counter(<span class="number">50</span>)  <span class="comment"># 创建另外一个闭包</span></span><br><span class="line"><span class="built_in">print</span>(c2())</span><br><span class="line"><span class="built_in">print</span>(c2())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c1())</span><br><span class="line"><span class="built_in">print</span>(c1())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(c2())</span><br><span class="line"><span class="built_in">print</span>(c2())</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">7</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td></tr></table></figure>
<h4 id="多个闭包">多个闭包</h4>
<p>如上面的代码中，调用了2次<code>counter</code>，也就意味着创建了2个闭包，并且每个闭包之间没有任何关系。</p>
<p>大家是否有种感觉，好像闭包与对象有些类似。确实是这样的，对象其实可通俗的理解为数据(属性) + 功能(方法)，而闭包也可以理解为数据 + 功能，<strong>只不过此时数据是外部函数中的那些局部变量或者形参，而功能则是内部函数</strong>。对象适合完成较为复杂的功能，而闭包则更轻量</p>
<h4 id="闭包总结">闭包总结</h4>
<ol>
<li>闭包定义是在函数内再嵌套函数</li>
<li>闭包是可以访问另一个函数局部作用域中变量的函数</li>
<li>闭包可以读取另外一个函数内部的变量</li>
<li>闭包可以让参数和变量不会被垃圾回收机制回收，始终保持在内存中（而普通的函数调用结束后 会被Python解释器自动释放局部变量）</li>
</ol>
<h3 id="4-装饰器">4. 装饰器</h3>
<p>装饰器是python语言中的语法糖，可以通过装饰器对函数的功能进行拓展。</p>
<h4 id="为什么需要装饰器">为什么需要装饰器</h4>
<p>我们假设你的程序实现了<code>say_hello()</code>和<code>say_goodbye()</code>两个函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_goodbye</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello!&quot;</span>)  <span class="comment"># 此处应打印 goodbye</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    say_hello()</span><br><span class="line">    say_goodbye()</span><br></pre></td></tr></table></figure>
<p>假设上述代码中的say_goodbye函数出现了bug，为了之后能更好的维护，现在需要在调用方法前记录函数调用名称，以定位出错位置。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[DEBUG]: Enter say_hello()</span><br><span class="line">Hello!</span><br><span class="line"></span><br><span class="line">[DEBUG]: Enter say_goodbye()</span><br><span class="line">Goodbye!</span><br></pre></td></tr></table></figure>
<p>实现方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]: enter say_hello()&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; hello!&quot;</span>) </span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_goodbye</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;[DEBUG]: enter say_goodbye()&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; hello!&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    say_hello()</span><br><span class="line">    say_goodbye()</span><br></pre></td></tr></table></figure>
<p>对上述代码进行优化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    <span class="keyword">import</span> inspect</span><br><span class="line">    caller_name = inspect.stack()[<span class="number">1</span>][<span class="number">3</span>]  <span class="comment"># 可以返回函数名与当前函数的返回值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; [DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(caller_name))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    debug()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_goodbye</span>():</span><br><span class="line">    debug()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;goodbye!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    say_hello()</span><br><span class="line">    say_goodbye()</span><br></pre></td></tr></table></figure>
<p>上述代码需要在每个业务函数里都要调用一下<code>debug()</code>函数，是不是很难受？万一老板说say相关的函数不用debug，do相关的才需要呢？</p>
<p>那么装饰器这时候应该登场了。</p>
<blockquote>
<p>装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。</p>
</blockquote>
<p>概括的讲，装饰器的作用就是<strong>为已经存在的函数或对象添加额外的功能</strong>。</p>
<h4 id="如何实现一个装饰器">如何实现一个装饰器</h4>
<p>在早些时候 (Python Version &lt; 2.4，2004年以前)，为一个函数添加额外功能的写法是这样的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; [DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">say_hello = debug(say_hello)</span><br><span class="line"></span><br><span class="line">say_hello()</span><br></pre></td></tr></table></figure>
<p>上面的debug函数其实已经是一个装饰器了，它对原函数做了包装并返回了另外一个函数，额外添加了一些功能。因为这样写实在不太优雅，在后面版本的Python中支持了@语法糖，下面代码等同于早期的写法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; [DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">say_hello()</span><br></pre></td></tr></table></figure>
<p>这是最简单的装饰器，但是有一个问题，如果被装饰的函数需要传入参数，那么这个装饰器就坏了。因为返回的函数并不能接受参数，你可以指定装饰器函数<code>wrapper</code>接受和原函数一样的参数，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">something</span>):  <span class="comment"># 指定一毛一样的参数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; [DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func(something)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper  <span class="comment"># 返回包装过函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">something</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello &#123;&#125;!&quot;</span>.<span class="built_in">format</span>(something))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">say(<span class="string">&#x27;顾安&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这样你就解决了一个问题，但又多了N个问题。因为函数有千千万，你只管你自己的函数，别人的函数参数是什么样子，鬼知道？还好Python提供了可变参数<code>*args</code>和关键字参数<code>**kwargs</code>，有了这两个参数，装饰器就可以用于任意目标函数了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; [DEBUG]: enter &#123;&#125;()&quot;</span>.<span class="built_in">format</span>(func.__name__))</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">something</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello &#123;&#125;!&quot;</span>.<span class="built_in">format</span>(something))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">say(<span class="string">&#x27;顾安&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="带参数的装饰器">带参数的装饰器</h4>
<p>假设我们前文的装饰器需要完成的功能不仅仅是能在进入某个函数后打出log信息，而且还需指定log的级别，那么装饰器就会是这样的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">logging</span>(<span class="params">level</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">inner_wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot; [&#123;level&#125;]: enter function &#123;func&#125;()&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                level = level,</span><br><span class="line">                func = func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> inner_wrapper</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(<span class="params">level =<span class="string">&#x27;INFO&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">something</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;say &#123;&#125;!&quot;</span>.<span class="built_in">format</span>(something))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有使用@语法，等同于</span></span><br><span class="line"><span class="comment"># say = logging(level =&#x27;INFO&#x27;)(say)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@logging(<span class="params">level =<span class="string">&#x27;DEBUG&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do</span>(<span class="params">something</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;do &#123;&#125;...&quot;</span>.<span class="built_in">format</span>(something))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    say(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    do(<span class="string">&quot;my work&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>是不是有一些晕？你可以这么理解，当带参数的装饰器被打在某个函数上时，比如<code>@logging(level='DEBUG')</code>，它其实是一个函数，会马上被执行，只要它返回的结果是一个装饰器时，那就没问题。细细再体会一下。</p>
<h4 id="基于类的装饰器">基于类的装饰器</h4>
<p>装饰器函数其实是这样一个接口约束，它必须接受一个callable对象作为参数，然后返回一个callable对象。在Python中一般callable对象都是函数，但也有例外。只要某个对象重载了<code>__call__()</code>方法，那么这个对象就是callable的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;call me!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = Test()</span><br><span class="line">t()  <span class="comment"># call me</span></span><br></pre></td></tr></table></figure>
<p>像<code>__call__</code>这样前后都带下划线的方法在Python中被称为内置方法，有时候也被称为魔法方法。重载这些魔法方法一般会改变对象的内部行为。上面这个例子就让一个类对象拥有了被调用的行为。</p>
<p>回到装饰器上的概念上来，装饰器要求接受一个callable对象，并返回一个callable对象。那么用类来实现也是也可以的。我们可以让类的构造函数<code>__init__()</code>接受一个函数，然后重载<code>__call__()</code>并返回一个函数，也可以达到装饰器函数的效果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logging</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        <span class="variable language_">self</span>.func = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, *args, **kwargs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; [DEBUG]: enter function &#123;func&#125;()&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">            func = <span class="variable language_">self</span>.func.__name__))</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Logging</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">something</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;say &#123;&#125;!&quot;</span>.<span class="built_in">format</span>(something))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">say(<span class="string">&#x27;木木&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="带参数的类装饰器">带参数的类装饰器</h4>
<p>如果需要通过类形式实现带参数的装饰器，那么会比前面的例子稍微复杂一点。那么在构造函数里接收的就不是一个函数，而是传入的参数。通过类把这些参数保存起来。然后在重载<code>__call__</code>方法是就需要接收一个函数并返回一个函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Logging</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, level =<span class="string">&#x27;INFO&#x27;</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.level = level</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, func</span>):  <span class="comment"># 接收函数</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot; [&#123;level&#125;]: enter function &#123;func&#125;()&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">                level = <span class="variable language_">self</span>.level,</span><br><span class="line">                func = func.__name__))</span><br><span class="line">            func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrapper  <span class="comment"># 返回函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Logging(<span class="params">level =<span class="string">&#x27;INFO&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>(<span class="params">something</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;say &#123;&#125;!&quot;</span>.<span class="built_in">format</span>(something))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">say(<span class="string">&#x27;木木&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="property属性"><code>property</code>属性</h3>
<h4 id="property-简介"><code>@property</code> - 简介</h4>
<p>什么是property属性？</p>
<p>一种用起来像是使用的实例属性一样的特殊属性，可以对应于某个方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义 property 属性</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">      </span><br><span class="line">foo_obj = Foo()</span><br><span class="line">foo_obj.func()  <span class="comment"># 调用实例方法</span></span><br><span class="line">foo_obj.prop  <span class="comment"># 调用 property 属性</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span>:</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">money</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">goods = Goods()</span><br><span class="line"><span class="built_in">print</span>(goods.money)</span><br></pre></td></tr></table></figure>
<p>property属性的定义和调用要注意一下几点：</p>
<ul>
<li>定义时，在实例方法的基础上添加 @property 装饰器；并且仅有一个self参数</li>
<li>调用时，无需括号</li>
</ul>
<h4 id="简单的示例">简单的示例</h4>
<p>对于京东商城中显示电脑主机的列表页面，每次请求不可能把数据库中的所有内容都显示到页面上，而是通过分页的功能局部显示，所以在向数据库中请求数据时就要显示的指定获取从第m条到第n条的所有数据 这个分页的功能包括：</p>
<ul>
<li>根据用户请求的当前页和总数据条数计算出 m 和 n</li>
<li>根据m 和 n 去数据库中请求数据</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, current_page</span>):</span><br><span class="line">        <span class="comment"># 用户当前请求的页码（第一页、第二页...）</span></span><br><span class="line">        <span class="variable language_">self</span>.current_page = current_page</span><br><span class="line">        <span class="comment"># 每页默认显示 10 条数据</span></span><br><span class="line">        <span class="variable language_">self</span>.per_items = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">start</span>(<span class="params">self</span>):</span><br><span class="line">        val = (<span class="variable language_">self</span>.current_page - <span class="number">1</span>) * <span class="variable language_">self</span>.per_items</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">end</span>(<span class="params">self</span>):</span><br><span class="line">        val = <span class="variable language_">self</span>.current_page * <span class="variable language_">self</span>.per_items</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ########## 调用 ##########</span></span><br><span class="line">p = Pager(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(p.start)  <span class="comment"># 就是起始值，即：m</span></span><br><span class="line"><span class="built_in">print</span>(p.end)  <span class="comment"># 就是结束值，即：n</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Python的property属性的功能是：property属性内部进行一系列的逻辑计算，最终将计算结果返回。</li>
</ul>
<h4 id="property属性的两种方式">property属性的两种方式</h4>
<ul>
<li>装饰器 即：在方法上应用装饰器</li>
<li>类属性 即：在类中定义值为property对象的类属性</li>
</ul>
<blockquote>
<p>装饰器方式</p>
</blockquote>
<p>在类的实例方法上应用@property装饰器</p>
<p>Python中的类有<code>经典类</code>和<code>新式类</code>，<code>新式类</code>的属性比<code>经典类</code>的属性丰富。（ 如果类继object，那么该类是新式类 ）</p>
<p>经典类，具有一种@property装饰器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span>:</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">obj = Goods()</span><br><span class="line">result = obj.price  <span class="comment"># 自动执行 @property 修饰的 price 方法，并获取方法的返回值</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<p>新式类，具有三种@property装饰器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;@property&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @price.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">price</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;@price.setter&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @price.deleter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;@price.deleter&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Goods()</span><br><span class="line"><span class="built_in">print</span>(obj.price)   <span class="comment"># 自动执行 @property 修饰的 price 方法，并获取方法的返回值</span></span><br><span class="line">obj.price = <span class="number">123</span>    <span class="comment"># 自动执行 @price.setter 修饰的 price 方法，并将  123 赋值给方法的参数</span></span><br><span class="line"><span class="keyword">del</span> obj.price      <span class="comment"># 自动执行 @price.deleter 修饰的 price 方法</span></span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>经典类中的属性只有一种访问方式，其对应被 @property 修饰的方法</li>
<li>新式类中的属性有三种访问方式，并分别对应了三个被@property、@方法名.setter、@方法名.deleter修饰的方法</li>
</ul>
<p>由于新式类中具有三种访问方式，我们可以根据它们几个属性的访问特点，分别将三个方法定义为对同一个属性：获取、修改、删除</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 原价</span></span><br><span class="line">        <span class="variable language_">self</span>.original_price = <span class="number">100</span></span><br><span class="line">        <span class="comment"># 折扣</span></span><br><span class="line">        <span class="variable language_">self</span>.discount = <span class="number">0.8</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 实际价格 = 原价 * 折扣</span></span><br><span class="line">        new_price = <span class="variable language_">self</span>.original_price * <span class="variable language_">self</span>.discount</span><br><span class="line">        <span class="keyword">return</span> new_price</span><br><span class="line"></span><br><span class="line"><span class="meta">    @price.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">price</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="variable language_">self</span>.original_price = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @price.deleter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">del</span> <span class="variable language_">self</span>.original_price</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Goods()</span><br><span class="line"><span class="built_in">print</span>(obj.price)  <span class="comment"># 获取商品价格</span></span><br><span class="line">obj.price = <span class="number">200</span>  <span class="comment"># 修改商品原价</span></span><br><span class="line"><span class="built_in">print</span>(obj.price)</span><br><span class="line"><span class="keyword">del</span> obj.price  <span class="comment"># 删除商品原价</span></span><br><span class="line"><span class="comment"># 当前属性被删除之后再获取则报错</span></span><br><span class="line"><span class="comment"># print(obj.price)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>类属性方式，创建值为property对象的类属性</p>
</blockquote>
<ul>
<li>当使用类属性的方式创建property属性时，<code>经典类</code>和<code>新式类</code>无区别</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    price = <span class="built_in">property</span>(get_price)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Goods()</span><br><span class="line">result = obj.price  <span class="comment"># 自动调用 get_price 方法，并获取方法的返回值</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure>
<p>property方法中有个四个参数</p>
<ul>
<li>第一个参数是方法名，调用 对象.属性 时自动触发执行方法</li>
<li>第二个参数是方法名，调用 对象.属性 ＝ XXX 时自动触发执行方法</li>
<li>第三个参数是方法名，调用 del 对象.属性 时自动触发执行方法</li>
<li>第四个参数是字符串，调用 对象.属性.__doc__ ，此参数是该属性的描述信息</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_bar</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;getter...&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;a...&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_bar</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="string">&quot;&quot;</span> <span class="string">&quot;必须两个参数&quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;setter:&quot;</span>, value)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;set value&#x27;</span> + value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">del_bar</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;deleter...&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;b...&#x27;</span></span><br><span class="line"></span><br><span class="line">    BAR = <span class="built_in">property</span>(get_bar, set_bar, del_bar, <span class="string">&quot;description...&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Foo()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(obj.BAR)  <span class="comment"># 自动调用第一个参数中定义的方法：get_bar</span></span><br><span class="line">obj.BAR = <span class="string">&quot;c&quot;</span>  <span class="comment"># 自动调用第二个参数中定义的方法：set_bar 方法，并将“c”当作参数传入</span></span><br><span class="line">desc = Foo.BAR.__doc__  <span class="comment"># 自动获取第四个参数中设置的值：description...</span></span><br><span class="line"><span class="built_in">print</span>(desc)</span><br><span class="line"><span class="keyword">del</span> obj.BAR  <span class="comment"># 自动调用第三个参数中定义的方法：del_bar 方法</span></span><br></pre></td></tr></table></figure>
<p>由于<code>类属性方式</code>创建property属性具有3种访问方式，我们可以根据它们几个属性的访问特点，分别将三个方法定义为对同一个属性：获取、修改、删除</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Goods</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 原价</span></span><br><span class="line">        <span class="variable language_">self</span>.original_price = <span class="number">100</span></span><br><span class="line">        <span class="comment"># 折扣</span></span><br><span class="line">        <span class="variable language_">self</span>.discount = <span class="number">0.8</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 实际价格 = 原价 * 折扣</span></span><br><span class="line">        new_price = <span class="variable language_">self</span>.original_price * <span class="variable language_">self</span>.discount</span><br><span class="line">        <span class="keyword">return</span> new_price</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_price</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="variable language_">self</span>.original_price = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">del_price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">del</span> <span class="variable language_">self</span>.original_price</span><br><span class="line"></span><br><span class="line">    PRICE = <span class="built_in">property</span>(get_price, set_price, del_price, <span class="string">&#x27;价格属性描述...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = Goods()</span><br><span class="line"><span class="built_in">print</span>(obj.PRICE)  <span class="comment"># 获取商品价格</span></span><br><span class="line">obj.PRICE = <span class="number">200</span>  <span class="comment"># 修改商品原价</span></span><br><span class="line"><span class="built_in">print</span>(obj.PRICE)</span><br><span class="line"><span class="keyword">del</span> obj.PRICE  <span class="comment"># 删除商品原价</span></span><br></pre></td></tr></table></figure>
<h4 id="property-应用"><code>@property</code> - 应用</h4>
<ul>
<li>私有属性添加getter和setter方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Money</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.__money = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_money</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__money</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_money</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="variable language_">self</span>.__money = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;error: 不是整型数字&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">money = Money()</span><br><span class="line"><span class="built_in">print</span>(money.get_money())</span><br><span class="line">money.set_money(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(money.get_money())</span><br></pre></td></tr></table></figure>
<ul>
<li>使用property升级getter和setter方法</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Money</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.__money = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_money</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__money</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_money</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="variable language_">self</span>.__money = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;error: 不是整型数字&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义一个属性，当对这个 money 设置值时调用 setMoney, 当获取值时调用 getMoney</span></span><br><span class="line">    money = <span class="built_in">property</span>(get_money, set_money)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">money_obj = Money()</span><br><span class="line">money_obj.money = <span class="number">100</span>  <span class="comment"># 调用 setMoney 方法</span></span><br><span class="line"><span class="built_in">print</span>(money_obj.money)  <span class="comment"># 调用 getMoney 方法</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用property取代getter和setter方法
<ul>
<li>重新实现一个属性的设置和读取方法,可做边界判定</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Money</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.__money = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用装饰器对 money 进行装饰，那么会自动添加一个叫 money 的属性，当调用获取 money 的值时，调用装饰的方法</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">money</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__money</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用装饰器对 money 进行装饰，当对 money 设置值时，调用装饰的方法</span></span><br><span class="line"><span class="meta">    @money.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">money</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="variable language_">self</span>.__money = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;error: 不是整型数字&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">money_obj = Money()</span><br><span class="line">money_obj.money = <span class="number">100</span></span><br><span class="line"><span class="built_in">print</span>(money_obj.money)</span><br></pre></td></tr></table></figure>
<h2 id="线程">线程</h2>
<p>本章将介绍Python中的多线程编程。多线程一直是Python学习中的重点和难点，需要反复练习和研究。</p>
<p><strong>易错点</strong></p>
<ul>
<li>在多线程中，线程的target是引用，不要再写括号了；任务队列不要忘了用task_done()</li>
<li>在协程中，注意最后await asynciio.wait(tasks_list) 要写在循环外面
<ul>
<li><code>tasks_list = []</code>的创建最好在for循环的外面</li>
</ul>
</li>
</ul>
<h3 id="线程和进程">线程和进程</h3>
<p>在学习多线程的使用之前，需要先了解线程、进程的概念。</p>
<h4 id="进程">进程</h4>
<p>进程（Process，有时被称为重量级进程）是程序的一次执行。每个进程都有自己的地址空间、内存、数据栈以及记录运行轨迹的辅助数据，操作系统管理运行的所有进程，并为这些进程公平分配时间。进程可以通过fork和spawn操作完成其他任务。</p>
<p>因为各个进程有自己的内存空间、数据栈等，<strong>所以只能使用进程间通信（Inter Process Communication, IPC），而不能直接共享信息。</strong></p>
<h4 id="线程-2">线程</h4>
<p>线程（Thread，有时被称为轻量级进程）跟进程有些相似，不同的是所有线程运行在同一个进程中，<strong>共享运行环境。</strong></p>
<p>线程有开始、顺序执行和结束3部分，有一个自己的指令指针，记录运行到什么地方。线程的运行可能被抢占（中断）或暂时被挂起（睡眠），从而让其他线程运行，这叫作让步。</p>
<p>一个进程中的各个线程之间共享同一块数据空间，所以线程之间可以比进程之间更方便地共享数据和相互通信。</p>
<p>线程一般是并发执行的。正是由于这种并行和数据共享的机制，使得多个任务的合作变得可能。实际上，在单CPU系统中，真正的并行并不可能，每个线程会被安排成每次只运行一小会儿，然后就把CPU让出来，让其他线程运行。在进程的整个运行过程中，每个线程都只做自己的事，需要时再跟其他线程共享运行结果。多个线程共同访问同一块数据不是完全没有危险的，由于访问数据的顺序不一样，因此有可能导致数据结果不一致的问题，这叫作竞态条件。大多数线程库都带有一系列同步原语，用于控制线程的执行和数据的访问。</p>
<h4 id="对比">对比</h4>
<blockquote>
<p>一个工厂，<strong>至少</strong>有一个车间，一个车间中<strong>最少</strong>有一个工人，最终是工人在工作。</p>
<p>一个程序，<strong>至少</strong>有一个进程，一个进程中<strong>最少</strong>有一个线程，最终是线程在工作。</p>
</blockquote>
<blockquote>
<p>在一个车间中有最基本的工作工具，人通过操作工具的方式来完成工作。<br>
一个进程中有最基本的运行代码的资源(内存、cpu…)，线程通过进程中提供的资源来运行代码。</p>
</blockquote>
<blockquote>
<p>通过上述描述，我们来总结一下线程与进程的关系︰</p>
<ul>
<li>线程是计算机可以被cpu调度的最小单元（干活的）</li>
<li>进程是<strong>计算机分配资源</strong>的的最小单元（任务管理器里的），进程可以为线程提供运行资源。</li>
<li>一个进程中可以有多个线程，同一个进程中的线程可以共享当前进程中的资源。</li>
</ul>
</blockquote>
<h3 id="使用线程">使用线程</h3>
<p>本小节主要学习<code>Python</code>中的<code>threading</code>模块。</p>
<h4 id="全局解释器锁">全局解释器锁</h4>
<p>Python代码的执行由Python虚拟机（解释器主循环）控制。Python在设计之初就考虑到在主循环中只能有<strong>一个线程</strong>执行，虽然Python解释器中可以“运行”多个线程，但是在任意时刻只有一个线程在解释器中运行。</p>
<p>Python虚拟机的访问由全局解释器锁（Global Interpreter Lock, GIL）控制，这个锁能保证同一时刻只有一个线程运行。（保证线程安全）</p>
<p>在多线程环境中，Python虚拟机按以下方式执行：</p>
<ol>
<li>设置GIL。</li>
<li>切换到一个线程运行。</li>
<li>运行指定数量的字节码指令或线程主动让出控制（可以调用time.sleep(0)）。</li>
<li>把线程设置为睡眠状态。</li>
<li>解锁GIL。</li>
<li>再次重复以上所有步骤。</li>
</ol>
<p>在调用外部代码（如C/C++扩展函数）时，GIL将被锁定，直到这个函数结束为止（由于在此期间没有运行Python的字节码，因此不会做线程切换），编写扩展的程序员可以主动解锁GIL。</p>
<h4 id="多任务的概念">多任务的概念</h4>
<p>什么叫 “多任务” 呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。</p>
<p>现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？</p>
<p>答案就是: <strong>操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。</strong></p>
<p>真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>并发：指的是任务数多余cpu核数，通过操作系统的各种任务调度算法，实现用多个任务“一起”执行（实际上总有一些任务不在执行，因为切换任务的速度相当快，看上去一起执行而已）</li>
<li>并行：指的是任务数小于等于cpu核数，即任务真的是一起执行的。</li>
</ul>
<h4 id="threading-模块的使用">threading 模块的使用</h4>
<p>单线程代码示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        print_hello()</span><br></pre></td></tr></table></figure>
<p>多线程代码示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading  <span class="comment"># 线程标准库</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建线程对象（主线程创建的），不会执行任务</span></span><br><span class="line">    t = threading.Thread(target = print_hello)  <span class="comment"># 没有(), 将函数引用传递给这个类</span></span><br><span class="line">    <span class="comment"># 启动线程对象（启动子线程）</span></span><br><span class="line">    t.start()  </span><br></pre></td></tr></table></figure>
<p><code>threading</code> 模块中常用的一些类和函数：</p>
<ul>
<li><code>Thread</code> 类：用于创建新的线程对象。</li>
<li><code>Lock</code> 类：用于创建锁对象，实现多线程之间的互斥。</li>
</ul>
<h4 id="主线程等待所有子线程结束后退出">主线程等待所有子线程结束后退出</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, ctime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sing</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;正在唱歌: <span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dance</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;正在跳舞: <span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;程序开始: <span class="subst">&#123;ctime()&#125;</span>&#x27;</span>)</span><br><span class="line">    t1 = threading.Thread(target = sing) </span><br><span class="line">    t2 = threading.Thread(target = dance)</span><br><span class="line">    <span class="comment"># 设置线程类型为守护线程：主线程完成最后一行代码会立刻退出，而不管守护线程是否完成</span></span><br><span class="line">    t1.daemon = <span class="literal">True</span> <span class="comment"># start()方法启动它之前</span></span><br><span class="line">    t2.daemon = <span class="literal">True</span> <span class="comment"># start()方法启动它之前</span></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    <span class="comment"># 注释下一行代码查看程序是否立即退出</span></span><br><span class="line">    <span class="comment"># sleep(5)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;程序结束: <span class="subst">&#123;ctime()&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当子线程任务没有完成的情况下，主线程会等待子线程任务完成之后才会释放系统资源(程序退出)</p>
</blockquote>
<h4 id="查看线程数量">查看线程数量</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, ctime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sing</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;正在唱歌: <span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dance</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;正在跳舞: <span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;程序开始: <span class="subst">&#123;ctime&#125;</span>&#x27;</span>)</span><br><span class="line">    t1 = threading.Thread(target = sing)</span><br><span class="line">    t2 = threading.Thread(target = dance)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        length = <span class="built_in">len</span>(threading.<span class="built_in">enumerate</span>())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;当前线程数量: <span class="subst">&#123;length&#125;</span>&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> length &lt;= <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<h4 id="线程执行代码的封装">线程执行代码的封装</h4>
<p>通过上一小节，能够看出，通过使用threading模块能完成多任务的程序开发，为了让每个线程的封装性更完美，所以使用<code>threading</code>模块时，往往会定义一个新的子类<code>class</code>，只要继承<code>threading.Thread</code>就可以了，然后重写<code>run</code>方法。</p>
<p>示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>(threading.Thread):</span><br><span class="line">    <span class="comment"># 运行绑定的任务</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># self.name 是 threading 模块中的一个方法 保存的是当前线程的名称</span></span><br><span class="line">            msg = <span class="string">&#x27;我是 &#x27;</span> + <span class="variable language_">self</span>.name + <span class="string">&#x27; @ &#x27;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">            <span class="built_in">print</span>(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 虽然在每次循环中都使用相同的变量名 t 来保存线程对象，这意味着在每次迭代结束时，旧的线程对象就会被新的线程对象覆盖。这本身并不会导致问题，因为线程一旦被启动，就会独立运行，不受此局部变量的影响。因此，虽然变量名相同，但在内存中创建的是不同的线程对象。因此，每次循环迭代都会创建一个新的线程对象，它们是不同的线程对象，而不是重用同一个线程对象。</span></span><br><span class="line">    t = MyThread()</span><br><span class="line">    t.start() <span class="comment"># 调用 start()方法会自动运行 run()方法</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong><code>python</code>的<code>threading.Thread</code>类有一个<code>run</code>方法，用于定义线程的功能函数，可以在自己的线程类中覆盖该方法。而创建自己的线程实例后，通过<code>Thread</code>类的<code>start</code>方法，可以启动该线程，交给<code>python</code>虚拟机进行调度，当该线程获得执行的机会时，就会调用<code>run</code>方法执行线程。</p>
<h4 id="线程的执行顺序">线程的执行顺序</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            msg = <span class="string">&#x27;我是 &#x27;</span> + <span class="variable language_">self</span>.name + <span class="string">&#x27; @ &#x27;</span> + <span class="built_in">str</span>(i)</span><br><span class="line">            <span class="built_in">print</span>(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        t = MyThread()</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    test()</span><br></pre></td></tr></table></figure>
<p>**说明：**从代码和执行结果我们可以看出，<strong>多线程程序的执行顺序是不确定的</strong>。当执行到<code>sleep</code>语句时，线程将被阻塞（Blocked），到<code>sleep</code>结束后，线程进入就绪（Runnable）状态，等待调度。而线程调度将自行选择一个线程执行。上面的代码中只能保证每个线程都运行完整个<code>run</code>函数，但是线程的启动顺序、<code>run</code>函数中每次循环的执行顺序都不能确定。</p>
<h4 id="总结">总结</h4>
<ol>
<li>每个线程默认有一个名字，尽管上面的例子中没有指定线程对象的<code>name</code>，但是<code>python</code>会自动为线程指定一个名字。</li>
<li><strong>当线程的<code>run()</code>方法结束时该线程完成。</strong></li>
<li>无法控制线程调度程序，但可以通过别的方式来影响线程调度的方式。</li>
</ol>
<h3 id="多线程-共享全局变量">多线程 - 共享全局变量</h3>
<h4 id="整型类型共享">整型类型共享</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">g_num = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work_1</span>():</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        <span class="comment"># 循环相加三次</span></span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(f <span class="string">&quot;子线程 1 中计算得出的值为: &#123;g_num&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work_2</span>():</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;子线程 2 中获取到的值为: <span class="subst">&#123;g_num&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 线程启动之前获取全局变量</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;子线程未启动之前主线程获取的值为: <span class="subst">&#123;g_num&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建线程对象</span></span><br><span class="line">    t1 = threading.Thread(target = work_1)</span><br><span class="line">    t1.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过延迟保证 t1 线程中的事情做完</span></span><br><span class="line">    <span class="comment"># time.sleep(0.1)</span></span><br><span class="line">    t1.join()  <span class="comment"># 如果在子线程对象中使用 join 那么会等待这个线程绑定的函数执行完毕之后主线程才会往下走，对其他子线程没影响，主线程阻塞（类似同步）；join()方法只对调用它的线程有阻塞效果，对其他线程没有影响（既主线程）。</span></span><br><span class="line"></span><br><span class="line">    t2 = threading.Thread(target = work_2)</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;主线程最终获取到的值为: <span class="subst">&#123;g_num&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="序列类型共享">序列类型共享</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">g_nums = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work_1</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="comment"># 在全局列表中添加一个元素</span></span><br><span class="line">    nums.append(<span class="number">44</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;子线程 1 添加完成之后的列表元素为: <span class="subst">&#123;nums&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work_2</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;子线程 2 获取的列表元素为: <span class="subst">&#123;nums&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># args =()用来传递该线程绑定的任务所需的参数</span></span><br><span class="line">    t1 = threading.Thread(target = work_1, args =(g_nums,))</span><br><span class="line">    t1.start()</span><br><span class="line">    <span class="comment"># 确保子线程 1 完成操作后再执行一下代码</span></span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    t2 = threading.Thread(target = work_2, args =(g_nums,))</span><br><span class="line">    t2.start()</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;主线程获取到的全局列表元素为: <span class="subst">&#123;g_nums&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<ul>
<li>在一个进程内的所有线程共享全局变量，很方便在多个线程间共享数据</li>
<li>缺点就是，线程是对全局变量随意更改可能造成多线程之间对全局变量的混乱（即线程非安全）</li>
</ul>
<h3 id="多线程-共享全局变量问题">多线程 - 共享全局变量问题</h3>
<ul>
<li><strong>多线程开发可能遇到的问题</strong></li>
</ul>
<p>假设两个线程<code>t1</code>和<code>t2</code>都要对全局变量<code>g_num</code>(默认是0)进行加1运算，<code>t1</code>和<code>t2</code>都各对<code>g_num</code>加10次，<code>g_num</code>的最终的结果应该为20。</p>
<p>但是由于是多线程同时操作，有可能出现下面情况：</p>
<ol>
<li>在<code>g_num=0</code>时，<code>t1</code>取得<code>g_num=0</code>。此时系统把<code>t1</code>调度为”sleeping”状态，把<code>t2</code>转换为”running”状态，<code>t2</code>也获得<code>g_num=0</code></li>
<li>然后<code>t2</code>对得到的值进行加1并赋给<code>g_num</code>，使得<code>g_num=1</code></li>
<li>然后系统又把<code>t2</code>调度为”sleeping”，把<code>t1</code>转为”running”。线程<code>t1</code>又把它之前得到的0加1后赋值给<code>g_num</code>。</li>
<li>这样导致虽然<code>t1</code>和<code>t2</code>都对<code>g_num</code>加1，但结果仍然是<code>g_num=1</code></li>
</ol>
<p>示例代码一：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work_1</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(f <span class="string">&quot;线程 1 计算的结果为: &#123;g_num&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work_2</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(f <span class="string">&quot;线程 2 计算的结果为: &#123;g_num&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(f <span class="string">&quot;线程创建之前 g_num 的值为: &#123;g_num&#125;&quot;</span>)</span><br><span class="line">    t1 = threading.Thread(target = work_1, args =(<span class="number">100</span>,))</span><br><span class="line">    t1.start()</span><br><span class="line"></span><br><span class="line">    t2 = threading.Thread(target = work_2, args =(<span class="number">100</span>,))</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待子线程任务执行完毕后再执行主线程代码</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(threading.<span class="built_in">enumerate</span>()) != <span class="number">1</span>:</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 或使用</span></span><br><span class="line">    <span class="comment"># t1.join()</span></span><br><span class="line">    <span class="comment"># t2.join()</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2 个线程对同一个全局变量操作之后的最终结果是:%s&quot;</span> % g_num)</span><br></pre></td></tr></table></figure>
<p>示例代码二：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work_1</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(f <span class="string">&quot;线程 1 计算的结果为: &#123;g_num&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work_2</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(f <span class="string">&quot;线程 2 计算的结果为: &#123;g_num&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(f <span class="string">&quot;线程创建之前 g_num 的值为: &#123;g_num&#125;&quot;</span>)</span><br><span class="line">    t1 = threading.Thread(target = work_1, args =(<span class="number">1000000</span>,))</span><br><span class="line">    t1.start()</span><br><span class="line"></span><br><span class="line">    t2 = threading.Thread(target = work_2, args =(<span class="number">1000000</span>,))</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待子线程任务执行完毕后再执行主线程代码</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(threading.<span class="built_in">enumerate</span>()) != <span class="number">1</span>:</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2 个线程对同一个全局变量操作之后的最终结果是:%s&quot;</span> % g_num)</span><br></pre></td></tr></table></figure>
<p>**结论：**如果多个线程同时对同一个全局变量操作，会出现资源竞争问题，从而数据结果会不正确</p>
<h3 id="同步的概念">同步的概念</h3>
<p>同步就是协同步调，按预定的先后次序进行运行。如:你说完，我再说。</p>
<p>“同” 字从字面上容易理解为一起动作</p>
<p><strong>其实不是</strong>，“同” 字应是指协同、协助、互相配合。</p>
<p>如进程、线程同步，可理解为进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B运行;B执行，再将结果给A;A再继续操作。</p>
<h3 id="解决线程同时修改全局变量的方式">解决线程同时修改全局变量的方式</h3>
<p>对于上一小节提出的那个计算错误的问题，可以通过线程同步来进行解决</p>
<p>思路，如下:</p>
<ol>
<li>系统调用<code>t1</code>，然后获取到<code>g_num</code>的值为0，此时上一把锁，即不允许其他线程操作<code>g_num</code></li>
<li><code>t1</code>对<code>g_num</code>的值进行+1</li>
<li><code>t1</code>解锁，此时<code>g_num</code>的值为1，其他的线程就可以使用<code>g_num</code>了，而且是<code>g_num</code>的值不是0而是1</li>
<li>同理其他线程在对<code>g_num</code>进行修改时，都要先上锁，处理完后再解锁，在上锁的整个过程中不允许其他线程访问，就保证了数据的正确性(原子性：要做就做完)</li>
</ol>
<h3 id="互斥锁">互斥锁</h3>
<p>当多个线程几乎同时修改某一个共享数据的时候，需要进行同步控制</p>
<p>线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引入互斥锁。</p>
<p>互斥锁为资源引入一个状态：锁定 / 非锁定</p>
<p>某个线程要更改共享数据时，先将其锁定，此时资源的状态为 “锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成 “非锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有一个线程进行写入操作，从而保证了多线程情况下数据的正确性。</p>
<p><code>threading</code>模块中定义了<code>Lock</code>类，可以方便的处理锁定：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建锁</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 锁定</span></span><br><span class="line">mutex.acquire()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放</span></span><br><span class="line">mutex.release()</span><br></pre></td></tr></table></figure>
<p><strong>注意点：</strong></p>
<ul>
<li>如果这个锁之前是没有上锁的，那么<code>acquire</code>不会堵塞</li>
<li>如果在调用<code>acquire</code>对这个锁上锁之前 它已经被 其他线程上了锁，那么此时<code>acquire</code>会堵塞，直到这个锁被解锁为止</li>
</ul>
<h4 id="互斥锁的使用">互斥锁的使用</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个互斥锁</span></span><br><span class="line"><span class="comment"># 默认是未上锁的状态</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"><span class="comment"># 全局变量</span></span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_number_1</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        mutex.acquire()  <span class="comment"># 上锁</span></span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">        mutex.release()  <span class="comment"># 解锁</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(f <span class="string">&quot;线程 1 计算得出的结果为: &#123;g_num&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_number_2</span>(<span class="params">num</span>):</span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(num):</span><br><span class="line">        mutex.acquire()  <span class="comment"># 上锁</span></span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">        mutex.release()  <span class="comment"># 解锁</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(f <span class="string">&quot;线程 2 计算得出的结果为: &#123;g_num&#125;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 创建 2 个线程，让他们各自对 g_num 加 1000000 次</span></span><br><span class="line">    p1 = threading.Thread(target = add_number_1, args =(<span class="number">1000000</span>,))</span><br><span class="line">    p1.start()</span><br><span class="line"></span><br><span class="line">    p2 = threading.Thread(target = add_number_2, args =(<span class="number">1000000</span>,))</span><br><span class="line">    p2.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待计算完成</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(threading.<span class="built_in">enumerate</span>()) != <span class="number">1</span>:</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2 个线程对同一个全局变量操作之后的最终结果是:%s&quot;</span> % g_num)</span><br></pre></td></tr></table></figure>
<p>可以看到最后的结果，加入互斥锁后，其结果与预期相符。（变成同步了，不要用多线程）</p>
<h4 id="上锁解锁过程">上锁解锁过程</h4>
<p>当一个线程调用锁的<code>acquire()</code>方法获得锁时，锁就进入“locked”状态。</p>
<p>每次只有一个线程可以获得锁。如果此时另一个线程试图获得这个锁，该线程就会变为“blocked”状态，称为“阻塞”，直到拥有锁的线程调用锁的<code>release()</code>方法释放锁之后，锁进入“unlocked”状态。</p>
<p>线程调度程序从处于同步阻塞状态的线程中选择一个来获得锁，并使得该线程进入运行（running）状态。</p>
<p><strong>总结：</strong></p>
<p>锁的好处：</p>
<ul>
<li>确保了某段关键代码只能由一个线程从头到尾完整地执行</li>
</ul>
<p>锁的坏处：</p>
<ul>
<li>阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了</li>
<li>由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁</li>
</ul>
<h3 id="死锁">死锁</h3>
<p>在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。</p>
<p>尽管死锁很少发生，但一旦发生就会造成应用的停止响应。</p>
<blockquote>
<p>死锁代码案例</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding = utf-8</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">mutexA = threading.Lock()</span><br><span class="line">mutexB = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread1</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 对 mutexA 上锁</span></span><br><span class="line">        mutexA.acquire()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># mutexA 上锁后，延时 1 秒，等待另外那个线程 把 mutexB 上锁</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.name+<span class="string">&#x27;----do1---up----&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 此时会堵塞，因为这个 mutexB 已经被另外的线程抢先上锁了</span></span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.name+<span class="string">&#x27;----do1---down----&#x27;</span>)</span><br><span class="line">        mutexB.release()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对 mutexA 解锁</span></span><br><span class="line">        mutexA.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread2</span>(threading.Thread):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 对 mutexB 上锁</span></span><br><span class="line">        mutexB.acquire()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># mutexB 上锁后，延时 1 秒，等待另外那个线程 把 mutexA 上锁</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.name+<span class="string">&#x27;----do2---up----&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 此时会堵塞，因为这个 mutexA 已经被另外的线程抢先上锁了</span></span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.name+<span class="string">&#x27;----do2---down----&#x27;</span>)</span><br><span class="line">        mutexA.release()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对 mutexB 解锁</span></span><br><span class="line">        mutexB.release()</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = MyThread1()</span><br><span class="line">    t2 = MyThread2()</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以用递归互斥锁解决  <code>lock = threading.RLock()</code></p>
<p>而且锁对象全局一般只定义一个</p>
</blockquote>
<h3 id="线程池">线程池</h3>
<h4 id="简单使用">简单使用</h4>
<blockquote>
<p>在普通的多线程案例中多数使用手动创建线程对象的方式去运行并发程序</p>
</blockquote>
<ol>
<li>如果当前有一百个任务，那么我需要创建一百个子线程对象去绑定并运行任务</li>
<li>线程对象是否可以重用?<br>
采用线程池的方式完成复用</li>
<li>线程对象是否能获取到一个任务到返回值?<br>
无法获取</li>
</ol>
<blockquote>
<p>普通方式使用线程池来执行线程任务的步骤如下：</p>
<ol>
<li>调用<code>ThreadPoolExecutor</code>类的构造器创建一个线程池。</li>
<li>定义一个普通函数作为线程任务。</li>
<li>调用<code>ThreadPoolExecutor</code>对象的<code>submit()</code>方法来提交线程任务。</li>
<li>当不想提交任何任务时，调用<code>ThreadPoolExecutor</code>对象的<code>shutdown()</code>方法来关闭线程池。</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个准备作为线程任务的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">action</span>(<span class="params"><span class="built_in">max</span></span>):</span><br><span class="line">    my_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>):</span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name + <span class="string">&#x27;  &#x27;</span> + <span class="built_in">str</span>(i))</span><br><span class="line">        my_sum += i</span><br><span class="line">        <span class="keyword">return</span> my_sum</span><br><span class="line">    <span class="comment"># 创建一个包含 2 条线程的线程池</span></span><br><span class="line">    pool = ThreadPoolExecutor(max_workers = <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 向线程池提交一个 task, 50 会作为 action()函数的参数</span></span><br><span class="line">    future1 = pool.submit(action, <span class="number">50</span>)</span><br><span class="line">    <span class="comment"># 向线程池再提交一个 task, 100 会作为 action()函数的参数</span></span><br><span class="line">    future2 = pool.submit(action, <span class="number">100</span>)</span><br><span class="line">    <span class="comment"># 判断 future1 代表的任务是否结束</span></span><br><span class="line">    <span class="built_in">print</span>(future1.done())</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 判断 future2 代表的任务是否结束</span></span><br><span class="line">    <span class="built_in">print</span>(future2.done())</span><br><span class="line">    <span class="comment"># 查看 future1 代表的任务返回的结果</span></span><br><span class="line">    <span class="built_in">print</span>(future1.result())</span><br><span class="line">    <span class="comment"># 查看 future2 代表的任务返回的结果</span></span><br><span class="line">    <span class="built_in">print</span>(future2.result())</span><br><span class="line">    <span class="comment"># 关闭线程池  </span></span><br><span class="line">    pool.shutdown()</span><br></pre></td></tr></table></figure>
<ul>
<li>上面程序中，第 13 行代码创建了一个包含两个线程的线程池，接下来的两行代码只要将<code>action()</code>函数提交（submit）给线程池，<strong>该线程池就会自动启动线程来执行action()函数</strong>。这种启动线程的方法既优雅，又具有更高的效率。</li>
<li>当程序把<code>action()</code>函数提交给线程池时，<code>submit()</code>方法会返回该任务所对应的<code>Future</code>对象，程序立即判断<code>future1</code>的<code>done()</code>方法，该方法将会返回False（表明此时该任务还未完成）。接下来主程序暂停 3 秒，然后判断<code>future2</code>的<code>done()</code>方法，如果此时该任务已经完成，那么该方法将会返回True。</li>
<li>程序最后通过<code>Future</code>的<code>result()</code>方法来获取两个异步任务返回的结果。</li>
<li>当程序使用<code>Future</code>的<code>result()</code>方法来获取结果时，该方法会阻塞主线程（如果调用<code>result()</code>方法的线程（在这个上下文中是主线程）在结果准备就绪之前就调用了<code>result()</code>，那么<code>result()</code>方法将会阻塞，直到结果被计算出来并返回。），如果没有指定<code>timeout</code>参数，当前线程将一直处于阻塞状态，直到<code>Future</code>代表的任务返回。</li>
<li>根据上传任务的顺序获取任务返回值，任务已经完成了，但是打印返回结果需要根据任务的上传顺序去返回</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2024/04/10/6615ce279b0de.png" alt="image-20240410072416619"></li>
<li>解决方法：<code>as_completed</code><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://bu.dusays.com/2024/04/10/6615cee5a67db.png" alt="image-20240410072734075"></li>
</ul>
<h4 id="获取执行结果"><strong>获取执行结果</strong></h4>
<p>前面程序调用了<code>Future</code>的<code>result()</code>方法来获取线程任务的运回值，但该方法会阻塞当前主线程，只有等到线程任务完成后，<code>result()</code>方法的阻塞才会被解除。</p>
<p>如果程序不希望直接调用<code>result</code>()方法阻塞线程，则可通过<code>Future</code>的<code>add_done_callback()</code>方法来添加回调函数，该回调函数形如 <code>fn(future)</code>。当线程任务完成后，程序会自动触发该回调函数，并将对应的<code>Future</code>对象作为参数传给该回调函数。</p>
<blockquote>
<p>上下文管理器方式使用线程池来执行线程任务的步骤如下：</p>
<ol>
<li>使用上下问管理器的方式创建线程池对象</li>
<li>创建线程池可以声明最大线程数:max_workers</li>
<li>通过线程池中的submit方法进行任务提交</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个准备作为线程任务的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">action</span>(<span class="params"><span class="built_in">max</span></span>):</span><br><span class="line">    my_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>):</span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name + <span class="string">&#x27;  &#x27;</span> + <span class="built_in">str</span>(i))</span><br><span class="line">        my_sum += i</span><br><span class="line">        <span class="keyword">return</span> my_sum</span><br><span class="line"><span class="comment"># 创建一个包含 2 条线程的线程池</span></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers = <span class="number">2</span>) <span class="keyword">as</span> pool:</span><br><span class="line">    <span class="comment"># 向线程池提交一个 task, 50 会作为 action()函数的参数</span></span><br><span class="line">    future1 = pool.submit(action, <span class="number">50</span>)</span><br><span class="line">    <span class="comment"># 向线程池再提交一个 task, 100 会作为 action()函数的参数</span></span><br><span class="line">    future2 = pool.submit(action, <span class="number">100</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_result</span>(<span class="params">future</span>):</span><br><span class="line">        <span class="built_in">print</span>(future.result())</span><br><span class="line">        <span class="comment"># 为 future1 添加线程完成的回调函数</span></span><br><span class="line">  、future1.add_done_callback(get_result)</span><br><span class="line">        <span class="comment"># 为 future2 添加线程完成的回调函数</span></span><br><span class="line">    future2.add_done_callback(get_result)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--------------&#x27;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面主程序分别为 <code>future1</code>、<code>future2</code>添加了同一个回调函数，该回调函数会在线程任务结束时获取其返回值。</p>
<p>主程序的最后一行代码打印了一条横线。由于程序并未直接调用<code>future1</code>、<code>future2</code>的<code>result()</code>方法，因此主线程不会被阻塞，可以立即看到输出主线程打印出的横线。接下来将会看到两个新线程并发执行，当线程任务执行完成后，<code>get_result()</code>函数被触发，输出线程任务的返回值。</p>
<p>另外，由于线程池实现了上下文管理协议（Context Manage Protocol），因此，程序可以使用with语句来管理线程池，这样即可避免手动关闭线程池，如上面的程序所示。</p>
</blockquote>
<h4 id="map-和wait-方法"><strong>map()和wait()方法</strong></h4>
<blockquote>
<p>例如，如下程序使用Executor的map()方法来启动线程，并收集线程任务的返回值：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个准备作为线程任务的函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">action</span>(<span class="params"><span class="built_in">max</span></span>):</span><br><span class="line">    my_sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">max</span>):</span><br><span class="line">        <span class="built_in">print</span>(threading.current_thread().name + <span class="string">&#x27;  &#x27;</span> + <span class="built_in">str</span>(i))</span><br><span class="line">        my_sum += i</span><br><span class="line">    <span class="keyword">return</span> my_sum</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个包含4条线程的线程池</span></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">4</span>) <span class="keyword">as</span> pool:</span><br><span class="line">    <span class="comment"># 使用线程执行map计算</span></span><br><span class="line">    <span class="comment"># 后面元组有3个元素，因此程序启动3条线程来执行action函数</span></span><br><span class="line">    results = pool.<span class="built_in">map</span>(action, (<span class="number">50</span>, <span class="number">100</span>, <span class="number">150</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;--------------&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> r <span class="keyword">in</span> results:</span><br><span class="line">        <span class="built_in">print</span>(r)</span><br></pre></td></tr></table></figure>
<ul>
<li>上面程序使用<code>map()</code>方法来启动 3 个线程（该程序的线程池包含 4 个线程，如果使用只包含两个线程的线程池，此时将有一个任务处于等待状态，必须等其中一个任务完成，线程空闲出来才会获得执行的机会），<code>map()</code>方法的返回值将会收集每个线程任务的返回结果（生成器）。</li>
<li>运行上面程序，同样可以看到 3 个线程并发执行的结果，最后通过<code>results</code>可以看到 3 个线程任务的返回结果。</li>
<li>通过上面程序可以看出，使用<code>map()</code>方法来启动线程，并收集线程的执行结果，不仅具有代码简单的优点，而且虽然程序会以并发方式来执行 <code>action()</code>函数，但最后收集的<code>action()</code>函数的执行结果，依然与传入参数的结果保持一致。也就是说，上面<code>results</code>的第一个元素是 <code>action(50)</code>的结果，第二个元素是<code>action(100)</code>的结果，第三个元素是<code>action(150)</code>的结果。</li>
</ul>
<blockquote>
<p>wait()方法示例</p>
</blockquote>
<p><strong>等待单个<code>Future</code>对象：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, wait</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">1</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    future = executor.submit(my_function, <span class="number">10</span>)</span><br><span class="line">    wait([future], timeout=<span class="number">5</span>)  <span class="comment"># 等待future对象完成，超时时间为5秒</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>等待<code>Future</code>对象列表：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor, wait</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> ThreadPoolExecutor(max_workers=<span class="number">1</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    futures = [executor.submit(my_function, i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">     wait(futures, timeout=<span class="number">5</span>)   <span class="comment"># 等待futures列表中的所有future对象完成，超时时间为5秒</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用<code>wait()</code>方法时，可以让所有的子线程任务全部完成之后才执行主线程中的代码，您可以指定一个超时时间（使用<code>timeout</code>参数），以避免无限期地等待。如果没有指定超时时间，<code>wait()</code>方法将阻塞直到指定的<code>Future</code>对象完成或取消。</p>
</blockquote>
<h2 id="进程-2">进程</h2>
<h3 id="什么是进程">什么是进程</h3>
<p>程序：例如xxx.py这是程序，是一个静态的</p>
<p>进程：一个程序运行起来后，代码+用到的资源 称之为进程，它是操作系统分配资源的基本单元。</p>
<p>不仅可以通过线程完成多任务，进程也是可以的</p>
<h3 id="进程的状态">进程的状态</h3>
<p>工作中，任务数往往大于cpu的核数，即一定有一些任务正在执行，而另外一些任务在等待cpu进行执行，因此导致了有了不同的状态。</p>
<ul>
<li>就绪态：运行的条件都已经具备，正在等在cpu执行</li>
<li>执行态：cpu正在执行其功能</li>
<li>等待态：等待某些条件满足，例如一个程序sleep了，此时就处于等待态</li>
</ul>
<h3 id="进程的创建-multiprocessing">进程的创建 - multiprocessing</h3>
<p><code>multiprocessing</code>模块就是跨平台版本的多进程模块，提供了一个<code>Process</code>类来代表一个进程对象，这个对象可以理解为是一个独立的进程，可以执行另外的事情。</p>
<h4 id="两个while循环一起执行">两个<code>while</code>循环一起执行</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_proc</span>():</span><br><span class="line">    <span class="string">&quot;&quot;</span> <span class="string">&quot;子进程要执行的代码&quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当前任务被子进程运行...&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多进程需要写函数入口 </span></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = Process(target = run_proc)   <span class="comment"># 	注意大写P</span></span><br><span class="line">    p.start()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当前任务被主进程运行...&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个<code>Process</code>实例，用<code>start()</code>方法启动</p>
<h4 id="获取进程的pid">获取进程的<code>pid</code></h4>
<p><strong>示例代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_proc</span>():</span><br><span class="line">    <span class="string">&quot;&quot;</span> <span class="string">&quot;子进程要执行的代码&quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;子进程运行中，pid =%d...&#x27;</span> % os.getpid())  <span class="comment"># os.getpid 获取当前进程的进程号</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;子进程将要结束...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父进程 pid: %d&#x27;</span> % os.getpid())  <span class="comment"># os.getpid 获取当前进程的进程号</span></span><br><span class="line">    p = Process(target = run_proc)</span><br><span class="line">    p.start()</span><br></pre></td></tr></table></figure>
<p><code>Process</code>语法结构如下：</p>
<p><code>Process([group [, target [, name [, args [, kwargs]]]]])</code></p>
<ul>
<li><code>target</code>：如果传递了函数的引用，可以任务这个子进程就执行这里的代码</li>
<li><code>args</code>：给<code>target</code>指定的函数传递的参数，以元组的方式传递</li>
<li><code>kwargs</code>：给<code>target</code>指定的函数传递命名参数</li>
<li><code>name</code>：给进程设定一个名字，可以不设定</li>
<li><code>group</code>：指定进程组，大多数情况下用不到</li>
</ul>
<p><code>Process</code>创建的实例对象的常用方法：</p>
<ul>
<li><code>start()</code>：启动子进程实例（创建子进程）</li>
<li><code>is_alive()</code>：判断进程子进程是否存活</li>
<li><code>join([timeout])</code>：是否等待子进程执行结束，或等待多少秒</li>
<li><code>terminate()</code>：不管任务是否完成，立即终止子进程</li>
</ul>
<p><code>Process</code>创建的实例对象的常用属性：</p>
<ul>
<li><code>name</code>：当前进程的别名，默认为<code>Process-N</code>，N为从1开始递增的整数</li>
<li><code>pid</code>：当前进程的<code>pid</code>（进程号）</li>
</ul>
<h4 id="给子进程指定的函数传递参数">给子进程指定的函数传递参数</h4>
<p><strong>示例代码</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run_proc</span>(<span class="params">name, age, **kwargs</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;子进程运行中，name =%s, age =%d, pid =%d...&#x27;</span> % (name, age, os.getpid()))</span><br><span class="line">        <span class="built_in">print</span>(kwargs)</span><br><span class="line">        sleep(<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = Process(target = run_proc, args =(<span class="string">&#x27;test&#x27;</span>, <span class="number">18</span>), kwargs =&#123;<span class="string">&quot;m&quot;</span>: <span class="number">20</span>&#125;)</span><br><span class="line">    p.start()</span><br><span class="line">    sleep(<span class="number">1</span>)  <span class="comment"># 1 秒之后，立即结束子进程</span></span><br><span class="line">    p.terminate()</span><br><span class="line">    <span class="string">&quot;&quot;</span> <span class="string">&quot;</span></span><br><span class="line"><span class="string">    但是通过执行系统命令 ps 查看停止后的进程</span></span><br><span class="line"><span class="string">    你会发现, 直接调用 terminate 方法停止的进程变成了一个僵尸进程(defunct), </span></span><br><span class="line"><span class="string">    只能等待主程序退出, 这个僵尸进程才会消失.</span></span><br><span class="line"><span class="string">    &quot;</span><span class="string">&quot; &quot;</span></span><br><span class="line">    <span class="comment"># 等待子进程真正结束</span></span><br><span class="line">    p.join()</span><br><span class="line">    <span class="built_in">print</span>(p.is_alive())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="进程间不同享全局变量">进程间不同享全局变量</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">nums = [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work1</span>():</span><br><span class="line">    <span class="string">&quot;&quot;</span> <span class="string">&quot;子进程要执行的代码&quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in 子进程_1 pid =%d , 初始列表 =%s&quot;</span> % (os.getpid(), nums))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        nums.append(i)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;in 子进程_1 pid =%d , nums =%s&quot;</span> % (os.getpid(), nums))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">work2</span>():</span><br><span class="line">    <span class="string">&quot;&quot;</span> <span class="string">&quot;子进程要执行的代码&quot;</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;in 子进程_2 pid =%d , nums =%s&quot;</span> % (os.getpid(), nums))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p1 = Process(target = work1)</span><br><span class="line">    p1.start()</span><br><span class="line">    p1.join()</span><br><span class="line"></span><br><span class="line">    p2 = Process(target = work2)</span><br><span class="line">    p2.start()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>进程间不同享全局变量,子进程间内存隔离</p>
</blockquote>
<h3 id="进程、线程对比">进程、线程对比</h3>
<h4 id="功能">功能</h4>
<ul>
<li>进程，能够完成多任务，比如 在一台电脑上能够同时运行多个QQ</li>
<li>线程，能够完成多任务，比如 一个QQ中的多个聊天窗口</li>
</ul>
<h4 id="定义的不同">定义的不同</h4>
<ul>
<li>进程是系统进行资源分配和调度的一个独立单位.</li>
<li>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.</li>
</ul>
<h4 id="区别">区别</h4>
<ul>
<li>
<p>一个程序至少有一个进程,一个进程至少有一个线程.</p>
</li>
<li>
<p>线程的划分尺度小于进程(资源比进程少)，使得多线程程序的并发性高。</p>
</li>
<li>
<p>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率</p>
</li>
<li>
<p>线程不能够独立执行，必须依存在进程中</p>
</li>
<li>
<p>可以将进程理解为工厂中的一条流水线，而其中的线程就是这个流水线上的工人</p>
</li>
</ul>
<h4 id="优缺点">优缺点</h4>
<p>线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源的管理和保护；而进程正相反。</p>
<h3 id="进程间通信-Queue">进程间通信 - <code>Queue</code></h3>
<ol>
<li>在线程中使用队列的原因:<br>
避免线程之间资源竞争，队列这种数据结构是线程安全的</li>
<li>在进程中使用队列的原因:<br>
队列在进程中可以实现资源共享</li>
</ol>
<h4 id="Queue的使用"><code>Queue</code>的使用</h4>
<p>可以使用<code>multiprocessing</code>模块的<code>Queue</code>实现多进程之间的数据传递。</p>
<p><code>Queue</code>本身是一个消息列队程序（和线程进程无关，全局对象），首先用一个小实例来演示一下<code>Queue</code>的工作原理：（类似列表？篮子？）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在进程中使用Queue要使用multiprocessing模块的Queue，而不是queue的Queue</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line">q = Queue(<span class="number">3</span>)  <span class="comment"># 初始化一个 Queue 对象，最多可接收三条 put 消息</span></span><br><span class="line">q.put(<span class="string">&quot;消息 1&quot;</span>)</span><br><span class="line">q.put(<span class="string">&quot;消息 2&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(q.full())  <span class="comment"># 判断当前队列是否已满: False</span></span><br><span class="line">q.put(<span class="string">&quot;消息 3&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(q.full())  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果队列已满 put_nowait 会立即抛出异常，put 等待两秒会抛出异常</span></span><br><span class="line">q.put(<span class="string">&quot;消息 4&quot;</span>, <span class="literal">True</span>, <span class="number">2</span>)</span><br><span class="line">q.put_nowait(<span class="string">&quot;消息 4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推荐的方式，先判断消息列队是否已满，再写入</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> q.full():</span><br><span class="line">    q.put_nowait(<span class="string">&quot;消息 4&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取消息时，先判断消息列队是否为空，再读取</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(q.qsize()):</span><br><span class="line">        <span class="built_in">print</span>(q.get_nowait())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>先进先出，没有索引</p>
<p>（其实一般多线程才会用queue，线程池不会用）</p>
</blockquote>
<p><strong>说明</strong></p>
<ul>
<li>
<p>初始化<code>Queue()</code>对象时，若括号中没有指定最大可接收的消息数量，或数量为负值，那么就代表可接受的消息数量<strong>没有上限</strong>（直到内存的尽头）；</p>
</li>
<li>
<p><code>Queue.qsize()</code>：返回当前队列包含的消息数量；</p>
</li>
<li>
<p><code>Queue.empty()</code>：如果队列为空，返回<code>True</code>，反之<code>False</code>；</p>
</li>
<li>
<p><code>Queue.full()</code>：如果队列满了，返回<code>True</code>,反之<code>False</code>；</p>
</li>
<li>
<p><code>Queue.get([block[, timeout]])</code>：获取队列中的一条消息，然后<strong>将其从列队中移除</strong>，<code>block</code>默认值为<code>True</code>；</p>
<ul>
<li>
<p>如果<code>block</code>使用默认值，且没有设置<code>timeout</code>（单位秒），<strong>消息列队如果为空，此时程序将被阻塞（停在读取状态）</strong>，直到从消息列队读到消息为止，如果设置了<code>timeout</code>，则会等待<code>timeout</code>秒，若还没读取到任何消息，则抛出<code>&quot;Queue.Empty&quot;</code>异常；</p>
</li>
<li>
<p>如果<code>block</code>值为<code>False</code>，消息列队如果为空，则会立刻抛出<code>&quot;Queue.Empty&quot;</code>异常；</p>
</li>
<li>
<p><code>Queue.get_nowait()</code>：相当<code>Queue.get(False)</code>（会抛异常，很少用）；</p>
</li>
</ul>
</li>
<li>
<p><code>Queue.put(item,[block[, timeout]])</code>：将<code>item</code>消息写入队列，<code>block</code>默认值为<code>True</code>；</p>
<ul>
<li>
<p>如果<code>block</code>使用默认值，且没有设置<code>timeout</code>（单位秒），<strong>消息列队如果已经没有空间可写入，此时程序将被阻塞（停在写入状态）</strong>，直到从消息列队腾出空间为止，如果设置了<code>timeout</code>，则会等待<code>timeout</code>秒，若还没空间，则抛出<code>&quot;Queue.Full</code>&quot;异常；</p>
</li>
<li>
<p>如果<code>block</code>值为<code>False</code>，消息列队如果没有空间可写入，则会立刻抛出<code>&quot;Queue.Full&quot;</code>异常；</p>
</li>
<li>
<p><code>Queue.put_nowait(item)</code>：相当<code>Queue.put(item, False)</code></p>
</li>
</ul>
</li>
</ul>
<h4 id="Queue实例"><code>Queue</code>实例</h4>
<p>我们以<code>Queue</code>为例，在父进程中创建两个子进程，一个往<code>Queue</code>里写数据，一个从<code>Queue</code>里读数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> time, random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写数据进程执行的代码:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Put %s to queue...&#x27;</span> % value)</span><br><span class="line">        q.put(value)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读数据进程执行的代码:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            value = q.get(<span class="literal">True</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Get %s from queue.&#x27;</span> % value)</span><br><span class="line">            time.sleep(random.random())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 父进程创建 Queue，并传给各个子进程：</span></span><br><span class="line">    q = Queue() <span class="comment"># 只能读写</span></span><br><span class="line">    pw = Process(target = write, args =(q,))</span><br><span class="line">    pr = Process(target = read, args =(q,))</span><br><span class="line">    <span class="comment"># 启动子进程 pw，写入:</span></span><br><span class="line">    pw.start()</span><br><span class="line">    <span class="comment"># 等待 pw 结束:</span></span><br><span class="line">    pw.join()</span><br><span class="line">    <span class="comment"># 启动子进程 pr，读取:</span></span><br><span class="line">    pr.start()</span><br><span class="line">    pr.join()</span><br><span class="line">    <span class="comment"># pr 进程里是死循环，无法等待其结束，只能强行终止:</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;所有数据都写入并且读完&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="队列信号">队列信号</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time, random</span><br><span class="line"><span class="comment">#  进程中实现队列信号要使用JoinableQueue  （线程中好像Queue即可）</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, JoinableQueue  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">write</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>]:</span><br><span class="line">        q.put(value) <span class="comment"># 计数器+1</span></span><br><span class="line">        time.sleep(random.random())  <span class="comment"># 返回0 - 1之间的随机数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        value = q.get()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;队列中的数据:&#x27;</span>, value)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line">        q.task_done()  <span class="comment"># 发送一个任务结束的信号  计数器-1</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        循环在队列中取值, 取出一个就给主进程发送一个任务结束的信号</span></span><br><span class="line"><span class="string">            直到这个队列为空</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    queue = JoinableQueue()  <span class="comment"># 维护了一个计数器</span></span><br><span class="line"></span><br><span class="line">    p1 = Process(target=write, args=(queue,))</span><br><span class="line">    p2 = Process(target=read, args=(queue,))</span><br><span class="line"></span><br><span class="line">    process_list = [p1, p2]</span><br><span class="line">    <span class="keyword">for</span> process <span class="keyword">in</span> process_list:</span><br><span class="line">        <span class="comment"># 设置守护进程</span></span><br><span class="line">        process.daemon = <span class="literal">True</span></span><br><span class="line">        process.start()</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当队列计数器的值不为0会造成主进程堵塞</span></span><br><span class="line">    queue.join()  <span class="comment"># 让主进程等待, 如果计数器为0主进程解堵塞</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>put的时候计数+1，get不会-1，get需要和task_done 一起使用才会-1</p>
<p>task_done不能放在另一个队列的put之前，否则可能会出现数据没有处理完成，程序结束的情况</p>
</blockquote>
<h3 id="进程的创建-进程池Pool">进程的创建 - 进程池<code>Pool</code></h3>
<h4 id="使用Pool创建进程池">使用<code>Pool</code>创建进程池</h4>
<p>当需要创建的子进程数量不多时，可以直接利用<code>multiprocessing</code>中的<code>Process</code>动态成生多个进程，但如果是上百甚至上千个目标，手动的去创建进程的工作量巨大，此时就可以用到<code>multiprocessing</code>模块提供的<code>Pool</code>方法。</p>
<p>初始化<code>Pool</code>时，可以指定一个最大进程数，当有新的请求提交到<code>Pool</code>中时，如果池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中有进程结束，才会用之前的进程来执行新的任务，请看下面的实例（和线程池一样）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="comment"># 更高级的进程池</span></span><br><span class="line"><span class="comment"># from concurrent.futures import ProcessPoolExecutor</span></span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">msg</span>):</span><br><span class="line">    p_start = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s 开始执行, 进程号为%d&quot;</span> % (msg, os.getpid()))</span><br><span class="line">    <span class="comment"># random.random()随机生成 0~1 之间的浮点数</span></span><br><span class="line">    time.sleep(random.random() * <span class="number">2</span>)</span><br><span class="line">    p_stop = time.time()</span><br><span class="line">    <span class="built_in">print</span>(msg, <span class="string">&quot;执行完毕，耗时%0.2f&quot;</span> % (p_stop - p_start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main_start = time.time()</span><br><span class="line">    po = Pool(<span class="number">3</span>)  <span class="comment"># 定义一个进程池，最大进程数 3</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">        <span class="comment"># Pool().apply_async(要调用的目标,(传递给目标的参数元祖,))</span></span><br><span class="line">        <span class="comment"># 每次循环将会用空闲出来的子进程去调用目标</span></span><br><span class="line">        po.apply_async(worker, (i,))</span><br><span class="line">        <span class="comment"># po.apply(worker, (i,))  # 同步执行 执行该方法会导致主进程堵塞</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;----start----&quot;</span>)</span><br><span class="line">    po.close()  <span class="comment"># 关闭进程池，关闭后 po 不再接收新的请求</span></span><br><span class="line">    po.join()  <span class="comment"># 等待 po 中所有子进程执行完成，必须放在 close 语句之后</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;-----end-----&quot;</span>)</span><br><span class="line">    main_stop = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;耗时: <span class="subst">&#123;main_stop - main_start&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>multiprocessing.Pool</code>常用函数解析：</p>
<ul>
<li><code>apply_async(func[, args[, kwds]]) </code>：使用非阻塞方式调用<code>func</code>（并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程），<code>args</code>为传递给<code>func</code>的参数列表，<code>kwds</code>为传递给<code>func</code>的关键字参数列表</li>
<li><code>close()</code>：关闭<code>Pool</code>，使其不再接受新的任务</li>
<li><code>terminate()</code>：不管任务是否完成，立即终止</li>
<li><code>join()</code>：主进程阻塞，等待子进程的退出， 必须在<code>close</code>或<code>terminate</code>之后使用</li>
</ul>
<h4 id="进程池中的Queue">进程池中的<code>Queue</code></h4>
<p>如果要使用<code>Pool</code>创建进程，就需要使用<code>multiprocessing.Manager()</code>中的<code>Queue()</code>，而不是<code>multiprocessing.Queue()</code>，否则会得到一条如下的错误信息：</p>
<blockquote>
<p>RuntimeError: Queue objects should only be shared between processes through inheritance.</p>
</blockquote>
<p>下面的实例演示了进程池中的进程如何通信：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改 import 中的 Queue 为 Manager</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager, Pool</span><br><span class="line"><span class="keyword">import</span> os, time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">reader</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;reader 启动(%s), 父进程为(%s)&quot;</span> % (os.getpid(), os.getppid()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(q.qsize()):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;reader 从 Queue 获取到消息：%s&quot;</span> % q.get())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">writer</span>(<span class="params">q</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;writer 启动(%s), 父进程为(%s)&quot;</span> % (os.getpid(), os.getppid()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;tuling&quot;</span>:</span><br><span class="line">        q.put(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(%s) start&quot;</span> % os.getpid())</span><br><span class="line">    q = Manager().Queue()  <span class="comment"># 使用 Manager 中的 Queue</span></span><br><span class="line">    po = Pool()</span><br><span class="line">    po.apply_async(writer, (q,))</span><br><span class="line">    <span class="comment"># 等待队列写入</span></span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    po.apply_async(reader, (q,))</span><br><span class="line">    po.close()</span><br><span class="line">    po.join()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;(%s) End&quot;</span> % os.getpid())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="协程-asyncio">协程 - <code>asyncio</code></h2>
<h3 id="协程">协程</h3>
<p>协程不是计算机提供，操作系统只是提供了线程和进程。<strong>程序员人为创造</strong>。</p>
<p>协程运行程序的大致状态：在一个线程中运行多个任务，任务与任务之间来回切换，并在同一时间内只能运行一个任务。</p>
<p>协程（coroutine）也可以被称之为微线程，是一种用户态内的上下文切换技术。简而言之，其实就是<strong>通过一个线程实现代码块相互切换</strong>执行。</p>
<h3 id="协程意义">协程意义</h3>
<p>在一个线程中如果遇到了<code>IO等待</code>的时间，那么线程会充分利用这个等待时间去执行其他的任务。</p>
<p>案例：使用<code>requests</code>模块完成图片下载</p>
<ul>
<li>
<p>普通方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pip install requests</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">download_image</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始下载: &#x27;</span>, url)</span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;下载完成...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存图片</span></span><br><span class="line">    file_name = url.rsplit(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, mode =<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(response.content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url_list = [</span><br><span class="line">        <span class="string">&#x27;http://pic.bizhi360.com/bbpic/98/10798.jpg&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;http://pic.bizhi360.com/bbpic/92/10792.jpg&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;http://pic.bizhi360.com/bbpic/86/10386.jpg&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> url_list:</span><br><span class="line">        download_image(item)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>协程方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">download_image</span>(<span class="params">session, url</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;发送请求: &#x27;</span>, url)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, verify_ssl = <span class="literal">False</span>) <span class="keyword">as</span> response:</span><br><span class="line">        content = <span class="keyword">await</span> response.content.read()</span><br><span class="line">        file_name = url.rsplit(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_name, mode =<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        url_list = [</span><br><span class="line">            <span class="string">&#x27;http://pic.bizhi360.com/bbpic/98/10798.jpg&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;http://pic.bizhi360.com/bbpic/92/10792.jpg&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;http://pic.bizhi360.com/bbpic/86/10386.jpg&#x27;</span></span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        tasks = [asyncio.create_task(download_image(session, url)) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="异步编程">异步编程</h3>
<h4 id="事件循环">事件循环</h4>
<p>事件循环是异步编程中的重要的组成部分，大家现在可以暂时理解为一个死循环，可以检测并执行某些代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪代码</span></span><br><span class="line">任务列表 = [任务 <span class="number">1</span>, 任务 <span class="number">2</span>, 任务 <span class="number">3.</span>..]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    可执行的任务列表, 已完成的任务列表 = 去任务列表中检查所有的任务, 将<span class="string">&#x27;可执行&#x27;</span>和<span class="string">&#x27;已完成&#x27;</span>的任务返回</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 就绪任务 <span class="keyword">in</span> 可执行的任务列表:</span><br><span class="line">        执行已就绪的任务</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> 已完成的任务 <span class="keyword">in</span> 已完成的任务列表:</span><br><span class="line">        在任务列表中移除已完成的任务</span><br><span class="line">        </span><br><span class="line">    如果任务列表中的任务都已经完成则终止循环</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成或者获取一个事件循环</span></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="comment"># 将任务放到事件循环 [任务列表] 中检测任务状态是否可执行</span></span><br><span class="line">loop.run_until_complete(任务)</span><br></pre></td></tr></table></figure>
<h4 id="基本应用">基本应用</h4>
<ul>
<li>协程函数：在定义函数时使用<code>async def 函数名()</code>修饰的函数被称之为协程函数</li>
<li>协程对象：执行 <code>协程函数()</code> 得到的就是协程对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义协程函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 获取协程对象</span></span><br><span class="line">result = func()</span><br></pre></td></tr></table></figure>
<p>注意：在获取协程对象时 协程函数的内部代码并不会被执行。</p>
<p>想要执行协程函数，需要使用协程函数、协程对象、事件循环搭配使用。</p>
<p>事件循环会执行协程函数中的内部代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;这是一个协程任务&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">result = func()</span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line">loop.run_until_complete(result)</span><br></pre></td></tr></table></figure>
<p>在python3.7之后无需自己创建事件循环, 可以直接使用<code>asyncio.run(任务)</code>来执行协程函数中的内部代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;这是一个协程任务&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">result = func()</span><br><span class="line">asyncio.run(result)</span><br></pre></td></tr></table></figure>
<h4 id="await-关键字">await 关键字</h4>
<ul>
<li>
<p>await 定义：<strong>等待后面的函数返回结果,只有后面的函数返回结果了(且现在主线程没事干)，程序才会继续往下执行。</strong>（我感觉这种定义有问题啊，一般的函数就是这样啊，等到结果返回了，程序才会继续往下执行，，await应该是告诉程序可以去执行别的了，这个任务比较消耗时间，等到主线程完成别的了，检测到它的任务也完成了，才会继续往下执行））</p>
</li>
<li>
<p>基本使用方式：await + 可等待的对象（协程对象、<code>Future</code>对象、<code>Task</code>对象）</p>
<p>示例1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始协程任务...&#x27;</span>)</span><br><span class="line">    <span class="comment"># 模拟 IO 等待 如果当前有其他任务则切换</span></span><br><span class="line">    response = <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;任务结束: &#x27;</span>, response)</span><br><span class="line">    </span><br><span class="line">asyncio.run(func())</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">others</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;这是执行完协程函数后所得到的结果&#x27;</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;执行协程函数内部代码&#x27;</span>)</span><br><span class="line">    response = <span class="keyword">await</span> others()</span><br><span class="line">    <span class="built_in">print</span>(response)</span><br><span class="line"></span><br><span class="line">asyncio.run(func())</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>await</code>可以获取任务的返回值</p>
</blockquote>
<p>示例3：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">others</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;end&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;这是执行完协程函数后所得到的结果&#x27;</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;执行协程函数内部代码&#x27;</span>)</span><br><span class="line">    <span class="comment"># 注意：在当前代码中使用 await 进行 io 等待后, 会堵塞代码。当 response_1 执行完毕后解堵塞继续往下执行</span></span><br><span class="line">    response_1 = <span class="keyword">await</span> others()</span><br><span class="line">    <span class="built_in">print</span>(response_1)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># response_2 同理, 等待 others 任务执行完毕后才能继续往下执行</span></span><br><span class="line">    response_2 = <span class="keyword">await</span> others()  <span class="comment"># 等待另一个协程完成</span></span><br><span class="line">    <span class="built_in">print</span>(response_2)</span><br><span class="line"></span><br><span class="line">asyncio.run(func())</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在<code>asyncio</code>事件循环中，<code>await</code>关键字用于<strong>暂停当前协程</strong>的执行，并等待一个<code>awaitable</code>对象（如另一个协程、任务或未来）完成。如果在等待期间有其他<code>awaitable</code>对象准备好执行，事件循环会调度这些就绪的<code>awaitable</code>对象，而不是继续执行刚刚被<code>await</code>暂停的协程。</p>
<p>这种调度机制是由事件循环的核心功能决定的，事件循环负责监控所有的<code>awaitable</code>对象，并在它们准备好执行时（例如，一个网络请求返回结果，一个文件读取完成，或者一个定时器触发）调度它们执行。当一个<code>awaitable</code>对象准备好执行时（即它不是阻塞的），事件循环会立即执行它，而不是等待之前被<code>await</code>暂停的协程继续执行。</p>
<p>以下是一些关键点：</p>
<ol>
<li>
<ol>
<li><strong>非阻塞操作：</strong> <code>awaitable</code>对象通常是执行非阻塞操作的。例如，<code>asyncio.sleep()</code>是一个阻塞调用，但是当您使用<code>await asyncio.sleep()</code>时，它会释放执行权，允许事件循环去处理其他任务。</li>
<li><strong>事件循环的调度：</strong> 当一个<code>awaitable</code>对象完成时（例如，网络操作完成或定时器触发），事件循环会将其标记为就绪，并在下一个事件循环迭代中调度它。如果在等待这个<code>awaitable</code>对象时有其他就绪的<code>awaitable</code>对象，事件循环会优先处理这些就绪的<code>awaitable</code>对象。</li>
<li><strong>协作式多任务：</strong> 在<code>asyncio</code>中，协程的执行是协作式的。这意味着即使一个协程被<code>await</code>暂停，它也不是永久挂起的。一旦就绪，它就会被重新加入到事件循环的就绪队列中，并在下一次事件循环迭代中被调度执行。</li>
</ol>
</li>
</ol>
<p>总结来说，<code>await</code>关键字确保了协程的执行不会被阻塞在单个耗时的操作上，而是可以在多个协程之间灵活地切换，这使得<code>asyncio</code>非常适合处理I/O密集型任务，如网络编程和文件操作。在多核CPU上，<code>asyncio</code>还可以利用<code>concurrent.futures</code>模块中的线程池或进程池来执行CPU密集型任务，进一步提高性能。</p>
<p><strong>特点：</strong></p>
<ol>
<li>
<ol>
<li><strong>协程必须显式地使用<code>await</code>：</strong> 协程必须在耗时操作（如网络请求、文件读写等）前使用<code>await</code>，以确保这些操作不会阻塞事件循环。这是协作式多任务的核心：协程必须遵守规则并交还控制权。</li>
<li><strong>事件循环控制切换：</strong> 事件循环负责调度多个协程的执行。当一个协程<code>await</code>一个<code>awaitable</code>对象时，如果该对象还没有准备好，事件循环会切换到下一个就绪的协程执行。当<code>awaitable</code>对象完成时，事件循环会安排对应的协程继续执行。</li>
</ol>
</li>
<li></li>
</ol>
</blockquote>
</li>
</ul>
<h4 id="Task-对象">Task 对象</h4>
<blockquote>
<p>Tasks用于并发调度协程，通过<code>asyncio.create_task(协程对象)</code>的方式创建Task对象，这样可以让协程加入事件循环中等待被调度执行。</p>
<p>除了使用<code>asyncio.create_task()</code>函数外，还可以使用低层级的<code>loop.create_task()</code>或<code>ensure_future()</code>函数。但是不建议手动实例化Task对象</p>
</blockquote>
<p>注意：<code>asyncio.create_task()</code>函数在 Python 3.7 中被加入。在 Python 3.7 之前可以改用低层级的<code>asyncio.ensure_future()</code>函数</p>
<p>实例1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;这是一个返回值&#x27;</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始任务...&#x27;</span>)</span><br><span class="line">    <span class="comment"># 创建 task 对象，将当前的 func 任务添加到事件循环中</span></span><br><span class="line">    task_1 = asyncio.create_task(func())</span><br><span class="line">    task_2 = asyncio.create_task(func())</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;任务结束...&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 当执行某些协程遇到 IO 操作时，会自动切换执行其他任务</span></span><br><span class="line">    <span class="comment"># 此处的 await 是等待相对应的协程全部执行完毕并获取结果</span></span><br><span class="line">    <span class="comment"># 虽然没使用列表，但是依然是异步的</span></span><br><span class="line">    result_1 = <span class="keyword">await</span> task_1</span><br><span class="line">    result_2 = <span class="keyword">await</span> task_2</span><br><span class="line">    <span class="built_in">print</span>(result_1, result_2)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())    </span><br></pre></td></tr></table></figure>
<blockquote>
<p>是在<code>asyncio</code>中，需要在事件循环中运行异步代码。因此，需要将<code>asyncio.run()</code>调用包装在一个函数(<code>main()</code>)中，然后使用<code>asyncio.run()</code>来运行该函数。这样做可以确保在程序的顶层中运行异步代码是正确的。</p>
<p><code>asyncio.run()</code> 函数需要一个 <code>async</code> 函数作为参数</p>
</blockquote>
<p>示例2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;这是一个返回值&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始任务...&#x27;</span>)</span><br><span class="line">    <span class="comment"># 创建 task 对象，将当前的 func 任务添加到事件循环中</span></span><br><span class="line">    task_list = [</span><br><span class="line">        <span class="comment"># 在创建 task 对象时, 可以在 task 内部给协程对象取别名: name = 别名名称</span></span><br><span class="line">        asyncio.create_task(func(), name =<span class="string">&#x27;n1&#x27;</span>),</span><br><span class="line">        asyncio.create_task(func(), name =<span class="string">&#x27;n2&#x27;</span>)</span><br><span class="line">    ]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;任务结束...&#x27;</span>)</span><br><span class="line">    <span class="comment"># await 关键字之后只能连接可以等待的对象 列表不能在 await 之后</span></span><br><span class="line">    <span class="comment"># await task_list</span></span><br><span class="line">    done, pending = <span class="keyword">await</span> asyncio.wait(task_list, timeout = <span class="literal">None</span>)   <span class="comment"># 返回的是一个元组，拆包成为2个集合</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    done: 接收协程函数所返回的值</span></span><br><span class="line"><span class="string">    pending: 如果设置超时时间, 则接收在超时时间内没有执行完毕的函数的状态</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    一般情况下不会使用 pending 参数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(done)  <span class="comment"># 返回的类型为一个集合</span></span><br><span class="line">    <span class="comment"># asyncio.wait返回的完成任务的顺序并不一定与传入的协程顺序一致，它并不保证顺序。</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> done:  <span class="comment"># 使用迭代的方式取出集合中的协程对象</span></span><br><span class="line">        <span class="built_in">print</span>(item.result())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>asyncio.wait()</code>函数接受一个可迭代的<code>Task</code>对象集合（列表），返回一个包含已完成（<code>done</code>）和未完成（<code>pending</code>）<code>Task</code>对象的两元组。这些<code>Task</code>对象代表了异步的控制流，可以在一个事件循环中运行。<strong>这个方法接收了一个迭代对象之后对这个迭代对象进行遍历并取出内部元素将内部元素传递给事件循环</strong></p>
<p><code>asyncio.wait()</code> 函数应该接收一个由 Task 对象组成的列表(高版本移除了接收协程对象的功能)</p>
<p><code>asyncio.create_task()</code>应该放在一个函数的内部</p>
</blockquote>
<p><s>示例3：</s></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;这是一个返回值&#x27;</span></span><br><span class="line"></span><br><span class="line">task_list = [</span><br><span class="line">    func(),</span><br><span class="line">    func()</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line">done, pending = asyncio.run(asyncio.wait(task_list))</span><br><span class="line"><span class="built_in">print</span>(done)</span><br></pre></td></tr></table></figure>
<p>注意点：</p>
<ul>
<li>
<p>如果需要将<code>task</code>列表放在函数外，需要注意在执行协程函数列表之前需要首先创建事件循环。</p>
</li>
<li>
<p>并且在列表中不能直接添加<code>Task</code>对象。<code>Task</code>对象需要基于事件循环执行。</p>
</li>
</ul>
<h4 id="asyncio-Future-对象"><s>asyncio.Future 对象</s></h4>
<blockquote>
<p>Task 继承 Future, Task对象内部中的await结果的处理基于Future对象来的</p>
</blockquote>
<p>在Future对象中会保存当前执行的这个协程任务的状态，如果当前任务状态为finished, 则await不再等待。</p>
<p>示例1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 获取当前事件循环</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line">    <span class="comment"># 创建一个任务 [Future 对象] 当前没有任何任务</span></span><br><span class="line">    fut = loop.create_future()</span><br><span class="line">    <span class="comment"># 等待任务的最终结果，没有结果则一直等待</span></span><br><span class="line">    <span class="keyword">await</span> fut</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">set_after</span>(<span class="params">fut</span>):</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">2</span>)</span><br><span class="line">    fut.set_result(<span class="string">&#x27;这是一个测试结果&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 获取事件循环</span></span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建一个任务, 并且当前任务没有绑定任何行为, 则这个任务永远不知道什么时候结束</span></span><br><span class="line">    fut = loop.create_future()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 手动设置 future 任务的最终结果</span></span><br><span class="line">    <span class="keyword">await</span> loop.create_task(set_after(fut))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待 Future 对象获取最终的结果, 否则就一直等</span></span><br><span class="line">    data = <span class="keyword">await</span> fut</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>
<h4 id="concurrent-futures-Future-对象"><s>concurrent.futures.Future 对象</s></h4>
<p>使用线程池、进程池实现异步操作时会使用到的对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> Future</span><br><span class="line"><span class="keyword">from</span> concurrent.futures.thread <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> concurrent.futures.process <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">value</span>):</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线程池</span></span><br><span class="line">pool = ThreadPoolExecutor(max_workers = <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建进程池</span></span><br><span class="line"><span class="comment"># pool = ProcessPoolExecutor(max_workers = 5)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    fut = pool.submit(func, i)</span><br><span class="line">    <span class="built_in">print</span>(fut)</span><br></pre></td></tr></table></figure>
<p>一般情况下，代码编写需要统一编程风格，简而言之，就是如果使用的是线程/进程，则整个程序都统一使用线程/进程。</p>
<p>只有一种情况可能会进行交叉编程。一个项目中的所有IO请求为协程异步请求，假设MySQL数据库版本过低导致无法使用协程进行并发存储，这种情况会使用线程/进程完成并发存储任务。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func_1</span>():</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;测试&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    loop = asyncio.get_running_loop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在协程函数中运行普通函数 在执行函数时，协程内部会自动创建一个线程池来运行任务</span></span><br><span class="line">    <span class="comment"># run_in_executor()方法第一个参数为 None 时则默认创建一个线程池</span></span><br><span class="line">    fut = loop.run_in_executor(<span class="literal">None</span>, func_1)</span><br><span class="line">    result = <span class="keyword">await</span> fut</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前方式会自动创建一个线程池去执行普通函数: &#x27;</span>, result)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在协程函数中运行基于线程池的任务, 效果与以上代码一致</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">        result = <span class="keyword">await</span> loop.run_in_executor(pool, func_1)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;在线程池中得到的执行结果: &#x27;</span>, result)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在协程函数中运行基于进程池的任务</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor() <span class="keyword">as</span> pool:</span><br><span class="line">        result = <span class="keyword">await</span> loop.run_in_executor(pool, func_1)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;在进程池中得到的执行结果: &#x27;</span>, result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>
<p>案例：asyncio + 不支持异步的模块（requests）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">download_image</span>(<span class="params">url</span>):</span><br><span class="line">  	<span class="comment"># 发送网络请求，下载图片（遇到网络下载图片的 IO 请求，自动切换到其他任务）</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始下载: &#x27;</span>, url)</span><br><span class="line">    </span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    <span class="comment"># requests 模块默认不支持异步操作，所以使用线程池来配合实现</span></span><br><span class="line">    future = loop.run_in_executor(<span class="literal">None</span>, requests.get, url)</span><br><span class="line">    response = <span class="keyword">await</span> future</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;下载完成...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存图片</span></span><br><span class="line">    file_name = url.rsplit(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_name, mode =<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(response.content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url_list = [</span><br><span class="line">        <span class="string">&#x27;http://pic.bizhi360.com/bbpic/98/10798.jpg&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;http://pic.bizhi360.com/bbpic/92/10792.jpg&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;http://pic.bizhi360.com/bbpic/86/10386.jpg&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">    </span><br><span class="line">    tasks = [download_image(url) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]</span><br><span class="line">    <span class="comment"># loop = asyncio.get_event_loop()</span></span><br><span class="line">    <span class="comment"># loop.run_until_complete(asyncio.wait(tasks))</span></span><br><span class="line">    asyncio.run(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实就是多线程实现并发。。</p>
</blockquote>
<h4 id="异步迭代器"><s>异步迭代器</s></h4>
<blockquote>
<p>什么是异步迭代器？</p>
<p>实现了<code>__aiter__()</code> 和 <code>__anext__()</code> 方法的对象。<code>__aiter__()</code> 必须返回一个<code>awaitable</code>对象。<code>async for</code>会处理异步迭代器的 <code>__anext__() </code>方法所返回的可等待对象，直到引发一个<code>StopAsyncIteration</code>异常。</p>
<p>什么是异步可迭代对象？</p>
<p>可在<code>async for</code>语句中被使用的对象。必须通过它的<code>__aiter__()</code>方法返回一个<code>asynchronous iterator</code>。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义异步迭代器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">readline</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># await asyncio.sleep(1)</span></span><br><span class="line">        <span class="variable language_">self</span>.count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.count == <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.count</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__aiter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__anext__</span>(<span class="params">self</span>):</span><br><span class="line">        val = <span class="keyword">await</span> <span class="variable language_">self</span>.readline()</span><br><span class="line">        <span class="keyword">if</span> val <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopAsyncIteration</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    obj = Reader()</span><br><span class="line">    <span class="comment"># 异步 for 循环必须在协程函数内执行，协程函数名称随意取名</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">for</span> item <span class="keyword">in</span> obj:</span><br><span class="line">        <span class="built_in">print</span>(item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(func())</span><br></pre></td></tr></table></figure>
<h4 id="异步上下文管理器">异步上下文管理器</h4>
<blockquote>
<p>此种现象通过定义<code>__aenter__()</code>和<code>__axeit__()</code>方法来对<code>async with</code>语句中的环境进行控制。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AsyncContextManager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, conn = <span class="literal">None</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.conn = conn</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">do_something</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 异步操作数据库</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;crud&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__aenter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 异步连接数据库</span></span><br><span class="line">        <span class="variable language_">self</span>.conn = <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__aexit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        <span class="comment"># 异步关闭数据库连接</span></span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">func</span>():</span><br><span class="line">    <span class="comment"># 上下文管理器处理也需要在协程函数中运行</span></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> AsyncContextManager() <span class="keyword">as</span> f:</span><br><span class="line">        result = <span class="keyword">await</span> f.do_something()</span><br><span class="line">        <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(func())</span><br></pre></td></tr></table></figure>
<h4 id="uvloop">uvloop</h4>
<p>是asyncio的事件循环的替代方案。</p>
<p>uvloop事件循环的执行效率比asyncio默认的事件循环的效率高。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pip install uvloop</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> uvloop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置事件循环为 uvloop</span></span><br><span class="line">asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写的 asyncio 代码与之前一致</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 内部事件循环会自动切到 uvloop</span></span><br><span class="line">asyncio.run(...)</span><br></pre></td></tr></table></figure>
<h3 id="实战案例">实战案例</h3>
<h4 id="异步操作-Redis">异步操作 Redis</h4>
<p>在使用python代码操作redis时，像连接、读取/写入、断开都是IO操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install aioredis == <span class="number">1.3</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>
<p>案例1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aioredis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">address</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始执行: &#x27;</span>, address)</span><br><span class="line">    <span class="comment"># 网络 IO 创建 redis 连接</span></span><br><span class="line">    redis = <span class="keyword">await</span> aioredis.create_redis(address)</span><br><span class="line">    <span class="comment"># 网络 IO 在 redis 中设置哈希值</span></span><br><span class="line">    <span class="keyword">await</span> redis.hmset_dict(<span class="string">&#x27;car&#x27;</span>, key1 = <span class="number">1</span>, key2 = <span class="number">2</span>, key3 = <span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 网络 IO 获取 redis 中的值</span></span><br><span class="line">    result = <span class="keyword">await</span> redis.hgetall(<span class="string">&#x27;car&#x27;</span>, encoding =<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    redis.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络 IO 关闭 redis 连接</span></span><br><span class="line">    <span class="keyword">await</span> redis.wait_closed()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;结束...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(execute(<span class="string">&#x27;redis://127.0.0.1: 6379/0&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>案例2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aioredis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">address, password</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始执行: &#x27;</span>, address)</span><br><span class="line">    <span class="comment"># 网络 IO 创建 redis 连接</span></span><br><span class="line">    redis = <span class="keyword">await</span> aioredis.create_redis_pool(address, password = password)</span><br><span class="line">    <span class="comment"># 网络 IO 在 redis 中设置哈希值</span></span><br><span class="line">    <span class="keyword">await</span> redis.hmset_dict(<span class="string">&#x27;car&#x27;</span>, key1 = <span class="number">1</span>, key2 = <span class="number">2</span>, key3 = <span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 网络 IO 获取 redis 中的值</span></span><br><span class="line">    result = <span class="keyword">await</span> redis.hgetall(<span class="string">&#x27;car&#x27;</span>, encoding =<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line">    redis.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络 IO 关闭 redis 连接</span></span><br><span class="line">    <span class="keyword">await</span> redis.wait_closed()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;结束...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">task_list = [</span><br><span class="line">    execute(<span class="string">&#x27;redis://localhost: 6379/0&#x27;</span>, <span class="literal">None</span>),</span><br><span class="line">    execute(<span class="string">&#x27;redis://localhost: 6379/1&#x27;</span>, <span class="literal">None</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(asyncio.wait(task_list))</span><br></pre></td></tr></table></figure>
<h4 id="异步-MySQL">异步 MySQL</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install aiomysql</span><br></pre></td></tr></table></figure>
<p>案例1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiomysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">execute</span>():</span><br><span class="line">    <span class="comment"># 网络 IO 操作 连接 mysql</span></span><br><span class="line">    conn = <span class="keyword">await</span> aiomysql.connect(host =<span class="string">&#x27;127.0.0.1&#x27;</span>, port = <span class="number">3306</span>, user =<span class="string">&#x27;root&#x27;</span>, password =<span class="string">&#x27;root&#x27;</span>, db =<span class="string">&#x27;mysql&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络 IO 操作 创建游标</span></span><br><span class="line">    cursor = <span class="keyword">await</span> conn.cursor()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络 IO 操作 执行 sql</span></span><br><span class="line">    <span class="keyword">await</span> cursor.execute(<span class="string">&#x27;select host, user from user&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络 IO 操作 获取 sql 结果</span></span><br><span class="line">    result = <span class="keyword">await</span> cursor.fetchall()</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络 IO 操作</span></span><br><span class="line">    <span class="keyword">await</span> cursor.close()</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(execute())</span><br></pre></td></tr></table></figure>
<p>案例2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiomysql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">host, password</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始连接:&#x27;</span>, host)</span><br><span class="line">    <span class="comment"># 网络 IO 操作 连接 mysql</span></span><br><span class="line">    conn = <span class="keyword">await</span> aiomysql.connect(host = host, port = <span class="number">3306</span>, user =<span class="string">&#x27;root&#x27;</span>, password = password, db =<span class="string">&#x27;mysql&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络 IO 操作 创建游标</span></span><br><span class="line">    cursor = <span class="keyword">await</span> conn.cursor()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络 IO 操作 执行 sql</span></span><br><span class="line">    <span class="keyword">await</span> cursor.execute(<span class="string">&#x27;select host, user from user&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络 IO 操作 获取 sql 结果</span></span><br><span class="line">    result = <span class="keyword">await</span> cursor.fetchall()</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 网络 IO 操作</span></span><br><span class="line">    <span class="keyword">await</span> cursor.close()</span><br><span class="line">    conn.close()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;结束:&#x27;</span>, host)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">task_list = [</span><br><span class="line">    execute(<span class="string">&#x27;localhost&#x27;</span>, <span class="string">&#x27;root&#x27;</span>),</span><br><span class="line">    execute(<span class="string">&#x27;localhost&#x27;</span>, <span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(asyncio.wait(task_list))</span><br></pre></td></tr></table></figure>
<h4 id="FastAPI框架"><code>FastAPI</code>框架</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install uvicorn</span><br><span class="line">pip install fastapi</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uvicorn</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aioredis</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line">app = FastAPI()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 redis 连接池</span></span><br><span class="line">REDIS_POOL = aioredis.ConnectionsPool(<span class="string">&#x27;redis://localhost: 6379&#x27;</span>, password = <span class="literal">None</span>, minsize = <span class="number">1</span>, maxsize = <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&#x27;/&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="comment"># 普通视图函数</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&#x27;message&#x27;</span>: <span class="string">&#x27;hello world&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.get(<span class="params"><span class="string">&#x27;/red&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">red</span>():</span><br><span class="line">    <span class="comment"># 异步视图</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;请求来了...&#x27;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取连接池中的一个链接</span></span><br><span class="line">    conn = <span class="keyword">await</span> REDIS_POOL.acquire()</span><br><span class="line">    redis = aioredis.Redis(conn)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设置值</span></span><br><span class="line">    <span class="keyword">await</span> redis.hmset_dict(<span class="string">&#x27;car_fastApi&#x27;</span>, key1 = <span class="number">1</span>, key2 = <span class="number">2</span>, key3 = <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取值</span></span><br><span class="line">    result = <span class="keyword">await</span> redis.hgetall(<span class="string">&#x27;car_fastApi&#x27;</span>, encoding =<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(result)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将单个连接归还给连接池</span></span><br><span class="line">    REDIS_POOL.release(conn)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  	<span class="comment"># fastapi_test 为当前这个脚本文件的名称</span></span><br><span class="line">    uvicorn.run(<span class="string">&quot;fastapi_test: app&quot;</span>, host =<span class="string">&#x27;127.0.0.1&#x27;</span>, port = <span class="number">5000</span>, log_level =<span class="string">&#x27;info&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="爬虫">爬虫</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch</span>(<span class="params">session, url</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;发送请求: &#x27;</span>, url)</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> session.get(url, verify_ssl = <span class="literal">False</span>) <span class="keyword">as</span> response:</span><br><span class="line">        text = <span class="keyword">await</span> response.text()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;结果: &#x27;</span>, url, <span class="built_in">len</span>(text))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        url_list = [</span><br><span class="line">            <span class="string">&#x27;https://python.org&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;https://www.baidu.com&#x27;</span>,</span><br><span class="line">        ]</span><br><span class="line"></span><br><span class="line">        tasks = [asyncio.create_task(fetch(session, url)) <span class="keyword">for</span> url <span class="keyword">in</span> url_list]</span><br><span class="line">        <span class="keyword">await</span> asyncio.wait(tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>python</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://www.fomal.cc/posts/a4d4b8.html">https://www.fomal.cc/posts/a4d4b8.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>czz🕉️</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2023-01-14</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2025-05-10</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/"><div class="tags-punctuation"><svg class="faa-tada icon" style="height:1.1em;width:1.1em;fill:currentColor;position:relative;top:2px;margin-right:3px" aria-hidden="true"><use xlink:href="#icon-sekuaibiaoqian"></use></svg></div>python</a></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/2.webp" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://tuchuang.voooe.cn/images/2023/01/04/20f8e49805975b8f8.webp" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://npm.elemecdn.com/akilar-candyassets@1.0.36/audio/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/db30bcc7.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.staticaly.com/gh/czzczzczz/image@main/202302081605208.png" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">matlab</div></div></a></div><div class="next-post pull-right"><a href="/posts/758c1bd4.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_14.webp" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">xind使用教程</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Python-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-text">Python 基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-text">字面量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-text">注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">数据类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%89%A9%E5%B1%95"><span class="toc-text">字符串扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5"><span class="toc-text">数据输入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6%EF%BC%88%E5%BF%85%E9%A1%BB%E6%98%AF%E5%8F%8D%E6%96%9C%E6%9D%A0%EF%BC%89"><span class="toc-text">转义字符（必须是反斜杠）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5"><span class="toc-text">Python判断语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%AF%94%E8%BE%83%E3%80%81%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">布尔类型和比较、逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F"><span class="toc-text">if语句的基本格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if-else-%E8%AF%AD%E5%8F%A5"><span class="toc-text">if else 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#if-elif-else%E8%AF%AD%E5%8F%A5"><span class="toc-text">if elif else语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%B5%8C%E5%A5%97"><span class="toc-text">判断语句的嵌套</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-text">Python循环语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#while%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-text">while循环的基础语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#while%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A1%88%E4%BE%8B"><span class="toc-text">while循环的基础案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#while%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%B5%8C%E5%A5%97%E5%BA%94%E7%94%A8"><span class="toc-text">while循环的嵌套应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#while%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%B5%8C%E5%A5%97%E6%A1%88%E4%BE%8B"><span class="toc-text">while循环的嵌套案例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-text">for循环的基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-text">基础语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#range%E8%AF%AD%E5%8F%A5"><span class="toc-text">range语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">变量作用域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%B5%8C%E5%A5%97%E5%BA%94%E7%94%A8"><span class="toc-text">for循环的嵌套应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%B8%AD%E6%96%AD-break%E5%92%8Ccontinue-%E5%8F%AA%E4%BD%9C%E7%94%A8%E4%BA%8E%E5%BE%AA%E7%8E%AF%EF%BC%8C%E5%92%8C%E5%88%A4%E6%96%AD%E6%97%A0%E5%85%B3"><span class="toc-text">循环中断 : break和continue(只作用于循环，和判断无关)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84-else"><span class="toc-text">循环中的 else</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5"><span class="toc-text">引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#while%E2%80%A6else%E2%80%A6-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">while…else… 的使用方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B"><span class="toc-text">代码案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for%E2%80%A6else%E2%80%A6-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-text">for…else… 的使用方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%88%E4%BE%8B-2"><span class="toc-text">代码案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81-continue"><span class="toc-text">验证 continue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python%E5%87%BD%E6%95%B0"><span class="toc-text">Python函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BB%8B%E7%BB%8D"><span class="toc-text">函数介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">函数的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-text">函数的参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">函数的返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">函数返回值的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#None%E7%B1%BB%E5%9E%8B"><span class="toc-text">None类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E%E6%96%87%E6%A1%A3"><span class="toc-text">函数说明文档</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%B5%8C%E5%A5%97%E8%B0%83%E7%94%A8"><span class="toc-text">函数的嵌套调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-text">变量的作用域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-Python%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%EF%BC%88-%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5-%EF%BC%89"><span class="toc-text">2.5 Python数据容器（&#x3D;&#x3D;增删改查&#x3D;&#x3D;）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%E5%85%A5%E9%97%A8"><span class="toc-text">1. 数据容器入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%EF%BC%9Alist-%E5%88%97%E8%A1%A8"><span class="toc-text">2. 数据容器：list(列表)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%97%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1. 列表的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%97%E8%A1%A8%E7%9A%84%E4%B8%8B%E6%A0%87%E7%B4%A2%E5%BC%95"><span class="toc-text">2. 列表的下标索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%97%E8%A1%A8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">3. 列表的常用操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%88%97%E8%A1%A8%E7%9A%84%E6%96%B9%E6%B3%95-%E6%80%BB%E8%A7%88"><span class="toc-text">4. 列表的方法 - 总览</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-list%EF%BC%88%E5%88%97%E8%A1%A8%EF%BC%89%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">3. list（列表）的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%EF%BC%9Atuple-%E5%85%83%E7%BB%84"><span class="toc-text">4. 数据容器：tuple(元组)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%85%83%E7%BB%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1. 元组的定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%EF%BC%9Astr-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">5. 数据容器：str(字符串)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%B1%87%E6%80%BB"><span class="toc-text">&#x3D;&#x3D;字符串常用操作汇总&#x3D;&#x3D;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%EF%BC%88%E5%BA%8F%E5%88%97%EF%BC%89%E7%9A%84%E5%88%87%E7%89%87"><span class="toc-text">6. 数据容器（序列）的切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-set-%E9%9B%86%E5%90%88"><span class="toc-text">7. set(集合)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%EF%BC%9Adict-%E5%AD%97%E5%85%B8%E3%80%81%E6%98%A0%E5%B0%84"><span class="toc-text">8. 数据容器：dict(字典、映射)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AD%97%E5%85%B8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1. 字典的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%97%E5%85%B8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">2. 字典的常用操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%95%B0%E6%8D%AE%E5%AE%B9%E5%99%A8%E7%9A%84%E5%AF%B9%E6%AF%94%E5%92%8C%E9%80%9A%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">9. 数据容器的对比和通用操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="toc-text">10. 推导式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="toc-text">列表推导式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="toc-text">集合推导式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E6%8E%A8%E5%AF%BC%E5%BC%8F"><span class="toc-text">字典推导式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%86%E5%8C%85"><span class="toc-text">拆包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-Python%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6"><span class="toc-text">2.6 Python函数进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">1. 函数多返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%E5%A4%9A%E7%A7%8D%E4%BC%A0%E5%8F%82%E6%96%B9%E5%BC%8F"><span class="toc-text">2. 函数多种传参方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-text">1. 位置参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%82%E6%95%B0"><span class="toc-text">2. 关键字参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0"><span class="toc-text">3. 缺省参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%8D%E5%AE%9A%E9%95%BF%E5%8F%82%E6%95%B0"><span class="toc-text">4. 不定长参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-text">3. 匿名函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-text">1. 函数作为参数传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0"><span class="toc-text">2. lambda匿名函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E6%8B%86%E5%8C%85"><span class="toc-text">3. 函数返回值拆包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E6%8B%86%E5%8C%85"><span class="toc-text">什么是函数返回值拆包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC%E6%8B%86%E5%8C%85%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">返回值拆包的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E6%98%9F%E5%8F%B7%E6%8B%86%E5%8C%85"><span class="toc-text">通过星号拆包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Python%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-text">4. Python语言中的引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%95%E7%94%A8"><span class="toc-text">什么是引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%BD%93%E5%81%9A%E5%AE%9E%E5%8F%82"><span class="toc-text">引用当做实参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%90%8D%E4%B9%9F%E6%98%AF%E5%BC%95%E7%94%A8"><span class="toc-text">函数名也是引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">引用的作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-Python%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-text">2.7 Python文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E7%A0%81"><span class="toc-text">1. 文件的编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%8F%96"><span class="toc-text">2. 文件的读取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%BD%E5%8A%A0"><span class="toc-text">4. 文件的追加</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-Python%E5%BC%82%E5%B8%B8%E3%80%81%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%8C%85"><span class="toc-text">2.8 Python异常、模块与包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%82%E5%B8%B8%E7%9A%84%E6%8D%95%E8%8E%B7%E6%96%B9%E6%B3%95"><span class="toc-text">1. 异常的捕获方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BC%A0%E9%80%92"><span class="toc-text">2. 异常的传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Python%E6%A8%A1%E5%9D%97"><span class="toc-text">3. Python模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%AF%BC%E5%85%A5"><span class="toc-text">1. 模块的导入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97"><span class="toc-text">2. 自定义模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Python%E5%8C%85"><span class="toc-text">3. Python包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85"><span class="toc-text">自定义包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8C%85"><span class="toc-text">安装第三方包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">2.9 面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9D%E8%AF%86%E5%AF%B9%E8%B1%A1"><span class="toc-text">1. 初识对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95"><span class="toc-text">2. 成员方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-text">3. 类和对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">4. 构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94"><span class="toc-text">对象关联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E8%BF%9B%E8%A1%8C%E5%85%B3%E8%81%94"><span class="toc-text">将两个对象进行关联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%85%B3%E8%81%94%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-text">调用关联的对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-text">关联多个对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%85%B6%E5%AE%83%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95"><span class="toc-text">5. 其它内置方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-str-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%B9%E6%B3%95"><span class="toc-text">1. str 字符串方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-lt-%E5%B0%8F%E4%BA%8E%E7%AC%A6%E5%8F%B7%E6%AF%94%E8%BE%83%E6%96%B9%E6%B3%95"><span class="toc-text">2. __lt__ 小于符号比较方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-le-%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E%E6%AF%94%E8%BE%83%E7%AC%A6%E5%8F%B7%E6%96%B9%E6%B3%95"><span class="toc-text">3. __le__ 小于等于比较符号方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-eq-%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6%E6%96%B9%E6%B3%95"><span class="toc-text">4. __eq__ 比较运算符方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%B0%81%E8%A3%85"><span class="toc-text">6. 封装</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93"><span class="toc-text">简单总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%BB%A7%E6%89%BF"><span class="toc-text">7. 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%BB%A7%E6%89%BF%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-text">1. 继承的基础语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%A4%8D%E5%86%99%E5%92%8C%E4%BD%BF%E7%94%A8%E7%88%B6%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-text">2. 复写和使用父类成员</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-text">8. 类型注解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%98%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-text">1. 变量的类型注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%87%BD%E6%95%B0%EF%BC%88%E6%96%B9%E6%B3%95%EF%BC%89%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-text">2. 函数（方法）的类型注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Union%E7%B1%BB%E5%9E%8B"><span class="toc-text">3. Union类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%A4%9A%E6%80%81"><span class="toc-text">9. 多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93-2"><span class="toc-text">简单总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">10. 静态方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5-2"><span class="toc-text">引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">静态方法的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">代码示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93-3"><span class="toc-text">简单总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E7%B1%BB%E5%B1%9E%E6%80%A7"><span class="toc-text">11. 类属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5-3"><span class="toc-text">引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%B1%9E%E6%80%A7%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">类属性的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-2"><span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">12. 类方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5-4"><span class="toc-text">引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E6%96%B9%E6%B3%95%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">类方法的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-text">示例代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93-4"><span class="toc-text">简单总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-text">13. 类对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5-5"><span class="toc-text">引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">类对象的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">类对象的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E6%80%8E%E4%B9%88%E7%94%A8%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-text">实例对象怎么用类对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dir-%E6%96%B9%E6%B3%95"><span class="toc-text">dir() 方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93-5"><span class="toc-text">简单总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%B1%9E%E6%80%A7%E3%80%81%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7"><span class="toc-text">类属性、实例属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E3%80%81%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-text">实例方法、静态方法和类方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%BB%A5%E5%8F%8AMRO%E9%A1%BA%E5%BA%8F"><span class="toc-text">14. 多继承以及MRO顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%AD%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C%E7%BB%93%E6%9E%9C%E4%B8%8D%E5%90%8C"><span class="toc-text">多继承中调用父类方式不同结果不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84super"><span class="toc-text">单继承中的super</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93-6"><span class="toc-text">简单总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-text">面试题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">15. 单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-object%E5%9F%BA%E7%B1%BB"><span class="toc-text">16. object基类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-Python%E9%AB%98%E9%98%B6%E6%8A%80%E5%B7%A7"><span class="toc-text">2.10 Python高阶技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">1. 迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5-6"><span class="toc-text">引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3"><span class="toc-text">什么是迭代</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1"><span class="toc-text">可迭代对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">自定义迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for-in-%E5%BE%AA%E7%8E%AF%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">for...in...循环的本质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E4%B8%8D%E6%98%AF%E5%8F%AA%E6%9C%89for%E5%BE%AA%E7%8E%AF%E8%83%BD%E6%8E%A5%E6%94%B6%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1"><span class="toc-text">并不是只有for循环能接收可迭代对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%80%BB%E7%BB%93-7"><span class="toc-text">简单总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%8F%E5%A0%82%E4%BD%9C%E4%B8%9A"><span class="toc-text">随堂作业</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-text">2. 生成器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5-7"><span class="toc-text">引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">生成器工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">生成器表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E5%99%A8%E4%B8%AD%E7%9A%84send-%E4%B8%8Eclose-%E6%96%B9%E6%B3%95"><span class="toc-text">生成器中的send()与close()方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%97%AD%E5%8C%85"><span class="toc-text">3. 闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5-8"><span class="toc-text">引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-text">问题解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%95%E7%94%A8"><span class="toc-text">函数引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">闭包的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E6%A1%88%E4%BE%8B"><span class="toc-text">闭包案例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">使用闭包需要注意的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85%E4%BF%AE%E6%94%B9%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F"><span class="toc-text">使用闭包修改外部函数中的变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E9%97%AD%E5%8C%85"><span class="toc-text">多个闭包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E6%80%BB%E7%BB%93"><span class="toc-text">闭包总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">4. 装饰器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">为什么需要装饰器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">如何实现一个装饰器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">带参数的装饰器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">基于类的装饰器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E7%B1%BB%E8%A3%85%E9%A5%B0%E5%99%A8"><span class="toc-text">带参数的类装饰器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#property%E5%B1%9E%E6%80%A7"><span class="toc-text">property属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#property-%E7%AE%80%E4%BB%8B"><span class="toc-text">@property - 简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-text">简单的示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#property%E5%B1%9E%E6%80%A7%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">property属性的两种方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#property-%E5%BA%94%E7%94%A8"><span class="toc-text">@property - 应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-text">线程和进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-text">进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B-2"><span class="toc-text">线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-text">对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B"><span class="toc-text">使用线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81"><span class="toc-text">全局解释器锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">多任务的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#threading-%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">threading 模块的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E7%BA%BF%E7%A8%8B%E7%AD%89%E5%BE%85%E6%89%80%E6%9C%89%E5%AD%90%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9D%9F%E5%90%8E%E9%80%80%E5%87%BA"><span class="toc-text">主线程等待所有子线程结束后退出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F"><span class="toc-text">查看线程数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-text">线程执行代码的封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">线程的执行顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%85%B1%E4%BA%AB%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">多线程 - 共享全局变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B%E7%B1%BB%E5%9E%8B%E5%85%B1%E4%BA%AB"><span class="toc-text">整型类型共享</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E7%B1%BB%E5%9E%8B%E5%85%B1%E4%BA%AB"><span class="toc-text">序列类型共享</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%85%B1%E4%BA%AB%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98"><span class="toc-text">多线程 - 共享全局变量问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">同步的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%97%B6%E4%BF%AE%E6%94%B9%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-text">解决线程同时修改全局变量的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-text">互斥锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">互斥锁的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8A%E9%94%81%E8%A7%A3%E9%94%81%E8%BF%87%E7%A8%8B"><span class="toc-text">上锁解锁过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8"><span class="toc-text">简单使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-text">获取执行结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-%E5%92%8Cwait-%E6%96%B9%E6%B3%95"><span class="toc-text">map()和wait()方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B-2"><span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B"><span class="toc-text">什么是进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-text">进程的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA-multiprocessing"><span class="toc-text">进程的创建 - multiprocessing</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AAwhile%E5%BE%AA%E7%8E%AF%E4%B8%80%E8%B5%B7%E6%89%A7%E8%A1%8C"><span class="toc-text">两个while循环一起执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%BF%9B%E7%A8%8B%E7%9A%84pid"><span class="toc-text">获取进程的pid</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%99%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%8C%87%E5%AE%9A%E7%9A%84%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-text">给子进程指定的函数传递参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E4%B8%8D%E5%90%8C%E4%BA%AB%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-text">进程间不同享全局变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%AF%94"><span class="toc-text">进程、线程对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-text">功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-text">定义的不同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-text">区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1-Queue"><span class="toc-text">进程间通信 - Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Queue%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">Queue的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Queue%E5%AE%9E%E4%BE%8B"><span class="toc-text">Queue实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E4%BF%A1%E5%8F%B7"><span class="toc-text">队列信号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA-%E8%BF%9B%E7%A8%8B%E6%B1%A0Pool"><span class="toc-text">进程的创建 - 进程池Pool</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Pool%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E6%B1%A0"><span class="toc-text">使用Pool创建进程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84Queue"><span class="toc-text">进程池中的Queue</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B-asyncio"><span class="toc-text">协程 - asyncio</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-text">协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E6%84%8F%E4%B9%89"><span class="toc-text">协程意义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B"><span class="toc-text">异步编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-text">事件循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8"><span class="toc-text">基本应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#await-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">await 关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Task-%E5%AF%B9%E8%B1%A1"><span class="toc-text">Task 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#asyncio-Future-%E5%AF%B9%E8%B1%A1"><span class="toc-text">asyncio.Future 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#concurrent-futures-Future-%E5%AF%B9%E8%B1%A1"><span class="toc-text">concurrent.futures.Future 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">异步迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-text">异步上下文管理器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#uvloop"><span class="toc-text">uvloop</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B"><span class="toc-text">实战案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C-Redis"><span class="toc-text">异步操作 Redis</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5-MySQL"><span class="toc-text">异步 MySQL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FastAPI%E6%A1%86%E6%9E%B6"><span class="toc-text">FastAPI框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%88%AC%E8%99%AB"><span class="toc-text">爬虫</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">魔改指南</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/box/Gallery/">我的画廊</a><a href="/personal/bb/">我的唠叨</a></li><li><a href="/site/time/">建设进程</a><a href="/site/census/">网站统计</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a href="https://www.fomal.cc/" title="Fomalhaut🥝"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/60e5d4e39da7c077.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2022-2025</b></span><span><b>&nbsp;&nbsp;By czz🕉️</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20226665" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20226665号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/萌ICP备-20226665-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Bucket-缤纷云-9c62da.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://sourcebucket.s3.ladydaily.com/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.staticfile.org/fancyapps-ui/4.0.31/fancybox.umd.min.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/instant.page/5.1.0/instantpage.min.js" type="module"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/vanilla-lazyload/17.3.1/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: '',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: '',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.staticfile.org/jquery/3.6.3/jquery.min.js"></script><script async src="https://cdn1.tianli0.top/npm/vue@2.6.14/dist/vue.min.js"></script><script async src="https://cdn1.tianli0.top/npm/element-ui@2.15.6/lib/index.js"></script><script async src="https://cdn.bootcdn.net/ajax/libs/clipboard.js/2.0.11/clipboard.min.js"></script><script defer type="text/javascript" src="https://cdn1.tianli0.top/npm/sweetalert2@8.19.0/dist/sweetalert2.all.js"></script><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer src="https://cdn1.tianli0.top/gh/nextapps-de/winbox/dist/winbox.bundle.min.js"></script><script async src="//at.alicdn.com/t/c/font_3586335_hsivh70x0fm.js"></script><script async src="//at.alicdn.com/t/c/font_3636804_gr02jmjr3y9.js"></script><script async src="//at.alicdn.com/t/c/font_3612150_kfv55xn3u2g.js"></script><script async src="https://cdn.wpon.cn/2022-sucai/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/fomal.js"></script><div class="aplayer no-destroy" data-id="2379161415" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-lrcType="-1"> </div><link rel="stylesheet" href="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/aplayer/1.10.1/APlayer.min.js"></script><script src="https://cdn1.tianli0.top/npm/js-heo@1.0.12/metingjs/Meting.min.js"></script><script src="https://lib.baomitu.com/pjax/0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><a class="magnet_link_more"  href="https://www.fomal.cc/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #e9e9e9;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><script data-pjax src="https://npm.elemecdn.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><!-- hexo injector body_end end --></body></html>